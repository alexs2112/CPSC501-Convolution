commit 910b2dd8769658b51c23c875fa4a104d3130fe42
Author: alexs2112 <alexste2112@gmail.com>
Date:   Mon Dec 4 15:24:38 2023 -0700

    compiler-level optimization

diff --git a/Makefile b/Makefile
index 7975d14..9a3c13a 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,5 @@
 convolve: convolve.cpp
-	g++ -g -p -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+	g++ -O3 -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
 
 test: test.cpp
-	g++ -g -o test test.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+	g++ -g -O3 -o test test.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
diff --git a/report.md b/report.md
index fefb216..a9403fd 100644
--- a/report.md
+++ b/report.md
@@ -346,7 +346,7 @@ sys     0m0.094s
  - The `complex_multiply` function continues to be the second slowest function during execution of the code.
  - The performance of this function can be improved by Partially Unrolling the code 3 times
 
-**Commit**: []()
+**Commit**: [05695544be809617d20fedbb02247b5f1d7caa86](https://github.com/alexs2112/CPSC501-Convolution/commit/05695544be809617d20fedbb02247b5f1d7caa86)
 
 **Code Changes**:
 ```c
@@ -425,10 +425,10 @@ sys     0m0.087s
 **Code Changes**:
 ```Makefile
 convolve: convolve.cpp
-	g++ -O3 -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+	g++ -O3 -o convolve convolve.cpp ...
 
 test: test.cpp
-	g++ -g -O3 -o test test.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+	g++ -g -O3 -o test test.cpp ...
 ```
 
 **Run Time Performance**:

commit 05695544be809617d20fedbb02247b5f1d7caa86
Author: alexs2112 <alexste2112@gmail.com>
Date:   Mon Dec 4 15:21:17 2023 -0700

    manual tuning: partial unrolling of complex_multiply function

diff --git a/README.md b/README.md
index b43fa0a..22d7d2e 100644
--- a/README.md
+++ b/README.md
@@ -62,6 +62,6 @@ Unit tests are available through the `test.cpp` file that implements a custom un
 >>> ./test
 
 Test Run Complete.
-Tests Run: 4
+Tests Run: 5
 Test Failed: 0
 ```
diff --git a/modules/fast_fourier.cpp b/modules/fast_fourier.cpp
index ee8b04b..c821972 100644
--- a/modules/fast_fourier.cpp
+++ b/modules/fast_fourier.cpp
@@ -100,11 +100,28 @@ struct complex_param {
 void *complex_multiply(void *v) {
     // Perform complex multiplication
     complex_param p = ((complex_param *)v)[0];
-    for (int k = 0; k < p.size; k += 2) {
+    int k;
+    for (k = 0; k < p.size; k += 6) {
         // Re Y[k] = Re X[k] Re H[k] - Im X[k] Im H[k]
         // Im Y[k] = Im X[k] Re H[k] + Re X[k] Im H[k]
         p.output[k] = p.x[k] * p.h[k] - p.x[k+1] * p.h[k+1];
         p.output[k+1] = p.x[k+1] * p.h[k] + p.x[k] * p.h[k+1];
+
+        p.output[k+2] = p.x[k+2] * p.h[k+2] - p.x[k+3] * p.h[k+3];
+        p.output[k+3] = p.x[k+3] * p.h[k+2] + p.x[k+2] * p.h[k+3];
+
+        p.output[k+4] = p.x[k+4] * p.h[k+4] - p.x[k+5] * p.h[k+5];
+        p.output[k+5] = p.x[k+5] * p.h[k+4] + p.x[k+4] * p.h[k+5];
+    }
+    if (k == p.size - 4) {
+        p.output[k] = p.x[k] * p.h[k] - p.x[k+1] * p.h[k+1];
+        p.output[k+1] = p.x[k+1] * p.h[k] + p.x[k] * p.h[k+1];
+        p.output[k+2] = p.x[k+2] * p.h[k+2] - p.x[k+3] * p.h[k+3];
+        p.output[k+3] = p.x[k+3] * p.h[k+2] + p.x[k+2] * p.h[k+3];
+    }
+    if (k == p.size - 2) {
+        p.output[k] = p.x[k] * p.h[k] - p.x[k+1] * p.h[k+1];
+        p.output[k+1] = p.x[k+1] * p.h[k] + p.x[k] * p.h[k+1];
     }
     return 0;
 }
diff --git a/profiling/flute-manual-5.out b/profiling/flute-manual-5.out
new file mode 100644
index 0000000..f365c1b
Binary files /dev/null and b/profiling/flute-manual-5.out differ
diff --git a/profiling/flute-manual-5.txt b/profiling/flute-manual-5.txt
new file mode 100644
index 0000000..5f7babe
--- /dev/null
+++ b/profiling/flute-manual-5.txt
@@ -0,0 +1,284 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 93.00      3.72     3.72        3     1.24     1.24  four1(float*, int, int)
+  3.00      3.84     0.12                             complex_multiply(void*)
+  1.75      3.91     0.07        2     0.04     0.04  zero_padding(float*, int, float*, int)
+  1.25      3.96     0.05        1     0.05     3.85  convolution(wav_file, wav_file)
+  0.50      3.98     0.02        2     0.01     0.01  get_file_data(file_data&, _IO_FILE*, int)
+  0.25      3.99     0.01  2810253     0.00     0.00  double_to_short(double)
+  0.25      4.00     0.01       10     0.00     0.00  int_from_buffer(char*)
+  0.00      4.00     0.00  2810346     0.00     0.00  std::abs(float)
+  0.00      4.00     0.00  2810262     0.00     0.00  short_from_buffer(char*)
+  0.00      4.00     0.00  2810257     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  0.00      4.00     0.00  2810254     0.00     0.00  short_to_float(short)
+  0.00      4.00     0.00       66     0.00     0.00  std::sin(float)
+  0.00      4.00     0.00        5     0.00     0.00  fwriteIntLSB(int, _IO_FILE*)
+  0.00      4.00     0.00        2     0.00     0.00  exit_if_invalid(char*)
+  0.00      4.00     0.00        2     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.00      4.00     0.00        2     0.00     0.00  get_file_header(file_header&, _IO_FILE*)
+  0.00      4.00     0.00        2     0.00     0.02  read_file(char*)
+  0.00      4.00     0.00        1     0.00     0.00  create_wav(short*, int, wav_file)
+  0.00      4.00     0.00        1     0.00     0.00  next_power(unsigned int)
+  0.00      4.00     0.00        1     0.00     0.00  write_to_file(wav_file, char*)
+  0.00      4.00     0.00        1     0.00     3.79  fft_convolution(float*, int, float*, int, float*, int)
+  0.00      4.00     0.00        1     0.00     0.00  write_file_data(file_data, _IO_FILE*, int)
+  0.00      4.00     0.00        1     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      4.00     0.00        1     0.00     0.00  write_file_header(file_header, _IO_FILE*)
+  0.00      4.00     0.00        1     0.00     0.00  multithread_multiply(float*, float*, float*, int)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.25% of 4.00 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     97.0    0.00    3.88                 main [1]
+                0.05    3.80       1/1           convolution(wav_file, wav_file) [2]
+                0.00    0.03       2/2           read_file(char*) [7]
+                0.00    0.00       2/2           exit_if_invalid(char*) [25]
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [28]
+-----------------------------------------------
+                0.05    3.80       1/1           main [1]
+[2]     96.2    0.05    3.80       1         convolution(wav_file, wav_file) [2]
+                0.00    3.79       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+                0.01    0.00 2810253/2810253     double_to_short(double) [9]
+                0.00    0.00 2810346/2810346     std::abs(float) [19]
+                0.00    0.00 2810254/2810254     short_to_float(short) [22]
+                0.00    0.00       1/1           create_wav(short*, int, wav_file) [26]
+-----------------------------------------------
+                0.00    3.79       1/1           convolution(wav_file, wav_file) [2]
+[3]     94.8    0.00    3.79       1         fft_convolution(float*, int, float*, int, float*, int) [3]
+                3.72    0.00       3/3           four1(float*, int, int) [4]
+                0.07    0.00       2/2           zero_padding(float*, int, float*, int) [6]
+                0.00    0.00       1/1           next_power(unsigned int) [27]
+                0.00    0.00       1/1           multithread_multiply(float*, float*, float*, int) [32]
+-----------------------------------------------
+                3.72    0.00       3/3           fft_convolution(float*, int, float*, int, float*, int) [3]
+[4]     93.0    3.72    0.00       3         four1(float*, int, int) [4]
+                0.00    0.00      66/66          std::sin(float) [23]
+-----------------------------------------------
+                                                 <spontaneous>
+[5]      3.0    0.12    0.00                 complex_multiply(void*) [5]
+-----------------------------------------------
+                0.07    0.00       2/2           fft_convolution(float*, int, float*, int, float*, int) [3]
+[6]      1.8    0.07    0.00       2         zero_padding(float*, int, float*, int) [6]
+-----------------------------------------------
+                0.00    0.03       2/2           main [1]
+[7]      0.8    0.00    0.03       2         read_file(char*) [7]
+                0.02    0.00       2/2           get_file_data(file_data&, _IO_FILE*, int) [8]
+                0.00    0.01       2/2           get_file_format(file_fmt&, _IO_FILE*) [11]
+                0.00    0.00       2/2           get_file_header(file_header&, _IO_FILE*) [12]
+-----------------------------------------------
+                0.02    0.00       2/2           read_file(char*) [7]
+[8]      0.6    0.02    0.00       2         get_file_data(file_data&, _IO_FILE*, int) [8]
+                0.00    0.00       2/10          int_from_buffer(char*) [10]
+                0.00    0.00 2810254/2810262     short_from_buffer(char*) [20]
+-----------------------------------------------
+                0.01    0.00 2810253/2810253     convolution(wav_file, wav_file) [2]
+[9]      0.2    0.01    0.00 2810253         double_to_short(double) [9]
+-----------------------------------------------
+                0.00    0.00       2/10          get_file_header(file_header&, _IO_FILE*) [12]
+                0.00    0.00       2/10          get_file_data(file_data&, _IO_FILE*, int) [8]
+                0.01    0.00       6/10          get_file_format(file_fmt&, _IO_FILE*) [11]
+[10]     0.2    0.01    0.00      10         int_from_buffer(char*) [10]
+-----------------------------------------------
+                0.00    0.01       2/2           read_file(char*) [7]
+[11]     0.1    0.00    0.01       2         get_file_format(file_fmt&, _IO_FILE*) [11]
+                0.01    0.00       6/10          int_from_buffer(char*) [10]
+                0.00    0.00       8/2810262     short_from_buffer(char*) [20]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [7]
+[12]     0.1    0.00    0.00       2         get_file_header(file_header&, _IO_FILE*) [12]
+                0.00    0.00       2/10          int_from_buffer(char*) [10]
+-----------------------------------------------
+                0.00    0.00 2810346/2810346     convolution(wav_file, wav_file) [2]
+[19]     0.0    0.00    0.00 2810346         std::abs(float) [19]
+-----------------------------------------------
+                0.00    0.00       8/2810262     get_file_format(file_fmt&, _IO_FILE*) [11]
+                0.00    0.00 2810254/2810262     get_file_data(file_data&, _IO_FILE*, int) [8]
+[20]     0.0    0.00    0.00 2810262         short_from_buffer(char*) [20]
+-----------------------------------------------
+                0.00    0.00       4/2810257     write_file_format(file_fmt, _IO_FILE*) [30]
+                0.00    0.00 2810253/2810257     write_file_data(file_data, _IO_FILE*, int) [29]
+[21]     0.0    0.00    0.00 2810257         fwriteShortLSB(short, _IO_FILE*) [21]
+-----------------------------------------------
+                0.00    0.00 2810254/2810254     convolution(wav_file, wav_file) [2]
+[22]     0.0    0.00    0.00 2810254         short_to_float(short) [22]
+-----------------------------------------------
+                0.00    0.00      66/66          four1(float*, int, int) [4]
+[23]     0.0    0.00    0.00      66         std::sin(float) [23]
+-----------------------------------------------
+                0.00    0.00       1/5           write_file_header(file_header, _IO_FILE*) [31]
+                0.00    0.00       1/5           write_file_data(file_data, _IO_FILE*, int) [29]
+                0.00    0.00       3/5           write_file_format(file_fmt, _IO_FILE*) [30]
+[24]     0.0    0.00    0.00       5         fwriteIntLSB(int, _IO_FILE*) [24]
+-----------------------------------------------
+                0.00    0.00       2/2           main [1]
+[25]     0.0    0.00    0.00       2         exit_if_invalid(char*) [25]
+-----------------------------------------------
+                0.00    0.00       1/1           convolution(wav_file, wav_file) [2]
+[26]     0.0    0.00    0.00       1         create_wav(short*, int, wav_file) [26]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[27]     0.0    0.00    0.00       1         next_power(unsigned int) [27]
+-----------------------------------------------
+                0.00    0.00       1/1           main [1]
+[28]     0.0    0.00    0.00       1         write_to_file(wav_file, char*) [28]
+                0.00    0.00       1/1           write_file_header(file_header, _IO_FILE*) [31]
+                0.00    0.00       1/1           write_file_format(file_fmt, _IO_FILE*) [30]
+                0.00    0.00       1/1           write_file_data(file_data, _IO_FILE*, int) [29]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [28]
+[29]     0.0    0.00    0.00       1         write_file_data(file_data, _IO_FILE*, int) [29]
+                0.00    0.00 2810253/2810257     fwriteShortLSB(short, _IO_FILE*) [21]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [24]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [28]
+[30]     0.0    0.00    0.00       1         write_file_format(file_fmt, _IO_FILE*) [30]
+                0.00    0.00       4/2810257     fwriteShortLSB(short, _IO_FILE*) [21]
+                0.00    0.00       3/5           fwriteIntLSB(int, _IO_FILE*) [24]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [28]
+[31]     0.0    0.00    0.00       1         write_file_header(file_header, _IO_FILE*) [31]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [24]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[32]     0.0    0.00    0.00       1         multithread_multiply(float*, float*, float*, int) [32]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+  [26] create_wav(short*, int, wav_file) [9] double_to_short(double) [30] write_file_format(file_fmt, _IO_FILE*)
+  [27] next_power(unsigned int) [25] exit_if_invalid(char*) [31] write_file_header(file_header, _IO_FILE*)
+   [2] convolution(wav_file, wav_file) [3] fft_convolution(float*, int, float*, int, float*, int) [32] multithread_multiply(float*, float*, float*, int)
+  [24] fwriteIntLSB(int, _IO_FILE*) [11] get_file_format(file_fmt&, _IO_FILE*) [4] four1(float*, int, int)
+   [6] zero_padding(float*, int, float*, int) [12] get_file_header(file_header&, _IO_FILE*) [7] read_file(char*)
+   [8] get_file_data(file_data&, _IO_FILE*, int) [10] int_from_buffer(char*) [19] std::abs(float)
+  [28] write_to_file(wav_file, char*) [29] write_file_data(file_data, _IO_FILE*, int) [23] std::sin(float)
+  [21] fwriteShortLSB(short, _IO_FILE*) [5] complex_multiply(void*)
+  [22] short_to_float(short)  [20] short_from_buffer(char*)
diff --git a/profiling/guitar-manual-5.out b/profiling/guitar-manual-5.out
new file mode 100644
index 0000000..8100449
Binary files /dev/null and b/profiling/guitar-manual-5.out differ
diff --git a/profiling/guitar-manual-5.txt b/profiling/guitar-manual-5.txt
new file mode 100644
index 0000000..2a1afa6
--- /dev/null
+++ b/profiling/guitar-manual-5.txt
@@ -0,0 +1,284 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 89.26      1.33     1.33        3     0.44     0.44  four1(float*, int, int)
+  4.03      1.39     0.06                             complex_multiply(void*)
+  2.01      1.42     0.03  1871492     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  2.01      1.45     0.03        2     0.01     0.01  zero_padding(float*, int, float*, int)
+  1.34      1.47     0.02        2     0.01     0.01  get_file_data(file_data&, _IO_FILE*, int)
+  1.01      1.49     0.01  1871489     0.00     0.00  short_to_float(short)
+  0.34      1.49     0.01        2     0.00     0.00  exit_if_invalid(char*)
+  0.00      1.49     0.00  1871539     0.00     0.00  std::abs(float)
+  0.00      1.49     0.00  1871488     0.00     0.00  double_to_short(double)
+  0.00      1.49     0.00  1769480     0.00     0.00  short_from_buffer(char*)
+  0.00      1.49     0.00   102027     0.00     0.00  int_from_buffer(char*)
+  0.00      1.49     0.00       63     0.00     0.00  std::sin(float)
+  0.00      1.49     0.00        5     0.00     0.00  fwriteIntLSB(int, _IO_FILE*)
+  0.00      1.49     0.00        2     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.00      1.49     0.00        2     0.00     0.00  get_file_header(file_header&, _IO_FILE*)
+  0.00      1.49     0.00        2     0.00     0.01  read_file(char*)
+  0.00      1.49     0.00        1     0.00     0.00  create_wav(short*, int, wav_file)
+  0.00      1.49     0.00        1     0.00     0.00  next_power(unsigned int)
+  0.00      1.49     0.00        1     0.00     1.38  convolution(wav_file, wav_file)
+  0.00      1.49     0.00        1     0.00     0.03  write_to_file(wav_file, char*)
+  0.00      1.49     0.00        1     0.00     1.36  fft_convolution(float*, int, float*, int, float*, int)
+  0.00      1.49     0.00        1     0.00     0.03  write_file_data(file_data, _IO_FILE*, int)
+  0.00      1.49     0.00        1     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      1.49     0.00        1     0.00     0.00  write_file_header(file_header, _IO_FILE*)
+  0.00      1.49     0.00        1     0.00     0.00  multithread_multiply(float*, float*, float*, int)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.67% of 1.49 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     96.0    0.00    1.43                 main [1]
+                0.00    1.38       1/1           convolution(wav_file, wav_file) [2]
+                0.00    0.03       1/1           write_to_file(wav_file, char*) [8]
+                0.00    0.02       2/2           read_file(char*) [11]
+                0.01    0.00       2/2           exit_if_invalid(char*) [13]
+-----------------------------------------------
+                0.00    1.38       1/1           main [1]
+[2]     92.3    0.00    1.38       1         convolution(wav_file, wav_file) [2]
+                0.00    1.36       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+                0.01    0.00 1871489/1871489     short_to_float(short) [12]
+                0.00    0.00 1871539/1871539     std::abs(float) [21]
+                0.00    0.00 1871488/1871488     double_to_short(double) [22]
+                0.00    0.00       1/1           create_wav(short*, int, wav_file) [29]
+-----------------------------------------------
+                0.00    1.36       1/1           convolution(wav_file, wav_file) [2]
+[3]     91.3    0.00    1.36       1         fft_convolution(float*, int, float*, int, float*, int) [3]
+                1.33    0.00       3/3           four1(float*, int, int) [4]
+                0.03    0.00       2/2           zero_padding(float*, int, float*, int) [7]
+                0.00    0.00       1/1           next_power(unsigned int) [30]
+                0.00    0.00       1/1           multithread_multiply(float*, float*, float*, int) [32]
+-----------------------------------------------
+                1.33    0.00       3/3           fft_convolution(float*, int, float*, int, float*, int) [3]
+[4]     89.3    1.33    0.00       3         four1(float*, int, int) [4]
+                0.00    0.00      63/63          std::sin(float) [25]
+-----------------------------------------------
+                                                 <spontaneous>
+[5]      4.0    0.06    0.00                 complex_multiply(void*) [5]
+-----------------------------------------------
+                0.00    0.00       4/1871492     write_file_format(file_fmt, _IO_FILE*) [14]
+                0.03    0.00 1871488/1871492     write_file_data(file_data, _IO_FILE*, int) [9]
+[6]      2.0    0.03    0.00 1871492         fwriteShortLSB(short, _IO_FILE*) [6]
+-----------------------------------------------
+                0.03    0.00       2/2           fft_convolution(float*, int, float*, int, float*, int) [3]
+[7]      2.0    0.03    0.00       2         zero_padding(float*, int, float*, int) [7]
+-----------------------------------------------
+                0.00    0.03       1/1           main [1]
+[8]      2.0    0.00    0.03       1         write_to_file(wav_file, char*) [8]
+                0.00    0.03       1/1           write_file_data(file_data, _IO_FILE*, int) [9]
+                0.00    0.00       1/1           write_file_format(file_fmt, _IO_FILE*) [14]
+                0.00    0.00       1/1           write_file_header(file_header, _IO_FILE*) [31]
+-----------------------------------------------
+                0.00    0.03       1/1           write_to_file(wav_file, char*) [8]
+[9]      2.0    0.00    0.03       1         write_file_data(file_data, _IO_FILE*, int) [9]
+                0.03    0.00 1871488/1871492     fwriteShortLSB(short, _IO_FILE*) [6]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.02    0.00       2/2           read_file(char*) [11]
+[10]     1.3    0.02    0.00       2         get_file_data(file_data&, _IO_FILE*, int) [10]
+                0.00    0.00 1769472/1769480     short_from_buffer(char*) [23]
+                0.00    0.00  102019/102027      int_from_buffer(char*) [24]
+-----------------------------------------------
+                0.00    0.02       2/2           main [1]
+[11]     1.3    0.00    0.02       2         read_file(char*) [11]
+                0.02    0.00       2/2           get_file_data(file_data&, _IO_FILE*, int) [10]
+                0.00    0.00       2/2           get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       2/2           get_file_format(file_fmt&, _IO_FILE*) [27]
+-----------------------------------------------
+                0.01    0.00 1871489/1871489     convolution(wav_file, wav_file) [2]
+[12]     1.0    0.01    0.00 1871489         short_to_float(short) [12]
+-----------------------------------------------
+                0.01    0.00       2/2           main [1]
+[13]     0.3    0.01    0.00       2         exit_if_invalid(char*) [13]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [8]
+[14]     0.0    0.00    0.00       1         write_file_format(file_fmt, _IO_FILE*) [14]
+                0.00    0.00       4/1871492     fwriteShortLSB(short, _IO_FILE*) [6]
+                0.00    0.00       3/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00 1871539/1871539     convolution(wav_file, wav_file) [2]
+[21]     0.0    0.00    0.00 1871539         std::abs(float) [21]
+-----------------------------------------------
+                0.00    0.00 1871488/1871488     convolution(wav_file, wav_file) [2]
+[22]     0.0    0.00    0.00 1871488         double_to_short(double) [22]
+-----------------------------------------------
+                0.00    0.00       8/1769480     get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00 1769472/1769480     get_file_data(file_data&, _IO_FILE*, int) [10]
+[23]     0.0    0.00    0.00 1769480         short_from_buffer(char*) [23]
+-----------------------------------------------
+                0.00    0.00       2/102027      get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       6/102027      get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00  102019/102027      get_file_data(file_data&, _IO_FILE*, int) [10]
+[24]     0.0    0.00    0.00  102027         int_from_buffer(char*) [24]
+-----------------------------------------------
+                0.00    0.00      63/63          four1(float*, int, int) [4]
+[25]     0.0    0.00    0.00      63         std::sin(float) [25]
+-----------------------------------------------
+                0.00    0.00       1/5           write_file_header(file_header, _IO_FILE*) [31]
+                0.00    0.00       1/5           write_file_data(file_data, _IO_FILE*, int) [9]
+                0.00    0.00       3/5           write_file_format(file_fmt, _IO_FILE*) [14]
+[26]     0.0    0.00    0.00       5         fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [11]
+[27]     0.0    0.00    0.00       2         get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00       8/1769480     short_from_buffer(char*) [23]
+                0.00    0.00       6/102027      int_from_buffer(char*) [24]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [11]
+[28]     0.0    0.00    0.00       2         get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       2/102027      int_from_buffer(char*) [24]
+-----------------------------------------------
+                0.00    0.00       1/1           convolution(wav_file, wav_file) [2]
+[29]     0.0    0.00    0.00       1         create_wav(short*, int, wav_file) [29]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[30]     0.0    0.00    0.00       1         next_power(unsigned int) [30]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [8]
+[31]     0.0    0.00    0.00       1         write_file_header(file_header, _IO_FILE*) [31]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[32]     0.0    0.00    0.00       1         multithread_multiply(float*, float*, float*, int) [32]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+  [29] create_wav(short*, int, wav_file) [22] double_to_short(double) [14] write_file_format(file_fmt, _IO_FILE*)
+  [30] next_power(unsigned int) [13] exit_if_invalid(char*) [31] write_file_header(file_header, _IO_FILE*)
+   [2] convolution(wav_file, wav_file) [3] fft_convolution(float*, int, float*, int, float*, int) [32] multithread_multiply(float*, float*, float*, int)
+  [26] fwriteIntLSB(int, _IO_FILE*) [27] get_file_format(file_fmt&, _IO_FILE*) [4] four1(float*, int, int)
+   [7] zero_padding(float*, int, float*, int) [28] get_file_header(file_header&, _IO_FILE*) [11] read_file(char*)
+  [10] get_file_data(file_data&, _IO_FILE*, int) [24] int_from_buffer(char*) [21] std::abs(float)
+   [8] write_to_file(wav_file, char*) [9] write_file_data(file_data, _IO_FILE*, int) [25] std::sin(float)
+   [6] fwriteShortLSB(short, _IO_FILE*) [5] complex_multiply(void*)
+  [12] short_to_float(short)  [23] short_from_buffer(char*)
diff --git a/report.md b/report.md
index ec3bc27..fefb216 100644
--- a/report.md
+++ b/report.md
@@ -3,6 +3,10 @@ Alex Stevenson - 30073617
 
 Github Repository: https://github.com/alexs2112/CPSC501-Convolution
 
+
+
+
+
 ### Baseline Program
  - Initial version where convolution is implemented directly on the time domain in a linear matter.
  - The code for this version is stored in the [baseline branch](https://github.com/alexs2112/CPSC501-Convolution/tree/baseline) of the repository.
@@ -32,6 +36,10 @@ sys     0m0.154s
 >>> gprof convolve profiling/linear-guitar.out
 ```
 
+
+
+
+
 ### Algorithm Based Optimization:
  - Utilizing the FFT algorithm to re-implement the convolution using the frequency domain.
  - The code for this version before any further optimizations is stored in the [fft branch](https://github.com/alexs2112/CPSC501-Convolution/tree/fft) of the repository.
@@ -56,6 +64,10 @@ sys     0m0.075s
 **Regression Testing**:
  - Audio files produced from FFT convolution are the same as the ones produced by linear convolution.
 
+
+
+
+
 ### Manual Code Tuning #1:
  - The `complex_multiply` function very consistently takes the most time as a function call, taking 60% of the total processing time of the program. This is twice as much as the next largest function.
 ```
@@ -144,6 +156,10 @@ sys     0m0.134s
  - This test also broke previous unit tests as multiplication does not happen if the number of threads is greater than the size of the input arrays. This has since been fixed.
  - Output files from manual regression tests on convolution are the same as before the change.
 
+
+
+
+
 ### Manual Code Tuning #2:
  - Zero padding and converting the input samples to complex arrays have been taking a relatively long time after previous optimizations. Some profiling taken from the result of the previous optimization:
 ```
@@ -212,6 +228,10 @@ sys     0m0.139s
  - A minor bug with the `for` loop values was caught by the existing unit tests.
  - Manual convolution testing is successful and has expected results.
 
+
+
+
+
 ### Manual Code Tuning #3:
  - The `four1` algorithm as given to us uses doubles as its data type of choice. We don't need that level of precision for these simple convolutions and can change them all to floats.
  - As floats are half the size of doubles, this will drastically speed up operations that involve the various double arrays that are prevalent in the code.
@@ -263,11 +283,15 @@ sys     0m0.110s
  - There was mild concern that changing from doubles to floats would cause incorrect outputs as there is a loss of 4 bytes of precision.
  - This is not the case, all of the unit tests pass and manually running the convolution code using the new `four1` function produces the same result.
 
+
+
+
+
 ### Manual Code Tuning #4:
  - The `zero_padding` function performs repeated multiplications by 2 to get indices of the output array.
  - Strength Reduction can be applied to instead add by a fixed value every iteration instead of multiplying.
 
-**Commit**: []()
+**Commit**: [ed721fdee8e7511158f8b1c2820ba7afa9458e8d](https://github.com/alexs2112/CPSC501-Convolution/commit/ed721fdee8e7511158f8b1c2820ba7afa9458e8d)
 
 **Code Changes**:
 ```c
@@ -301,6 +325,7 @@ sys     0m0.121s
 real    0m2.059s
 user    0m1.695s
 sys     0m0.094s
+>>> gprof convolve profiling/guitar-manual-4.out
   %   cumulative   self              self     total           
  time   seconds   seconds    calls   s/call   s/call  name    
  89.61      1.38     1.38        3     0.46     0.46  four1(float*, int, int)
@@ -313,6 +338,84 @@ sys     0m0.094s
  - Previous automated unit tests continue to pass.
  - Manual running of the convolution executable works as expected.
 
+
+
+
+
+### Manual Code Tuning #5:
+ - The `complex_multiply` function continues to be the second slowest function during execution of the code.
+ - The performance of this function can be improved by Partially Unrolling the code 3 times
+
+**Commit**: []()
+
+**Code Changes**:
+```c
+void *complex_multiply(void *v) {
+    // Perform complex multiplication
+    complex_param p = ((complex_param *)v)[0];
+    int k;
+    for (k = 0; k < p.size; k += 6) {
+        // Re Y[k] = Re X[k] Re H[k] - Im X[k] Im H[k]
+        // Im Y[k] = Im X[k] Re H[k] + Re X[k] Im H[k]
+        p.output[k] = p.x[k] * p.h[k] - p.x[k+1] * p.h[k+1];
+        p.output[k+1] = p.x[k+1] * p.h[k] + p.x[k] * p.h[k+1];
+        p.output[k+2] = p.x[k+2] * p.h[k+2] - p.x[k+3] * p.h[k+3];
+        p.output[k+3] = p.x[k+3] * p.h[k+2] + p.x[k+2] * p.h[k+3];
+        p.output[k+4] = p.x[k+4] * p.h[k+4] - p.x[k+5] * p.h[k+5];
+        p.output[k+5] = p.x[k+5] * p.h[k+4] + p.x[k+4] * p.h[k+5];
+    }
+    if (k == p.size - 4) {
+        p.output[k] = p.x[k] * p.h[k] - p.x[k+1] * p.h[k+1];
+        p.output[k+1] = p.x[k+1] * p.h[k] + p.x[k] * p.h[k+1];
+        p.output[k+2] = p.x[k+2] * p.h[k+2] - p.x[k+3] * p.h[k+3];
+        p.output[k+3] = p.x[k+3] * p.h[k+2] + p.x[k+2] * p.h[k+3];
+    }
+    if (k == p.size - 2) {
+        p.output[k] = p.x[k] * p.h[k] - p.x[k+1] * p.h[k+1];
+        p.output[k+1] = p.x[k+1] * p.h[k] + p.x[k] * p.h[k+1];
+    }
+    return 0;
+}
+```
+ - The resulting code segment is a lot uglier than before this change, however each iteration of the loop now handles 3 complex values of the input (`k += 6`) rather than only a single complex value (`k += 2`).
+
+**Run Time Performance**:
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/out.wav
+real    0m4.789s
+user    0m4.196s
+sys     0m0.148s
+>>> gprof convolve profiling/flute-manual-5.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 93.00      3.72     3.72        3     1.24     1.24  four1(float*, int, int)
+  3.00      3.84     0.12                             complex_multiply(void*)
+  1.75      3.91     0.07        2     0.04     0.04  zero_padding(float*, int, float*, int)
+```
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    0m2.006s
+user    0m1.655s
+sys     0m0.087s
+>>> gprof convolve profiling/guitar-manual-5.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 89.26      1.33     1.33        3     0.44     0.44  four1(float*, int, int)
+  4.03      1.39     0.06                             complex_multiply(void*)
+  2.01      1.42     0.03  1871492     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  2.01      1.45     0.03        2     0.01     0.01  zero_padding(float*, int, float*, int)
+```
+ - This optimization is fairly negligible and as a result it adds a minimal performance upgrade to the program.
+ - For the second test case of convolving `GuitarDry.wav`, for the first time the `zero_padding` function is no longer in the top 3 functions that take the most time during program execution.
+
+**Regression Testing**:
+ - Previous unit tests pass and manually running the convolution code outputs correct wav files.
+ - The old test for the `complex_multiply` function did not actually test a case where the input is not divisible by 6. A new test case has been constructed to test an input value of a length of 8.
+
+
+
+
+
 ### Compiler-Level Optimization:
  - Previously, the `convolve` executable was compiled with the `g` debug flag and the `p` profiling flag. Both of these flags slow down performance by including debug and profiling information when the executable runs.
  - Adding the `O3` flag to allow the gcc compiler to optimize the executable the maximum allowed amount will also speed up execution time.
diff --git a/test.cpp b/test.cpp
index 9ecbac7..add3215 100644
--- a/test.cpp
+++ b/test.cpp
@@ -17,10 +17,11 @@
  ****************************************************************************/
 
 /* Test Definitions */
-#define NUM_TESTS   4
+#define NUM_TESTS   5
 int test_linear_convolution();
 int test_fft_convolution();
 int test_complex_multiplication();
+int test_complex_multiplication_2();
 int test_zero_padding();
 
 /* Main Function */
@@ -29,6 +30,7 @@ int main(int argc, char* argv[]) {
         test_linear_convolution,
         test_fft_convolution,
         test_complex_multiplication,
+        test_complex_multiplication_2,
         test_zero_padding,
     };
 
@@ -132,6 +134,30 @@ int test_complex_multiplication() {
     return 0;
 }
 
+int test_complex_multiplication_2() {
+    float x[] = { 1, 2, 3, 4, 5, 6, 7, 8};
+    float h[] = { 12, 11, 10, 9, 8, 7, 6, 5 };
+    float o[8];
+
+    complex_param p;
+    p.x = &x[0];
+    p.h = &h[0];
+    p.output = &o[0];
+    p.size = 8;
+    complex_multiply((void *)&p);
+
+    float e[] = { -10.0, 35.0, -6.0, 67.0, -2.0, 83.0, 2.0, 83 };
+
+    for (int i = 0; i < 8; i++) {
+        if (o[i] != e[i]) {
+            printf("Error in complex multiplication.\n\tExpected: [%.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f]\n\tActual: [%.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f]\n",
+                e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], o[0], o[1], o[2], o[3], o[4], o[5], o[6], o[7]);
+            return 1;
+        }
+    }
+    return 0;
+}
+
 int test_zero_padding() {
     float signal[] = { 0.5, 0.6, 0.7 };
     float output[8];

commit ed721fdee8e7511158f8b1c2820ba7afa9458e8d
Author: alexs2112 <alexste2112@gmail.com>
Date:   Mon Dec 4 14:23:30 2023 -0700

    manual tuning: strength reduction on zero_padding, revert compiler optimization

diff --git a/Makefile b/Makefile
index 9a3c13a..7975d14 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,5 @@
 convolve: convolve.cpp
-	g++ -O3 -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+	g++ -g -p -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
 
 test: test.cpp
-	g++ -g -O3 -o test test.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+	g++ -g -o test test.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
diff --git a/modules/fast_fourier.cpp b/modules/fast_fourier.cpp
index 203a309..ee8b04b 100644
--- a/modules/fast_fourier.cpp
+++ b/modules/fast_fourier.cpp
@@ -79,10 +79,10 @@ unsigned int next_power(unsigned int v) {
 
 // Output size should be 2x the padded size to account for complex numbers
 void zero_padding(float *signal, int input_size, float *output, int output_size) {
-    int i;
-    for (i = 0; i < input_size; i++) {
-        output[i*2] = signal[i];
-        output[i*2 + 1] = 0.0;
+    int i, j;
+    for (i = 0, j = 0; i < input_size; i++, j += 2) {
+        output[j] = signal[i];
+        output[j + 1] = 0.0;
     }
     for (i = input_size * 2; i < output_size; i++) {
         output[i] = 0.0;
diff --git a/profiling/flute-manual-4.out b/profiling/flute-manual-4.out
new file mode 100644
index 0000000..0e7a644
Binary files /dev/null and b/profiling/flute-manual-4.out differ
diff --git a/profiling/flute-manual-4.txt b/profiling/flute-manual-4.txt
new file mode 100644
index 0000000..6b2cde5
--- /dev/null
+++ b/profiling/flute-manual-4.txt
@@ -0,0 +1,284 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 94.10      3.83     3.83        3     1.28     1.28  four1(float*, int, int)
+  2.70      3.94     0.11                             complex_multiply(void*)
+  1.47      4.00     0.06        2     0.03     0.03  zero_padding(float*, int, float*, int)
+  0.74      4.03     0.03        2     0.01     0.01  get_file_data(file_data&, _IO_FILE*, int)
+  0.25      4.04     0.01  2810342     0.00     0.00  std::abs(float)
+  0.25      4.05     0.01  2810253     0.00     0.00  double_to_short(double)
+  0.25      4.06     0.01        1     0.01     3.93  convolution(wav_file, wav_file)
+  0.25      4.07     0.01        1     0.01     3.90  fft_convolution(float*, int, float*, int, float*, int)
+  0.00      4.07     0.00  2810262     0.00     0.00  short_from_buffer(char*)
+  0.00      4.07     0.00  2810257     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  0.00      4.07     0.00  2810254     0.00     0.00  short_to_float(short)
+  0.00      4.07     0.00       66     0.00     0.00  std::sin(float)
+  0.00      4.07     0.00       10     0.00     0.00  int_from_buffer(char*)
+  0.00      4.07     0.00        5     0.00     0.00  fwriteIntLSB(int, _IO_FILE*)
+  0.00      4.07     0.00        2     0.00     0.00  exit_if_invalid(char*)
+  0.00      4.07     0.00        2     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.00      4.07     0.00        2     0.00     0.00  get_file_header(file_header&, _IO_FILE*)
+  0.00      4.07     0.00        2     0.00     0.01  read_file(char*)
+  0.00      4.07     0.00        1     0.00     0.00  create_wav(short*, int, wav_file)
+  0.00      4.07     0.00        1     0.00     0.00  next_power(unsigned int)
+  0.00      4.07     0.00        1     0.00     0.00  write_to_file(wav_file, char*)
+  0.00      4.07     0.00        1     0.00     0.00  write_file_data(file_data, _IO_FILE*, int)
+  0.00      4.07     0.00        1     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      4.07     0.00        1     0.00     0.00  write_file_header(file_header, _IO_FILE*)
+  0.00      4.07     0.00        1     0.00     0.00  multithread_multiply(float*, float*, float*, int)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.25% of 4.07 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     97.3    0.00    3.96                 main [1]
+                0.01    3.92       1/1           convolution(wav_file, wav_file) [2]
+                0.00    0.03       2/2           read_file(char*) [8]
+                0.00    0.00       2/2           exit_if_invalid(char*) [23]
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [28]
+-----------------------------------------------
+                0.01    3.92       1/1           main [1]
+[2]     96.6    0.01    3.92       1         convolution(wav_file, wav_file) [2]
+                0.01    3.89       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+                0.01    0.00 2810342/2810342     std::abs(float) [9]
+                0.01    0.00 2810253/2810253     double_to_short(double) [10]
+                0.00    0.00 2810254/2810254     short_to_float(short) [19]
+                0.00    0.00       1/1           create_wav(short*, int, wav_file) [26]
+-----------------------------------------------
+                0.01    3.89       1/1           convolution(wav_file, wav_file) [2]
+[3]     95.8    0.01    3.89       1         fft_convolution(float*, int, float*, int, float*, int) [3]
+                3.83    0.00       3/3           four1(float*, int, int) [4]
+                0.06    0.00       2/2           zero_padding(float*, int, float*, int) [6]
+                0.00    0.00       1/1           next_power(unsigned int) [27]
+                0.00    0.00       1/1           multithread_multiply(float*, float*, float*, int) [32]
+-----------------------------------------------
+                3.83    0.00       3/3           fft_convolution(float*, int, float*, int, float*, int) [3]
+[4]     94.1    3.83    0.00       3         four1(float*, int, int) [4]
+                0.00    0.00      66/66          std::sin(float) [20]
+-----------------------------------------------
+                                                 <spontaneous>
+[5]      2.7    0.11    0.00                 complex_multiply(void*) [5]
+-----------------------------------------------
+                0.06    0.00       2/2           fft_convolution(float*, int, float*, int, float*, int) [3]
+[6]      1.5    0.06    0.00       2         zero_padding(float*, int, float*, int) [6]
+-----------------------------------------------
+                0.03    0.00       2/2           read_file(char*) [8]
+[7]      0.7    0.03    0.00       2         get_file_data(file_data&, _IO_FILE*, int) [7]
+                0.00    0.00 2810254/2810262     short_from_buffer(char*) [17]
+                0.00    0.00       2/10          int_from_buffer(char*) [21]
+-----------------------------------------------
+                0.00    0.03       2/2           main [1]
+[8]      0.7    0.00    0.03       2         read_file(char*) [8]
+                0.03    0.00       2/2           get_file_data(file_data&, _IO_FILE*, int) [7]
+                0.00    0.00       2/2           get_file_header(file_header&, _IO_FILE*) [25]
+                0.00    0.00       2/2           get_file_format(file_fmt&, _IO_FILE*) [24]
+-----------------------------------------------
+                0.01    0.00 2810342/2810342     convolution(wav_file, wav_file) [2]
+[9]      0.2    0.01    0.00 2810342         std::abs(float) [9]
+-----------------------------------------------
+                0.01    0.00 2810253/2810253     convolution(wav_file, wav_file) [2]
+[10]     0.2    0.01    0.00 2810253         double_to_short(double) [10]
+-----------------------------------------------
+                0.00    0.00       8/2810262     get_file_format(file_fmt&, _IO_FILE*) [24]
+                0.00    0.00 2810254/2810262     get_file_data(file_data&, _IO_FILE*, int) [7]
+[17]     0.0    0.00    0.00 2810262         short_from_buffer(char*) [17]
+-----------------------------------------------
+                0.00    0.00       4/2810257     write_file_format(file_fmt, _IO_FILE*) [30]
+                0.00    0.00 2810253/2810257     write_file_data(file_data, _IO_FILE*, int) [29]
+[18]     0.0    0.00    0.00 2810257         fwriteShortLSB(short, _IO_FILE*) [18]
+-----------------------------------------------
+                0.00    0.00 2810254/2810254     convolution(wav_file, wav_file) [2]
+[19]     0.0    0.00    0.00 2810254         short_to_float(short) [19]
+-----------------------------------------------
+                0.00    0.00      66/66          four1(float*, int, int) [4]
+[20]     0.0    0.00    0.00      66         std::sin(float) [20]
+-----------------------------------------------
+                0.00    0.00       2/10          get_file_header(file_header&, _IO_FILE*) [25]
+                0.00    0.00       2/10          get_file_data(file_data&, _IO_FILE*, int) [7]
+                0.00    0.00       6/10          get_file_format(file_fmt&, _IO_FILE*) [24]
+[21]     0.0    0.00    0.00      10         int_from_buffer(char*) [21]
+-----------------------------------------------
+                0.00    0.00       1/5           write_file_header(file_header, _IO_FILE*) [31]
+                0.00    0.00       1/5           write_file_data(file_data, _IO_FILE*, int) [29]
+                0.00    0.00       3/5           write_file_format(file_fmt, _IO_FILE*) [30]
+[22]     0.0    0.00    0.00       5         fwriteIntLSB(int, _IO_FILE*) [22]
+-----------------------------------------------
+                0.00    0.00       2/2           main [1]
+[23]     0.0    0.00    0.00       2         exit_if_invalid(char*) [23]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [8]
+[24]     0.0    0.00    0.00       2         get_file_format(file_fmt&, _IO_FILE*) [24]
+                0.00    0.00       8/2810262     short_from_buffer(char*) [17]
+                0.00    0.00       6/10          int_from_buffer(char*) [21]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [8]
+[25]     0.0    0.00    0.00       2         get_file_header(file_header&, _IO_FILE*) [25]
+                0.00    0.00       2/10          int_from_buffer(char*) [21]
+-----------------------------------------------
+                0.00    0.00       1/1           convolution(wav_file, wav_file) [2]
+[26]     0.0    0.00    0.00       1         create_wav(short*, int, wav_file) [26]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[27]     0.0    0.00    0.00       1         next_power(unsigned int) [27]
+-----------------------------------------------
+                0.00    0.00       1/1           main [1]
+[28]     0.0    0.00    0.00       1         write_to_file(wav_file, char*) [28]
+                0.00    0.00       1/1           write_file_header(file_header, _IO_FILE*) [31]
+                0.00    0.00       1/1           write_file_format(file_fmt, _IO_FILE*) [30]
+                0.00    0.00       1/1           write_file_data(file_data, _IO_FILE*, int) [29]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [28]
+[29]     0.0    0.00    0.00       1         write_file_data(file_data, _IO_FILE*, int) [29]
+                0.00    0.00 2810253/2810257     fwriteShortLSB(short, _IO_FILE*) [18]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [22]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [28]
+[30]     0.0    0.00    0.00       1         write_file_format(file_fmt, _IO_FILE*) [30]
+                0.00    0.00       4/2810257     fwriteShortLSB(short, _IO_FILE*) [18]
+                0.00    0.00       3/5           fwriteIntLSB(int, _IO_FILE*) [22]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [28]
+[31]     0.0    0.00    0.00       1         write_file_header(file_header, _IO_FILE*) [31]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [22]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[32]     0.0    0.00    0.00       1         multithread_multiply(float*, float*, float*, int) [32]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+  [26] create_wav(short*, int, wav_file) [10] double_to_short(double) [30] write_file_format(file_fmt, _IO_FILE*)
+  [27] next_power(unsigned int) [23] exit_if_invalid(char*) [31] write_file_header(file_header, _IO_FILE*)
+   [2] convolution(wav_file, wav_file) [3] fft_convolution(float*, int, float*, int, float*, int) [32] multithread_multiply(float*, float*, float*, int)
+  [22] fwriteIntLSB(int, _IO_FILE*) [24] get_file_format(file_fmt&, _IO_FILE*) [4] four1(float*, int, int)
+   [6] zero_padding(float*, int, float*, int) [25] get_file_header(file_header&, _IO_FILE*) [8] read_file(char*)
+   [7] get_file_data(file_data&, _IO_FILE*, int) [21] int_from_buffer(char*) [9] std::abs(float)
+  [28] write_to_file(wav_file, char*) [29] write_file_data(file_data, _IO_FILE*, int) [20] std::sin(float)
+  [18] fwriteShortLSB(short, _IO_FILE*) [5] complex_multiply(void*)
+  [19] short_to_float(short)  [17] short_from_buffer(char*)
diff --git a/profiling/guitar-manual-4.out b/profiling/guitar-manual-4.out
new file mode 100644
index 0000000..1e42867
Binary files /dev/null and b/profiling/guitar-manual-4.out differ
diff --git a/profiling/guitar-manual-4.txt b/profiling/guitar-manual-4.txt
new file mode 100644
index 0000000..78dd1b3
--- /dev/null
+++ b/profiling/guitar-manual-4.txt
@@ -0,0 +1,284 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 89.61      1.38     1.38        3     0.46     0.46  four1(float*, int, int)
+  5.19      1.46     0.08                             complex_multiply(void*)
+  1.30      1.48     0.02        2     0.01     0.01  zero_padding(float*, int, float*, int)
+  1.30      1.50     0.02        2     0.01     0.01  get_file_data(file_data&, _IO_FILE*, int)
+  0.65      1.51     0.01  1871492     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  0.65      1.52     0.01  1871488     0.00     0.00  double_to_short(double)
+  0.65      1.53     0.01        1     0.01     1.42  convolution(wav_file, wav_file)
+  0.65      1.54     0.01        1     0.01     0.02  write_file_data(file_data, _IO_FILE*, int)
+  0.00      1.54     0.00  1871546     0.00     0.00  std::abs(float)
+  0.00      1.54     0.00  1871489     0.00     0.00  short_to_float(short)
+  0.00      1.54     0.00  1769480     0.00     0.00  short_from_buffer(char*)
+  0.00      1.54     0.00   102027     0.00     0.00  int_from_buffer(char*)
+  0.00      1.54     0.00       63     0.00     0.00  std::sin(float)
+  0.00      1.54     0.00        5     0.00     0.00  fwriteIntLSB(int, _IO_FILE*)
+  0.00      1.54     0.00        2     0.00     0.00  exit_if_invalid(char*)
+  0.00      1.54     0.00        2     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.00      1.54     0.00        2     0.00     0.00  get_file_header(file_header&, _IO_FILE*)
+  0.00      1.54     0.00        2     0.00     0.01  read_file(char*)
+  0.00      1.54     0.00        1     0.00     0.00  create_wav(short*, int, wav_file)
+  0.00      1.54     0.00        1     0.00     0.00  next_power(unsigned int)
+  0.00      1.54     0.00        1     0.00     0.02  write_to_file(wav_file, char*)
+  0.00      1.54     0.00        1     0.00     1.40  fft_convolution(float*, int, float*, int, float*, int)
+  0.00      1.54     0.00        1     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      1.54     0.00        1     0.00     0.00  write_file_header(file_header, _IO_FILE*)
+  0.00      1.54     0.00        1     0.00     0.00  multithread_multiply(float*, float*, float*, int)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.65% of 1.54 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     94.8    0.00    1.46                 main [1]
+                0.01    1.41       1/1           convolution(wav_file, wav_file) [2]
+                0.00    0.02       2/2           read_file(char*) [8]
+                0.00    0.02       1/1           write_to_file(wav_file, char*) [9]
+                0.00    0.00       2/2           exit_if_invalid(char*) [26]
+-----------------------------------------------
+                0.01    1.41       1/1           main [1]
+[2]     92.2    0.01    1.41       1         convolution(wav_file, wav_file) [2]
+                0.00    1.40       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+                0.01    0.00 1871488/1871488     double_to_short(double) [12]
+                0.00    0.00 1871546/1871546     std::abs(float) [20]
+                0.00    0.00 1871489/1871489     short_to_float(short) [21]
+                0.00    0.00       1/1           create_wav(short*, int, wav_file) [29]
+-----------------------------------------------
+                0.00    1.40       1/1           convolution(wav_file, wav_file) [2]
+[3]     90.9    0.00    1.40       1         fft_convolution(float*, int, float*, int, float*, int) [3]
+                1.38    0.00       3/3           four1(float*, int, int) [4]
+                0.02    0.00       2/2           zero_padding(float*, int, float*, int) [6]
+                0.00    0.00       1/1           next_power(unsigned int) [30]
+                0.00    0.00       1/1           multithread_multiply(float*, float*, float*, int) [32]
+-----------------------------------------------
+                1.38    0.00       3/3           fft_convolution(float*, int, float*, int, float*, int) [3]
+[4]     89.6    1.38    0.00       3         four1(float*, int, int) [4]
+                0.00    0.00      63/63          std::sin(float) [24]
+-----------------------------------------------
+                                                 <spontaneous>
+[5]      5.2    0.08    0.00                 complex_multiply(void*) [5]
+-----------------------------------------------
+                0.02    0.00       2/2           fft_convolution(float*, int, float*, int, float*, int) [3]
+[6]      1.3    0.02    0.00       2         zero_padding(float*, int, float*, int) [6]
+-----------------------------------------------
+                0.02    0.00       2/2           read_file(char*) [8]
+[7]      1.3    0.02    0.00       2         get_file_data(file_data&, _IO_FILE*, int) [7]
+                0.00    0.00 1769472/1769480     short_from_buffer(char*) [22]
+                0.00    0.00  102019/102027      int_from_buffer(char*) [23]
+-----------------------------------------------
+                0.00    0.02       2/2           main [1]
+[8]      1.3    0.00    0.02       2         read_file(char*) [8]
+                0.02    0.00       2/2           get_file_data(file_data&, _IO_FILE*, int) [7]
+                0.00    0.00       2/2           get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       2/2           get_file_format(file_fmt&, _IO_FILE*) [27]
+-----------------------------------------------
+                0.00    0.02       1/1           main [1]
+[9]      1.3    0.00    0.02       1         write_to_file(wav_file, char*) [9]
+                0.01    0.01       1/1           write_file_data(file_data, _IO_FILE*, int) [10]
+                0.00    0.00       1/1           write_file_format(file_fmt, _IO_FILE*) [13]
+                0.00    0.00       1/1           write_file_header(file_header, _IO_FILE*) [31]
+-----------------------------------------------
+                0.01    0.01       1/1           write_to_file(wav_file, char*) [9]
+[10]     1.3    0.01    0.01       1         write_file_data(file_data, _IO_FILE*, int) [10]
+                0.01    0.00 1871488/1871492     fwriteShortLSB(short, _IO_FILE*) [11]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [25]
+-----------------------------------------------
+                0.00    0.00       4/1871492     write_file_format(file_fmt, _IO_FILE*) [13]
+                0.01    0.00 1871488/1871492     write_file_data(file_data, _IO_FILE*, int) [10]
+[11]     0.6    0.01    0.00 1871492         fwriteShortLSB(short, _IO_FILE*) [11]
+-----------------------------------------------
+                0.01    0.00 1871488/1871488     convolution(wav_file, wav_file) [2]
+[12]     0.6    0.01    0.00 1871488         double_to_short(double) [12]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [9]
+[13]     0.0    0.00    0.00       1         write_file_format(file_fmt, _IO_FILE*) [13]
+                0.00    0.00       4/1871492     fwriteShortLSB(short, _IO_FILE*) [11]
+                0.00    0.00       3/5           fwriteIntLSB(int, _IO_FILE*) [25]
+-----------------------------------------------
+                0.00    0.00 1871546/1871546     convolution(wav_file, wav_file) [2]
+[20]     0.0    0.00    0.00 1871546         std::abs(float) [20]
+-----------------------------------------------
+                0.00    0.00 1871489/1871489     convolution(wav_file, wav_file) [2]
+[21]     0.0    0.00    0.00 1871489         short_to_float(short) [21]
+-----------------------------------------------
+                0.00    0.00       8/1769480     get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00 1769472/1769480     get_file_data(file_data&, _IO_FILE*, int) [7]
+[22]     0.0    0.00    0.00 1769480         short_from_buffer(char*) [22]
+-----------------------------------------------
+                0.00    0.00       2/102027      get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       6/102027      get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00  102019/102027      get_file_data(file_data&, _IO_FILE*, int) [7]
+[23]     0.0    0.00    0.00  102027         int_from_buffer(char*) [23]
+-----------------------------------------------
+                0.00    0.00      63/63          four1(float*, int, int) [4]
+[24]     0.0    0.00    0.00      63         std::sin(float) [24]
+-----------------------------------------------
+                0.00    0.00       1/5           write_file_header(file_header, _IO_FILE*) [31]
+                0.00    0.00       1/5           write_file_data(file_data, _IO_FILE*, int) [10]
+                0.00    0.00       3/5           write_file_format(file_fmt, _IO_FILE*) [13]
+[25]     0.0    0.00    0.00       5         fwriteIntLSB(int, _IO_FILE*) [25]
+-----------------------------------------------
+                0.00    0.00       2/2           main [1]
+[26]     0.0    0.00    0.00       2         exit_if_invalid(char*) [26]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [8]
+[27]     0.0    0.00    0.00       2         get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00       8/1769480     short_from_buffer(char*) [22]
+                0.00    0.00       6/102027      int_from_buffer(char*) [23]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [8]
+[28]     0.0    0.00    0.00       2         get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       2/102027      int_from_buffer(char*) [23]
+-----------------------------------------------
+                0.00    0.00       1/1           convolution(wav_file, wav_file) [2]
+[29]     0.0    0.00    0.00       1         create_wav(short*, int, wav_file) [29]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[30]     0.0    0.00    0.00       1         next_power(unsigned int) [30]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [9]
+[31]     0.0    0.00    0.00       1         write_file_header(file_header, _IO_FILE*) [31]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [25]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[32]     0.0    0.00    0.00       1         multithread_multiply(float*, float*, float*, int) [32]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+  [29] create_wav(short*, int, wav_file) [12] double_to_short(double) [13] write_file_format(file_fmt, _IO_FILE*)
+  [30] next_power(unsigned int) [26] exit_if_invalid(char*) [31] write_file_header(file_header, _IO_FILE*)
+   [2] convolution(wav_file, wav_file) [3] fft_convolution(float*, int, float*, int, float*, int) [32] multithread_multiply(float*, float*, float*, int)
+  [25] fwriteIntLSB(int, _IO_FILE*) [27] get_file_format(file_fmt&, _IO_FILE*) [4] four1(float*, int, int)
+   [6] zero_padding(float*, int, float*, int) [28] get_file_header(file_header&, _IO_FILE*) [8] read_file(char*)
+   [7] get_file_data(file_data&, _IO_FILE*, int) [23] int_from_buffer(char*) [20] std::abs(float)
+   [9] write_to_file(wav_file, char*) [10] write_file_data(file_data, _IO_FILE*, int) [24] std::sin(float)
+  [11] fwriteShortLSB(short, _IO_FILE*) [5] complex_multiply(void*)
+  [21] short_to_float(short)  [22] short_from_buffer(char*)
diff --git a/report.md b/report.md
index d2b6a3a..ec3bc27 100644
--- a/report.md
+++ b/report.md
@@ -263,6 +263,56 @@ sys     0m0.110s
  - There was mild concern that changing from doubles to floats would cause incorrect outputs as there is a loss of 4 bytes of precision.
  - This is not the case, all of the unit tests pass and manually running the convolution code using the new `four1` function produces the same result.
 
+### Manual Code Tuning #4:
+ - The `zero_padding` function performs repeated multiplications by 2 to get indices of the output array.
+ - Strength Reduction can be applied to instead add by a fixed value every iteration instead of multiplying.
+
+**Commit**: []()
+
+**Code Changes**:
+```c
+void zero_padding(float *signal, int input_size, float *output, int output_size) {
+    int i, j;
+    for (i = 0, j = 0; i < input_size; i++, j += 2) {
+        output[j] = signal[i];
+        output[j + 1] = 0.0;
+    }
+    ...
+}
+```
+ - Previously, the index applied to output was `2 * i`
+ - Strength Reduction is applied to instead increment a second value of `j` by 2 every loop iteration. This can be directly applied as the index of output instead of needing to perform a multiplication.
+
+**Run Time Performance**:
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/out.wav
+real    0m4.874s
+user    0m4.345s
+sys     0m0.121s
+>>> gprof convolve profiling/flute-manual-4.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 94.10      3.83     3.83        3     1.28     1.28  four1(float*, int, int)
+  2.70      3.94     0.11                             complex_multiply(void*)
+  1.47      4.00     0.06        2     0.03     0.03  zero_padding(float*, int, float*, int)
+```
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    0m2.059s
+user    0m1.695s
+sys     0m0.094s
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 89.61      1.38     1.38        3     0.46     0.46  four1(float*, int, int)
+  5.19      1.46     0.08                             complex_multiply(void*)
+  1.30      1.48     0.02        2     0.01     0.01  zero_padding(float*, int, float*, int)
+```
+ - Note that the amount of time required by the `zero_padding` function is reduced in both cases.
+
+**Regression Testing**:
+ - Previous automated unit tests continue to pass.
+ - Manual running of the convolution executable works as expected.
+
 ### Compiler-Level Optimization:
  - Previously, the `convolve` executable was compiled with the `g` debug flag and the `p` profiling flag. Both of these flags slow down performance by including debug and profiling information when the executable runs.
  - Adding the `O3` flag to allow the gcc compiler to optimize the executable the maximum allowed amount will also speed up execution time.

commit 21369776df3f12bf2c655054d3e5d819f073e71a
Author: alexs2112 <alexste2112@gmail.com>
Date:   Mon Dec 4 13:40:06 2023 -0700

    compiler-level optimization

diff --git a/Makefile b/Makefile
index 7975d14..9a3c13a 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,5 @@
 convolve: convolve.cpp
-	g++ -g -p -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+	g++ -O3 -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
 
 test: test.cpp
-	g++ -g -o test test.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+	g++ -g -O3 -o test test.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
diff --git a/README.md b/README.md
index 59cd58d..b43fa0a 100644
--- a/README.md
+++ b/README.md
@@ -8,14 +8,6 @@ A full report is available at [report.md](report.md).
 ### Timings:
 Linear Convolution:
 ```
->>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
-real    9m4.331s
-user    9m0.709s
-sys     0m0.154s
-
->>> gprof convolve profiling/linear-guitar.out
-```
-```
 >>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/flute-mahal.wav
 real    21m49.301s
 user    20m56.925s
@@ -23,6 +15,14 @@ sys     0m0.710s
 
 >>> gprof convolve profiling/linear-flute.out
 ```
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    9m4.331s
+user    9m0.709s
+sys     0m0.154s
+
+>>> gprof convolve profiling/linear-guitar.out
+```
 
 FFT Convolution:
 ```
@@ -42,12 +42,26 @@ sys     0m0.075s
 >>> gprof convolve profiling/fft-guitar.out
 ```
 
+Further Manual and Compiler-Level Optimizations:
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/out.wav
+real    0m2.766s
+user    0m2.149s
+sys     0m0.154s
+```
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    0m1.205s
+user    0m0.823s
+sys     0m0.106s
+```
+
 ### Unit Testing:
-Unit tests are available through the `test.cpp` file. This can be compiled using `make test` and run as `./test`.
+Unit tests are available through the `test.cpp` file that implements a custom unit testing framework. This can be compiled using `make test` and run as `./test`.
 ```
 >>> ./test
 
 Test Run Complete.
-Tests Run: 2
+Tests Run: 4
 Test Failed: 0
 ```
diff --git a/convolve.cpp b/convolve.cpp
index 1f480a2..cc27df5 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -16,6 +16,7 @@
 
 using namespace std;
 
+// How many samples in H are required for FFT convolution to be faster than linear convolution
 #define USE_FAST_FOURIER    60
 
 float short_to_float(short i);
diff --git a/report.md b/report.md
index 29a742e..d2b6a3a 100644
--- a/report.md
+++ b/report.md
@@ -216,7 +216,7 @@ sys     0m0.139s
  - The `four1` algorithm as given to us uses doubles as its data type of choice. We don't need that level of precision for these simple convolutions and can change them all to floats.
  - As floats are half the size of doubles, this will drastically speed up operations that involve the various double arrays that are prevalent in the code.
 
-**Commit**: []()
+**Commit**: [fdd35509d66e612d2a9cdd8c27d5902c155f592a](https://github.com/alexs2112/CPSC501-Convolution/commit/fdd35509d66e612d2a9cdd8c27d5902c155f592a)
 
 **Code Changes**:
  - The main code change is present in the `four1` method, although there are many other places where doubles are changed to floats for performance.
@@ -262,3 +262,38 @@ sys     0m0.110s
 **Regression Testing**:
  - There was mild concern that changing from doubles to floats would cause incorrect outputs as there is a loss of 4 bytes of precision.
  - This is not the case, all of the unit tests pass and manually running the convolution code using the new `four1` function produces the same result.
+
+### Compiler-Level Optimization:
+ - Previously, the `convolve` executable was compiled with the `g` debug flag and the `p` profiling flag. Both of these flags slow down performance by including debug and profiling information when the executable runs.
+ - Adding the `O3` flag to allow the gcc compiler to optimize the executable the maximum allowed amount will also speed up execution time.
+
+**Commit**: []()
+
+**Code Changes**:
+```Makefile
+convolve: convolve.cpp
+	g++ -O3 -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+
+test: test.cpp
+	g++ -g -O3 -o test test.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+```
+
+**Run Time Performance**:
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/out.wav
+real    0m2.766s
+user    0m2.149s
+sys     0m0.154s
+```
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    0m1.205s
+user    0m0.823s
+sys     0m0.106s
+```
+ - Pretty large increases to speed, both convolution tests are running nearly twice as fast as they were after the previous manual optimization.
+
+**Regression Testing**:
+ - Note that the `-O3` flag was added to the makefile for the unit testing suite. This is to ensure that the functions involved with the convolution are not broken by the compiler reorganizing code.
+ - Unit Tests continue to pass after having the dependent FFT and Linear Convolution functions optimized.
+ - Manual regression testing on the full convolution continues to produce the expected output.

commit fdd35509d66e612d2a9cdd8c27d5902c155f592a
Author: alexs2112 <alexste2112@gmail.com>
Date:   Mon Dec 4 13:18:12 2023 -0700

    manual tuning: change from doubles to floats, massive increase in speed

diff --git a/convolve.cpp b/convolve.cpp
index 44f8926..1f480a2 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -99,7 +99,7 @@ wav_file convolution(wav_file input, wav_file ir) {
     // x and h arrays are handled as decimals between -1.0 and 1.0
     float *x = new float[N];
     float *h = new float[M];
-    double *y = new double[P];
+    float *y = new float[P];
 
     // Convert the stored sample values as floats from -1.0 to 1.0
     for (i = 0; i < N; i++)
@@ -107,7 +107,7 @@ wav_file convolution(wav_file input, wav_file ir) {
     for (i = 0; i < M; i++)
         h[i] = short_to_float(ir.data.samples[i]);
     for (i = 0; i < P; i++)
-        y[i] = 0.0;
+        y[i] = 0.0f;
 
     // Use FFT convolution when the size of M is greater than 60 samples, otherwise use linear convolution
     if (M > 60) {
@@ -117,7 +117,7 @@ wav_file convolution(wav_file input, wav_file ir) {
     }
 
     // The convolution can result in values > 1.0, make sure to scale them
-    double largest = 1.0;
+    float largest = 1.0;
     for (i = 0; i < P; i++) {
         if (abs(y[i]) > largest) { largest = abs(y[i]); }
     }
diff --git a/headers/convolution.h b/headers/convolution.h
index e59ed30..c15b31a 100644
--- a/headers/convolution.h
+++ b/headers/convolution.h
@@ -1 +1 @@
-void linear_convolution(float* x, int N, float* h, int M, double* y, int P);
+void linear_convolution(float* x, int N, float* h, int M, float* y, int P);
diff --git a/headers/fast_fourier.h b/headers/fast_fourier.h
index eca93a8..3cad788 100644
--- a/headers/fast_fourier.h
+++ b/headers/fast_fourier.h
@@ -1,3 +1,3 @@
-void fft_convolution(float *x, int N, float *h, int M, double *y, int P);
+void fft_convolution(float *x, int N, float *h, int M, float *y, int P);
 void *complex_multiply(void *v);
-void zero_padding(float *signal, int input_size, double *output, int output_size);
+void zero_padding(float *signal, int input_size, float *output, int output_size);
diff --git a/modules/convolution.cpp b/modules/convolution.cpp
index d0026e4..5bdc05f 100644
--- a/modules/convolution.cpp
+++ b/modules/convolution.cpp
@@ -1,5 +1,5 @@
 /* Using a slightly modified version of the input-side algorithm presented in lecture */
-void linear_convolution(float* x, int N, float* h, int M, double* y, int P) {
+void linear_convolution(float* x, int N, float* h, int M, float* y, int P) {
     int n, m;
 
 	// Clear output buffer y[]
@@ -11,7 +11,7 @@ void linear_convolution(float* x, int N, float* h, int M, double* y, int P) {
 	for (n = 0; n < N; n++) {
 		// Inner Loop: process x[n] with each sample of h[n]
 		for (m = 0; m < M; m++) {
-			y[n+m] += (double)(x[n] * h[m]);
+			y[n+m] += (float)(x[n] * h[m]);
 		}
 	}
 }
diff --git a/modules/fast_fourier.cpp b/modules/fast_fourier.cpp
index c6d20da..203a309 100644
--- a/modules/fast_fourier.cpp
+++ b/modules/fast_fourier.cpp
@@ -16,10 +16,10 @@
 //    data pointer to data array, this should be subtracted by 1 as our arrays are 0 aligned (ie. four1(data - 1, 1024, 1))
 //    nn must be a power of 2, it is the number of complex data points in data (ie. half the length of data)
 //    isign = +1 for FFT, -1 for IFFT
-void four1(double *data, int nn, int isign) {
+void four1(float *data, int nn, int isign) {
     unsigned long n, mmax, m, j, istep, i;
-    double wtemp, wr, wpr, wpi, wi, theta;
-    double tempr, tempi;
+    float wtemp, wr, wpr, wpi, wi, theta;
+    float tempr, tempi;
 
     n = nn << 1;
     j = 1;
@@ -78,10 +78,10 @@ unsigned int next_power(unsigned int v) {
 }
 
 // Output size should be 2x the padded size to account for complex numbers
-void zero_padding(float *signal, int input_size, double *output, int output_size) {
+void zero_padding(float *signal, int input_size, float *output, int output_size) {
     int i;
     for (i = 0; i < input_size; i++) {
-        output[i*2] = (double)signal[i];
+        output[i*2] = signal[i];
         output[i*2 + 1] = 0.0;
     }
     for (i = input_size * 2; i < output_size; i++) {
@@ -91,9 +91,9 @@ void zero_padding(float *signal, int input_size, double *output, int output_size
 
 /* Perform the complex multiplication on a segment of three arrays */
 struct complex_param {
-    double *x;
-    double *h;
-    double *output;
+    float *x;
+    float *h;
+    float *output;
     int size;
 };
 
@@ -110,7 +110,7 @@ void *complex_multiply(void *v) {
 }
 
 /* Perform complex multiplication in several threads for performance */
-void multithread_multiply(double *x, double *h, double *output, int size) {
+void multithread_multiply(float *x, float *h, float *output, int size) {
     int num_threads;
     if (size < 4 * COMPLEX_THREADS)
         num_threads = 1;
@@ -141,12 +141,12 @@ void multithread_multiply(double *x, double *h, double *output, int size) {
 //    M: length of h
 //    y: output signal samples, scaled to be between -1.0 and 1.0
 //    P: length of y, this should equal N + M - 1
-void fft_convolution(float *x, int N, float *h, int M, double *y, int P) {
+void fft_convolution(float *x, int N, float *h, int M, float *y, int P) {
     int padded_size = next_power(P);
 
-    double* padded_x = new double[2 * padded_size];
-    double* padded_h = new double[2 * padded_size];
-    double* padded_out = new double[2 * padded_size];
+    float* padded_x = new float[2 * padded_size];
+    float* padded_h = new float[2 * padded_size];
+    float* padded_out = new float[2 * padded_size];
 
     zero_padding(x, N, padded_x, 2 * padded_size);
     zero_padding(h, M, padded_h, 2 * padded_size);
@@ -159,7 +159,7 @@ void fft_convolution(float *x, int N, float *h, int M, double *y, int P) {
     four1(padded_out - 1, padded_size, -1);
 
     for (int i = 0; i < P; i++)
-        y[i] = padded_out[i * 2] / (double)N;
+        y[i] = padded_out[i * 2] / (float)N;
     
     delete(padded_x);
     delete(padded_h);
diff --git a/profiling/flute-manual-3.out b/profiling/flute-manual-3.out
new file mode 100644
index 0000000..a35f53a
Binary files /dev/null and b/profiling/flute-manual-3.out differ
diff --git a/profiling/flute-manual-3.txt b/profiling/flute-manual-3.txt
new file mode 100644
index 0000000..e06b806
--- /dev/null
+++ b/profiling/flute-manual-3.txt
@@ -0,0 +1,288 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 92.60      3.88     3.88        3     1.29     1.29  four1(float*, int, int)
+  1.91      3.96     0.08                             complex_multiply(void*)
+  1.67      4.03     0.07        2     0.04     0.04  zero_padding(float*, int, float*, int)
+  0.95      4.07     0.04        2     0.02     0.02  get_file_data(file_data&, _IO_FILE*, int)
+  0.72      4.10     0.03  2810257     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  0.72      4.13     0.03        1     0.03     3.99  convolution(wav_file, wav_file)
+  0.72      4.16     0.03        1     0.03     0.06  write_file_data(file_data, _IO_FILE*, int)
+  0.24      4.17     0.01  2810262     0.00     0.00  short_from_buffer(char*)
+  0.24      4.18     0.01        1     0.01     3.96  fft_convolution(float*, int, float*, int, float*, int)
+  0.24      4.19     0.01                             _init
+  0.00      4.19     0.00  2810349     0.00     0.00  std::abs(float)
+  0.00      4.19     0.00  2810254     0.00     0.00  short_to_float(short)
+  0.00      4.19     0.00  2810253     0.00     0.00  double_to_short(double)
+  0.00      4.19     0.00       66     0.00     0.00  std::sin(float)
+  0.00      4.19     0.00       10     0.00     0.00  int_from_buffer(char*)
+  0.00      4.19     0.00        5     0.00     0.00  fwriteIntLSB(int, _IO_FILE*)
+  0.00      4.19     0.00        2     0.00     0.00  exit_if_invalid(char*)
+  0.00      4.19     0.00        2     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.00      4.19     0.00        2     0.00     0.00  get_file_header(file_header&, _IO_FILE*)
+  0.00      4.19     0.00        2     0.00     0.03  read_file(char*)
+  0.00      4.19     0.00        1     0.00     0.00  create_wav(short*, int, wav_file)
+  0.00      4.19     0.00        1     0.00     0.00  next_power(unsigned int)
+  0.00      4.19     0.00        1     0.00     0.06  write_to_file(wav_file, char*)
+  0.00      4.19     0.00        1     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      4.19     0.00        1     0.00     0.00  write_file_header(file_header, _IO_FILE*)
+  0.00      4.19     0.00        1     0.00     0.00  multithread_multiply(float*, float*, float*, int)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.24% of 4.19 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     97.9    0.00    4.10                 main [1]
+                0.03    3.96       1/1           convolution(wav_file, wav_file) [2]
+                0.00    0.06       1/1           write_to_file(wav_file, char*) [7]
+                0.00    0.05       2/2           read_file(char*) [9]
+                0.00    0.00       2/2           exit_if_invalid(char*) [28]
+-----------------------------------------------
+                0.03    3.96       1/1           main [1]
+[2]     95.2    0.03    3.96       1         convolution(wav_file, wav_file) [2]
+                0.01    3.95       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+                0.00    0.00 2810349/2810349     std::abs(float) [22]
+                0.00    0.00 2810254/2810254     short_to_float(short) [23]
+                0.00    0.00 2810253/2810253     double_to_short(double) [24]
+                0.00    0.00       1/1           create_wav(short*, int, wav_file) [30]
+-----------------------------------------------
+                0.01    3.95       1/1           convolution(wav_file, wav_file) [2]
+[3]     94.5    0.01    3.95       1         fft_convolution(float*, int, float*, int, float*, int) [3]
+                3.88    0.00       3/3           four1(float*, int, int) [4]
+                0.07    0.00       2/2           zero_padding(float*, int, float*, int) [6]
+                0.00    0.00       1/1           next_power(unsigned int) [31]
+                0.00    0.00       1/1           multithread_multiply(float*, float*, float*, int) [33]
+-----------------------------------------------
+                3.88    0.00       3/3           fft_convolution(float*, int, float*, int, float*, int) [3]
+[4]     92.6    3.88    0.00       3         four1(float*, int, int) [4]
+                0.00    0.00      66/66          std::sin(float) [25]
+-----------------------------------------------
+                                                 <spontaneous>
+[5]      1.9    0.08    0.00                 complex_multiply(void*) [5]
+-----------------------------------------------
+                0.07    0.00       2/2           fft_convolution(float*, int, float*, int, float*, int) [3]
+[6]      1.7    0.07    0.00       2         zero_padding(float*, int, float*, int) [6]
+-----------------------------------------------
+                0.00    0.06       1/1           main [1]
+[7]      1.4    0.00    0.06       1         write_to_file(wav_file, char*) [7]
+                0.03    0.03       1/1           write_file_data(file_data, _IO_FILE*, int) [8]
+                0.00    0.00       1/1           write_file_format(file_fmt, _IO_FILE*) [14]
+                0.00    0.00       1/1           write_file_header(file_header, _IO_FILE*) [32]
+-----------------------------------------------
+                0.03    0.03       1/1           write_to_file(wav_file, char*) [7]
+[8]      1.4    0.03    0.03       1         write_file_data(file_data, _IO_FILE*, int) [8]
+                0.03    0.00 2810253/2810257     fwriteShortLSB(short, _IO_FILE*) [11]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [27]
+-----------------------------------------------
+                0.00    0.05       2/2           main [1]
+[9]      1.2    0.00    0.05       2         read_file(char*) [9]
+                0.04    0.01       2/2           get_file_data(file_data&, _IO_FILE*, int) [10]
+                0.00    0.00       2/2           get_file_format(file_fmt&, _IO_FILE*) [15]
+                0.00    0.00       2/2           get_file_header(file_header&, _IO_FILE*) [29]
+-----------------------------------------------
+                0.04    0.01       2/2           read_file(char*) [9]
+[10]     1.2    0.04    0.01       2         get_file_data(file_data&, _IO_FILE*, int) [10]
+                0.01    0.00 2810254/2810262     short_from_buffer(char*) [12]
+                0.00    0.00       2/10          int_from_buffer(char*) [26]
+-----------------------------------------------
+                0.00    0.00       4/2810257     write_file_format(file_fmt, _IO_FILE*) [14]
+                0.03    0.00 2810253/2810257     write_file_data(file_data, _IO_FILE*, int) [8]
+[11]     0.7    0.03    0.00 2810257         fwriteShortLSB(short, _IO_FILE*) [11]
+-----------------------------------------------
+                0.00    0.00       8/2810262     get_file_format(file_fmt&, _IO_FILE*) [15]
+                0.01    0.00 2810254/2810262     get_file_data(file_data&, _IO_FILE*, int) [10]
+[12]     0.2    0.01    0.00 2810262         short_from_buffer(char*) [12]
+-----------------------------------------------
+                                                 <spontaneous>
+[13]     0.2    0.01    0.00                 _init [13]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [7]
+[14]     0.0    0.00    0.00       1         write_file_format(file_fmt, _IO_FILE*) [14]
+                0.00    0.00       4/2810257     fwriteShortLSB(short, _IO_FILE*) [11]
+                0.00    0.00       3/5           fwriteIntLSB(int, _IO_FILE*) [27]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [9]
+[15]     0.0    0.00    0.00       2         get_file_format(file_fmt&, _IO_FILE*) [15]
+                0.00    0.00       8/2810262     short_from_buffer(char*) [12]
+                0.00    0.00       6/10          int_from_buffer(char*) [26]
+-----------------------------------------------
+                0.00    0.00 2810349/2810349     convolution(wav_file, wav_file) [2]
+[22]     0.0    0.00    0.00 2810349         std::abs(float) [22]
+-----------------------------------------------
+                0.00    0.00 2810254/2810254     convolution(wav_file, wav_file) [2]
+[23]     0.0    0.00    0.00 2810254         short_to_float(short) [23]
+-----------------------------------------------
+                0.00    0.00 2810253/2810253     convolution(wav_file, wav_file) [2]
+[24]     0.0    0.00    0.00 2810253         double_to_short(double) [24]
+-----------------------------------------------
+                0.00    0.00      66/66          four1(float*, int, int) [4]
+[25]     0.0    0.00    0.00      66         std::sin(float) [25]
+-----------------------------------------------
+                0.00    0.00       2/10          get_file_header(file_header&, _IO_FILE*) [29]
+                0.00    0.00       2/10          get_file_data(file_data&, _IO_FILE*, int) [10]
+                0.00    0.00       6/10          get_file_format(file_fmt&, _IO_FILE*) [15]
+[26]     0.0    0.00    0.00      10         int_from_buffer(char*) [26]
+-----------------------------------------------
+                0.00    0.00       1/5           write_file_header(file_header, _IO_FILE*) [32]
+                0.00    0.00       1/5           write_file_data(file_data, _IO_FILE*, int) [8]
+                0.00    0.00       3/5           write_file_format(file_fmt, _IO_FILE*) [14]
+[27]     0.0    0.00    0.00       5         fwriteIntLSB(int, _IO_FILE*) [27]
+-----------------------------------------------
+                0.00    0.00       2/2           main [1]
+[28]     0.0    0.00    0.00       2         exit_if_invalid(char*) [28]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [9]
+[29]     0.0    0.00    0.00       2         get_file_header(file_header&, _IO_FILE*) [29]
+                0.00    0.00       2/10          int_from_buffer(char*) [26]
+-----------------------------------------------
+                0.00    0.00       1/1           convolution(wav_file, wav_file) [2]
+[30]     0.0    0.00    0.00       1         create_wav(short*, int, wav_file) [30]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[31]     0.0    0.00    0.00       1         next_power(unsigned int) [31]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [7]
+[32]     0.0    0.00    0.00       1         write_file_header(file_header, _IO_FILE*) [32]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [27]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[33]     0.0    0.00    0.00       1         multithread_multiply(float*, float*, float*, int) [33]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+  [30] create_wav(short*, int, wav_file) [24] double_to_short(double) [14] write_file_format(file_fmt, _IO_FILE*)
+  [31] next_power(unsigned int) [28] exit_if_invalid(char*) [32] write_file_header(file_header, _IO_FILE*)
+   [2] convolution(wav_file, wav_file) [3] fft_convolution(float*, int, float*, int, float*, int) [33] multithread_multiply(float*, float*, float*, int)
+  [27] fwriteIntLSB(int, _IO_FILE*) [15] get_file_format(file_fmt&, _IO_FILE*) [4] four1(float*, int, int)
+   [6] zero_padding(float*, int, float*, int) [29] get_file_header(file_header&, _IO_FILE*) [9] read_file(char*)
+  [10] get_file_data(file_data&, _IO_FILE*, int) [26] int_from_buffer(char*) [22] std::abs(float)
+   [7] write_to_file(wav_file, char*) [8] write_file_data(file_data, _IO_FILE*, int) [25] std::sin(float)
+  [11] fwriteShortLSB(short, _IO_FILE*) [5] complex_multiply(void*) [13] _init
+  [23] short_to_float(short)  [12] short_from_buffer(char*)
diff --git a/profiling/guitar-manual-3.out b/profiling/guitar-manual-3.out
new file mode 100644
index 0000000..da0cc1b
Binary files /dev/null and b/profiling/guitar-manual-3.out differ
diff --git a/profiling/guitar-manual-3.txt b/profiling/guitar-manual-3.txt
new file mode 100644
index 0000000..1ceef9f
--- /dev/null
+++ b/profiling/guitar-manual-3.txt
@@ -0,0 +1,288 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 88.24      1.35     1.35        3     0.45     0.45  four1(float*, int, int)
+  5.88      1.44     0.09                             complex_multiply(void*)
+  1.96      1.47     0.03        2     0.01     0.01  zero_padding(float*, int, float*, int)
+  0.65      1.48     0.01  1871492     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  0.65      1.49     0.01  1871488     0.00     0.00  double_to_short(double)
+  0.65      1.50     0.01        2     0.01     0.01  get_file_data(file_data&, _IO_FILE*, int)
+  0.65      1.51     0.01        1     0.01     1.40  convolution(wav_file, wav_file)
+  0.65      1.52     0.01        1     0.01     0.02  write_file_data(file_data, _IO_FILE*, int)
+  0.65      1.53     0.01                             _init
+  0.00      1.53     0.00  1871544     0.00     0.00  std::abs(float)
+  0.00      1.53     0.00  1871489     0.00     0.00  short_to_float(short)
+  0.00      1.53     0.00  1769480     0.00     0.00  short_from_buffer(char*)
+  0.00      1.53     0.00   102027     0.00     0.00  int_from_buffer(char*)
+  0.00      1.53     0.00       63     0.00     0.00  std::sin(float)
+  0.00      1.53     0.00        5     0.00     0.00  fwriteIntLSB(int, _IO_FILE*)
+  0.00      1.53     0.00        2     0.00     0.00  exit_if_invalid(char*)
+  0.00      1.53     0.00        2     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.00      1.53     0.00        2     0.00     0.00  get_file_header(file_header&, _IO_FILE*)
+  0.00      1.53     0.00        2     0.00     0.01  read_file(char*)
+  0.00      1.53     0.00        1     0.00     0.00  create_wav(short*, int, wav_file)
+  0.00      1.53     0.00        1     0.00     0.00  next_power(unsigned int)
+  0.00      1.53     0.00        1     0.00     0.02  write_to_file(wav_file, char*)
+  0.00      1.53     0.00        1     0.00     1.38  fft_convolution(float*, int, float*, int, float*, int)
+  0.00      1.53     0.00        1     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      1.53     0.00        1     0.00     0.00  write_file_header(file_header, _IO_FILE*)
+  0.00      1.53     0.00        1     0.00     0.00  multithread_multiply(float*, float*, float*, int)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.65% of 1.53 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     93.5    0.00    1.43                 main [1]
+                0.01    1.39       1/1           convolution(wav_file, wav_file) [2]
+                0.00    0.02       1/1           write_to_file(wav_file, char*) [7]
+                0.00    0.01       2/2           read_file(char*) [12]
+                0.00    0.00       2/2           exit_if_invalid(char*) [27]
+-----------------------------------------------
+                0.01    1.39       1/1           main [1]
+[2]     91.5    0.01    1.39       1         convolution(wav_file, wav_file) [2]
+                0.00    1.38       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+                0.01    0.00 1871488/1871488     double_to_short(double) [10]
+                0.00    0.00 1871544/1871544     std::abs(float) [21]
+                0.00    0.00 1871489/1871489     short_to_float(short) [22]
+                0.00    0.00       1/1           create_wav(short*, int, wav_file) [30]
+-----------------------------------------------
+                0.00    1.38       1/1           convolution(wav_file, wav_file) [2]
+[3]     90.2    0.00    1.38       1         fft_convolution(float*, int, float*, int, float*, int) [3]
+                1.35    0.00       3/3           four1(float*, int, int) [4]
+                0.03    0.00       2/2           zero_padding(float*, int, float*, int) [6]
+                0.00    0.00       1/1           next_power(unsigned int) [31]
+                0.00    0.00       1/1           multithread_multiply(float*, float*, float*, int) [33]
+-----------------------------------------------
+                1.35    0.00       3/3           fft_convolution(float*, int, float*, int, float*, int) [3]
+[4]     88.2    1.35    0.00       3         four1(float*, int, int) [4]
+                0.00    0.00      63/63          std::sin(float) [25]
+-----------------------------------------------
+                                                 <spontaneous>
+[5]      5.9    0.09    0.00                 complex_multiply(void*) [5]
+-----------------------------------------------
+                0.03    0.00       2/2           fft_convolution(float*, int, float*, int, float*, int) [3]
+[6]      2.0    0.03    0.00       2         zero_padding(float*, int, float*, int) [6]
+-----------------------------------------------
+                0.00    0.02       1/1           main [1]
+[7]      1.3    0.00    0.02       1         write_to_file(wav_file, char*) [7]
+                0.01    0.01       1/1           write_file_data(file_data, _IO_FILE*, int) [8]
+                0.00    0.00       1/1           write_file_format(file_fmt, _IO_FILE*) [14]
+                0.00    0.00       1/1           write_file_header(file_header, _IO_FILE*) [32]
+-----------------------------------------------
+                0.01    0.01       1/1           write_to_file(wav_file, char*) [7]
+[8]      1.3    0.01    0.01       1         write_file_data(file_data, _IO_FILE*, int) [8]
+                0.01    0.00 1871488/1871492     fwriteShortLSB(short, _IO_FILE*) [9]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00       4/1871492     write_file_format(file_fmt, _IO_FILE*) [14]
+                0.01    0.00 1871488/1871492     write_file_data(file_data, _IO_FILE*, int) [8]
+[9]      0.7    0.01    0.00 1871492         fwriteShortLSB(short, _IO_FILE*) [9]
+-----------------------------------------------
+                0.01    0.00 1871488/1871488     convolution(wav_file, wav_file) [2]
+[10]     0.7    0.01    0.00 1871488         double_to_short(double) [10]
+-----------------------------------------------
+                0.01    0.00       2/2           read_file(char*) [12]
+[11]     0.7    0.01    0.00       2         get_file_data(file_data&, _IO_FILE*, int) [11]
+                0.00    0.00 1769472/1769480     short_from_buffer(char*) [23]
+                0.00    0.00  102019/102027      int_from_buffer(char*) [24]
+-----------------------------------------------
+                0.00    0.01       2/2           main [1]
+[12]     0.7    0.00    0.01       2         read_file(char*) [12]
+                0.01    0.00       2/2           get_file_data(file_data&, _IO_FILE*, int) [11]
+                0.00    0.00       2/2           get_file_header(file_header&, _IO_FILE*) [29]
+                0.00    0.00       2/2           get_file_format(file_fmt&, _IO_FILE*) [28]
+-----------------------------------------------
+                                                 <spontaneous>
+[13]     0.7    0.01    0.00                 _init [13]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [7]
+[14]     0.0    0.00    0.00       1         write_file_format(file_fmt, _IO_FILE*) [14]
+                0.00    0.00       4/1871492     fwriteShortLSB(short, _IO_FILE*) [9]
+                0.00    0.00       3/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00 1871544/1871544     convolution(wav_file, wav_file) [2]
+[21]     0.0    0.00    0.00 1871544         std::abs(float) [21]
+-----------------------------------------------
+                0.00    0.00 1871489/1871489     convolution(wav_file, wav_file) [2]
+[22]     0.0    0.00    0.00 1871489         short_to_float(short) [22]
+-----------------------------------------------
+                0.00    0.00       8/1769480     get_file_format(file_fmt&, _IO_FILE*) [28]
+                0.00    0.00 1769472/1769480     get_file_data(file_data&, _IO_FILE*, int) [11]
+[23]     0.0    0.00    0.00 1769480         short_from_buffer(char*) [23]
+-----------------------------------------------
+                0.00    0.00       2/102027      get_file_header(file_header&, _IO_FILE*) [29]
+                0.00    0.00       6/102027      get_file_format(file_fmt&, _IO_FILE*) [28]
+                0.00    0.00  102019/102027      get_file_data(file_data&, _IO_FILE*, int) [11]
+[24]     0.0    0.00    0.00  102027         int_from_buffer(char*) [24]
+-----------------------------------------------
+                0.00    0.00      63/63          four1(float*, int, int) [4]
+[25]     0.0    0.00    0.00      63         std::sin(float) [25]
+-----------------------------------------------
+                0.00    0.00       1/5           write_file_header(file_header, _IO_FILE*) [32]
+                0.00    0.00       1/5           write_file_data(file_data, _IO_FILE*, int) [8]
+                0.00    0.00       3/5           write_file_format(file_fmt, _IO_FILE*) [14]
+[26]     0.0    0.00    0.00       5         fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00       2/2           main [1]
+[27]     0.0    0.00    0.00       2         exit_if_invalid(char*) [27]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [12]
+[28]     0.0    0.00    0.00       2         get_file_format(file_fmt&, _IO_FILE*) [28]
+                0.00    0.00       8/1769480     short_from_buffer(char*) [23]
+                0.00    0.00       6/102027      int_from_buffer(char*) [24]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [12]
+[29]     0.0    0.00    0.00       2         get_file_header(file_header&, _IO_FILE*) [29]
+                0.00    0.00       2/102027      int_from_buffer(char*) [24]
+-----------------------------------------------
+                0.00    0.00       1/1           convolution(wav_file, wav_file) [2]
+[30]     0.0    0.00    0.00       1         create_wav(short*, int, wav_file) [30]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[31]     0.0    0.00    0.00       1         next_power(unsigned int) [31]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [7]
+[32]     0.0    0.00    0.00       1         write_file_header(file_header, _IO_FILE*) [32]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, float*, int) [3]
+[33]     0.0    0.00    0.00       1         multithread_multiply(float*, float*, float*, int) [33]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+  [30] create_wav(short*, int, wav_file) [10] double_to_short(double) [14] write_file_format(file_fmt, _IO_FILE*)
+  [31] next_power(unsigned int) [27] exit_if_invalid(char*) [32] write_file_header(file_header, _IO_FILE*)
+   [2] convolution(wav_file, wav_file) [3] fft_convolution(float*, int, float*, int, float*, int) [33] multithread_multiply(float*, float*, float*, int)
+  [26] fwriteIntLSB(int, _IO_FILE*) [28] get_file_format(file_fmt&, _IO_FILE*) [4] four1(float*, int, int)
+   [6] zero_padding(float*, int, float*, int) [29] get_file_header(file_header&, _IO_FILE*) [12] read_file(char*)
+  [11] get_file_data(file_data&, _IO_FILE*, int) [24] int_from_buffer(char*) [21] std::abs(float)
+   [7] write_to_file(wav_file, char*) [8] write_file_data(file_data, _IO_FILE*, int) [25] std::sin(float)
+   [9] fwriteShortLSB(short, _IO_FILE*) [5] complex_multiply(void*) [13] _init
+  [22] short_to_float(short)  [23] short_from_buffer(char*)
diff --git a/report.md b/report.md
index 8220f4a..29a742e 100644
--- a/report.md
+++ b/report.md
@@ -211,3 +211,54 @@ sys     0m0.139s
 **Regression Testing**:
  - A minor bug with the `for` loop values was caught by the existing unit tests.
  - Manual convolution testing is successful and has expected results.
+
+### Manual Code Tuning #3:
+ - The `four1` algorithm as given to us uses doubles as its data type of choice. We don't need that level of precision for these simple convolutions and can change them all to floats.
+ - As floats are half the size of doubles, this will drastically speed up operations that involve the various double arrays that are prevalent in the code.
+
+**Commit**: []()
+
+**Code Changes**:
+ - The main code change is present in the `four1` method, although there are many other places where doubles are changed to floats for performance.
+ - Consult the github commit to see the full list of changes.
+```c
+void four1(float *data, int nn, int isign) {
+    unsigned long n, mmax, m, j, istep, i;
+    float wtemp, wr, wpr, wpi, wi, theta;
+    float tempr, tempi;
+    ...
+}
+```
+
+**Run Time Performance**:
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/out.wav
+real    0m5.100s
+user    0m4.475s
+sys     0m0.150s
+>>> gprof convolve profiling/flute-manual-3.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 92.60      3.88     3.88        3     1.29     1.29  four1(float*, int, int)
+  1.91      3.96     0.08                             complex_multiply(void*)
+  1.67      4.03     0.07        2     0.04     0.04  zero_padding(float*, int, float*, int)
+```
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    0m2.133s
+user    0m1.700s
+sys     0m0.110s
+>>> gprof convolve profiling/guitar-manual-3.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 88.24      1.35     1.35        3     0.45     0.45  four1(float*, int, int)
+  5.88      1.44     0.09                             complex_multiply(void*)
+  1.96      1.47     0.03        2     0.01     0.01  zero_padding(float*, int, float*, int)
+```
+ - The number of seconds per call of the `four1` function has been drastically reduced. For the `FluteDry` convolution, this has been reduced from 1.6 seconds per call to 1.29 seconds per call. For the `GuitarDry` convolution, this has been reduced from 0.63 seconds per call to 0.45 seconds per call.
+ - Changing doubles to floats has decreased the total run speed by 1/6th. That is almost a 20% increase in speed.
+ - This is pretty clearly a huge performance boost
+
+**Regression Testing**:
+ - There was mild concern that changing from doubles to floats would cause incorrect outputs as there is a loss of 4 bytes of precision.
+ - This is not the case, all of the unit tests pass and manually running the convolution code using the new `four1` function produces the same result.
diff --git a/test.cpp b/test.cpp
index f465e64..9ecbac7 100644
--- a/test.cpp
+++ b/test.cpp
@@ -52,10 +52,10 @@ int test_linear_convolution() {
     int M = 2;
     float h[] = { 0.1, 0.2 };
     int P = N + M + 1;
-    double y[P];
+    float y[P];
     linear_convolution(x, N, h, M, y, P);
 
-    double expected[] = {
+    float expected[] = {
         0.020000,
         0.070000,
         0.100000,
@@ -80,10 +80,10 @@ int test_fft_convolution() {
     int M = 2;
     float h[] = { 0.1, 0.2 };
     int P = N + M - 1;
-    double y[P];
+    float y[P];
     fft_convolution(x, N, h, M, y, P);
 
-    double expected[] = {
+    float expected[] = {
         0.026,
         0.093,
         0.133,
@@ -102,16 +102,16 @@ int test_fft_convolution() {
 
 // Copied from fast_fourier.cpp
 struct complex_param {
-    double *x;
-    double *h;
-    double *output;
+    float *x;
+    float *h;
+    float *output;
     int size;
 };
 
 int test_complex_multiplication() {
-    double x[] = { 1, 2, 3, 4 };
-    double h[] = { 8, 7, 6, 5 };
-    double o[4];
+    float x[] = { 1, 2, 3, 4 };
+    float h[] = { 8, 7, 6, 5 };
+    float o[4];
 
     complex_param p;
     p.x = &x[0];
@@ -120,7 +120,7 @@ int test_complex_multiplication() {
     p.size = 4;
     complex_multiply((void *)&p);
 
-    double e[] = { -6.0, 23.0, -2.0, 39.0 };
+    float e[] = { -6.0, 23.0, -2.0, 39.0 };
 
     for (int i = 0; i < 4; i++) {
         if (o[i] != e[i]) {
@@ -134,9 +134,9 @@ int test_complex_multiplication() {
 
 int test_zero_padding() {
     float signal[] = { 0.5, 0.6, 0.7 };
-    double output[8];
+    float output[8];
     zero_padding(signal, 3, output, 8);
-    double expected[] = { 0.5, 0.0, 0.6, 0.0, 0.7, 0.0, 0.0, 0.0 };
+    float expected[] = { 0.5, 0.0, 0.6, 0.0, 0.7, 0.0, 0.0, 0.0 };
     for (int i = 0; i < 8; i++) {
         if ((float)(output[i]) != (float)(expected[i])) {
             printf("Error in zero padding.\n\tExpected: [%.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f]\n\tActual:   [%.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f]\n",

commit f2be2c3c9d1da9f74bf39dc35691630512be25d7
Author: alexs2112 <alexste2112@gmail.com>
Date:   Mon Dec 4 12:37:56 2023 -0700

    more unit tests, update report

diff --git a/headers/fast_fourier.h b/headers/fast_fourier.h
index 6d58fa1..eca93a8 100644
--- a/headers/fast_fourier.h
+++ b/headers/fast_fourier.h
@@ -1,2 +1,3 @@
 void fft_convolution(float *x, int N, float *h, int M, double *y, int P);
 void *complex_multiply(void *v);
+void zero_padding(float *signal, int input_size, double *output, int output_size);
diff --git a/modules/fast_fourier.cpp b/modules/fast_fourier.cpp
index 9effc30..c6d20da 100644
--- a/modules/fast_fourier.cpp
+++ b/modules/fast_fourier.cpp
@@ -84,7 +84,7 @@ void zero_padding(float *signal, int input_size, double *output, int output_size
         output[i*2] = (double)signal[i];
         output[i*2 + 1] = 0.0;
     }
-    for (i = input_size * 2 + 1; i < output_size; i++) {
+    for (i = input_size * 2; i < output_size; i++) {
         output[i] = 0.0;
     }
 }
diff --git a/report.md b/report.md
index 4b9c232..8220f4a 100644
--- a/report.md
+++ b/report.md
@@ -164,6 +164,8 @@ sys     0m0.134s
  - This can be optimized by only going over the array once by zeroing the imaginary part of the array at the same time as copying values from the input array.
     - *Note*: If the output array size is greater than twice the length of the input array then the remainder will still need to be zeroed. This is easy to accomplish by starting another `for` loop at the index of `2 * input_length + 1`.
 
+**Commit**: [95c75c13fa76d35a41940a4d9794334dfae4f208](https://github.com/alexs2112/CPSC501-Convolution/commit/95c75c13fa76d35a41940a4d9794334dfae4f208)
+
 **Code Changes**:
 ```c
 void zero_padding(float *signal, int input_size, double *output, int output_size) {
diff --git a/test.cpp b/test.cpp
index e098036..f465e64 100644
--- a/test.cpp
+++ b/test.cpp
@@ -8,11 +8,20 @@
 #include "headers/file_structs.h"
 #endif
 
+/****************************************************************************
+ * Custom unit testing framework                                            *
+ * To add a new test:                                                       *
+ *  Add the test function and test definition                               *
+ *  Increment NUM_TESTS                                                     *
+ *  Add a pointer to the new test to the `tests` array at the start of main *
+ ****************************************************************************/
+
 /* Test Definitions */
-#define NUM_TESTS   3
+#define NUM_TESTS   4
 int test_linear_convolution();
 int test_fft_convolution();
 int test_complex_multiplication();
+int test_zero_padding();
 
 /* Main Function */
 int main(int argc, char* argv[]) {
@@ -20,6 +29,7 @@ int main(int argc, char* argv[]) {
         test_linear_convolution,
         test_fft_convolution,
         test_complex_multiplication,
+        test_zero_padding,
     };
 
     // Run each test loaded into tests
@@ -120,4 +130,20 @@ int test_complex_multiplication() {
         }
     }
     return 0;
+}
+
+int test_zero_padding() {
+    float signal[] = { 0.5, 0.6, 0.7 };
+    double output[8];
+    zero_padding(signal, 3, output, 8);
+    double expected[] = { 0.5, 0.0, 0.6, 0.0, 0.7, 0.0, 0.0, 0.0 };
+    for (int i = 0; i < 8; i++) {
+        if ((float)(output[i]) != (float)(expected[i])) {
+            printf("Error in zero padding.\n\tExpected: [%.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f]\n\tActual:   [%.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f]\n",
+                expected[0], expected[1], expected[2], expected[3], expected[4], expected[5], expected[6], expected[7],
+                output[0], output[1], output[2], output[3], output[4], output[5], output[6], output[7]);
+            return 1;
+        }
+    }
+    return 0;
 }
\ No newline at end of file

commit 95c75c13fa76d35a41940a4d9794334dfae4f208
Author: alexs2112 <alexste2112@gmail.com>
Date:   Sun Dec 3 19:56:49 2023 -0700

    manual tuning: jamming zero padding for loops to reduce iterations

diff --git a/convolve.cpp b/convolve.cpp
index 730094a..44f8926 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -36,16 +36,16 @@ int main(int argc, char* argv[]) {
     exit_if_invalid(argv[2]);
 
     wav_file input = read_file(argv[1]);
-    printf("INPUT FILE:\n");
-    print_file_data(input);
+    // printf("INPUT FILE:\n");
+    // print_file_data(input);
 
     wav_file ir = read_file(argv[2]);
-    printf("\nIMPULSE RESPONSE:\n");
-    print_file_data(ir);
+    // printf("\nIMPULSE RESPONSE:\n");
+    // print_file_data(ir);
 
     wav_file output = convolution(input, ir);
-    printf("\nOUTPUT FILE:\n");
-    print_file_data(output);
+    // printf("\nOUTPUT FILE:\n");
+    // print_file_data(output);
 
     write_to_file(output, argv[3]);
 
diff --git a/modules/fast_fourier.cpp b/modules/fast_fourier.cpp
index 0cb963e..9effc30 100644
--- a/modules/fast_fourier.cpp
+++ b/modules/fast_fourier.cpp
@@ -80,12 +80,12 @@ unsigned int next_power(unsigned int v) {
 // Output size should be 2x the padded size to account for complex numbers
 void zero_padding(float *signal, int input_size, double *output, int output_size) {
     int i;
-    for (i = 0; i < output_size; i++) {
-        output[i] = 0.0;
-    }
-
     for (i = 0; i < input_size; i++) {
         output[i*2] = (double)signal[i];
+        output[i*2 + 1] = 0.0;
+    }
+    for (i = input_size * 2 + 1; i < output_size; i++) {
+        output[i] = 0.0;
     }
 }
 
diff --git a/profiling/flute-manual-1.txt b/profiling/flute-manual-1.txt
new file mode 100644
index 0000000..6b07477
--- /dev/null
+++ b/profiling/flute-manual-1.txt
@@ -0,0 +1,292 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 94.22      5.38     5.38        3     1.79     1.79  four1(double*, int, int)
+  1.75      5.48     0.10        2     0.05     0.05  zero_padding(float*, int, double*, int)
+  1.75      5.58     0.10                             complex_multiply(void*)
+  0.88      5.63     0.05        1     0.05     0.06  convolution(wav_file, wav_file)
+  0.53      5.66     0.03        2     0.01     0.01  get_file_data(file_data&, _IO_FILE*, int)
+  0.35      5.68     0.02        1     0.02     0.02  write_file_data(file_data, _IO_FILE*, int)
+  0.18      5.69     0.01  2810254     0.00     0.00  exit_if_invalid(char*)
+  0.18      5.70     0.01       12     0.00     0.46  fft_convolution(float*, int, float*, int, double*, int)
+  0.18      5.71     0.01                             double_to_short(double)
+  0.00      5.71     0.00  2810354     0.00     0.00  std::abs(double)
+  0.00      5.71     0.00  2810262     0.00     0.00  short_from_buffer(char*)
+  0.00      5.71     0.00  2810257     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  0.00      5.71     0.00  2810253     0.00     0.00  float_to_short(float)
+  0.00      5.71     0.00       10     0.00     0.00  int_from_buffer(char*)
+  0.00      5.71     0.00        5     0.00     0.00  fwriteIntLSB(int, _IO_FILE*)
+  0.00      5.71     0.00        3     0.00     0.46  print_id(char*)
+  0.00      5.71     0.00        2     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.00      5.71     0.00        2     0.00     0.00  get_file_header(file_header&, _IO_FILE*)
+  0.00      5.71     0.00        2     0.00     2.06  print_file_data(wav_file)
+  0.00      5.71     0.00        2     0.00     0.00  multithread_multiply(double*, double*, double*, int)
+  0.00      5.71     0.00        2     0.00     0.01  read_file(char*)
+  0.00      5.71     0.00        1     0.00     0.00  create_wav(short*, int, wav_file)
+  0.00      5.71     0.00        1     0.00     0.00  next_power(unsigned int)
+  0.00      5.71     0.00        1     0.00     0.02  write_to_file(wav_file, char*)
+  0.00      5.71     0.00        1     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      5.71     0.00        1     0.00     0.00  write_file_header(file_header, _IO_FILE*)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.18% of 5.71 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     98.1    0.00    5.60                 main [1]
+                0.00    4.12       2/2           print_file_data(wav_file) [4]
+                0.00    1.37       3/3           print_id(char*) [5]
+                0.05    0.01       1/1           convolution(wav_file, wav_file) [8]
+                0.00    0.03       2/2           read_file(char*) [10]
+                0.00    0.02       1/1           write_to_file(wav_file, char*) [11]
+-----------------------------------------------
+                0.00    1.37       3/12          print_id(char*) [5]
+                0.01    4.11       9/12          print_file_data(wav_file) [4]
+[2]     96.1    0.01    5.48      12         fft_convolution(float*, int, float*, int, double*, int) [2]
+                5.38    0.00       3/3           four1(double*, int, int) [3]
+                0.10    0.00       2/2           zero_padding(float*, int, double*, int) [6]
+                0.00    0.00       1/1           next_power(unsigned int) [31]
+                0.00    0.00       1/2           multithread_multiply(double*, double*, double*, int) [29]
+-----------------------------------------------
+                5.38    0.00       3/3           fft_convolution(float*, int, float*, int, double*, int) [2]
+[3]     94.2    5.38    0.00       3         four1(double*, int, int) [3]
+-----------------------------------------------
+                0.00    4.12       2/2           main [1]
+[4]     72.1    0.00    4.12       2         print_file_data(wav_file) [4]
+                0.01    4.11       9/12          fft_convolution(float*, int, float*, int, double*, int) [2]
+-----------------------------------------------
+                0.00    1.37       3/3           main [1]
+[5]     24.0    0.00    1.37       3         print_id(char*) [5]
+                0.00    1.37       3/12          fft_convolution(float*, int, float*, int, double*, int) [2]
+-----------------------------------------------
+                0.10    0.00       2/2           fft_convolution(float*, int, float*, int, double*, int) [2]
+[6]      1.8    0.10    0.00       2         zero_padding(float*, int, double*, int) [6]
+-----------------------------------------------
+                                                 <spontaneous>
+[7]      1.8    0.10    0.00                 complex_multiply(void*) [7]
+-----------------------------------------------
+                0.05    0.01       1/1           main [1]
+[8]      1.1    0.05    0.01       1         convolution(wav_file, wav_file) [8]
+                0.01    0.00 2810254/2810254     exit_if_invalid(char*) [13]
+                0.00    0.00 2810354/2810354     std::abs(double) [21]
+                0.00    0.00 2810253/2810253     float_to_short(float) [24]
+                0.00    0.00       1/2           multithread_multiply(double*, double*, double*, int) [29]
+                0.00    0.00       1/1           create_wav(short*, int, wav_file) [30]
+-----------------------------------------------
+                0.03    0.00       2/2           read_file(char*) [10]
+[9]      0.5    0.03    0.00       2         get_file_data(file_data&, _IO_FILE*, int) [9]
+                0.00    0.00 2810254/2810262     short_from_buffer(char*) [22]
+                0.00    0.00       2/10          int_from_buffer(char*) [25]
+-----------------------------------------------
+                0.00    0.03       2/2           main [1]
+[10]     0.5    0.00    0.03       2         read_file(char*) [10]
+                0.03    0.00       2/2           get_file_data(file_data&, _IO_FILE*, int) [9]
+                0.00    0.00       2/2           get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       2/2           get_file_format(file_fmt&, _IO_FILE*) [27]
+-----------------------------------------------
+                0.00    0.02       1/1           main [1]
+[11]     0.4    0.00    0.02       1         write_to_file(wav_file, char*) [11]
+                0.02    0.00       1/1           write_file_data(file_data, _IO_FILE*, int) [12]
+                0.00    0.00       1/1           write_file_header(file_header, _IO_FILE*) [33]
+                0.00    0.00       1/1           write_file_format(file_fmt, _IO_FILE*) [32]
+-----------------------------------------------
+                0.02    0.00       1/1           write_to_file(wav_file, char*) [11]
+[12]     0.4    0.02    0.00       1         write_file_data(file_data, _IO_FILE*, int) [12]
+                0.00    0.00 2810253/2810257     fwriteShortLSB(short, _IO_FILE*) [23]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.01    0.00 2810254/2810254     convolution(wav_file, wav_file) [8]
+[13]     0.2    0.01    0.00 2810254         exit_if_invalid(char*) [13]
+-----------------------------------------------
+                                                 <spontaneous>
+[14]     0.2    0.01    0.00                 double_to_short(double) [14]
+-----------------------------------------------
+                0.00    0.00 2810354/2810354     convolution(wav_file, wav_file) [8]
+[21]     0.0    0.00    0.00 2810354         std::abs(double) [21]
+-----------------------------------------------
+                0.00    0.00       8/2810262     get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00 2810254/2810262     get_file_data(file_data&, _IO_FILE*, int) [9]
+[22]     0.0    0.00    0.00 2810262         short_from_buffer(char*) [22]
+-----------------------------------------------
+                0.00    0.00       4/2810257     write_file_format(file_fmt, _IO_FILE*) [32]
+                0.00    0.00 2810253/2810257     write_file_data(file_data, _IO_FILE*, int) [12]
+[23]     0.0    0.00    0.00 2810257         fwriteShortLSB(short, _IO_FILE*) [23]
+-----------------------------------------------
+                0.00    0.00 2810253/2810253     convolution(wav_file, wav_file) [8]
+[24]     0.0    0.00    0.00 2810253         float_to_short(float) [24]
+-----------------------------------------------
+                0.00    0.00       2/10          get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       2/10          get_file_data(file_data&, _IO_FILE*, int) [9]
+                0.00    0.00       6/10          get_file_format(file_fmt&, _IO_FILE*) [27]
+[25]     0.0    0.00    0.00      10         int_from_buffer(char*) [25]
+-----------------------------------------------
+                0.00    0.00       1/5           write_file_header(file_header, _IO_FILE*) [33]
+                0.00    0.00       1/5           write_file_data(file_data, _IO_FILE*, int) [12]
+                0.00    0.00       3/5           write_file_format(file_fmt, _IO_FILE*) [32]
+[26]     0.0    0.00    0.00       5         fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [10]
+[27]     0.0    0.00    0.00       2         get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00       8/2810262     short_from_buffer(char*) [22]
+                0.00    0.00       6/10          int_from_buffer(char*) [25]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [10]
+[28]     0.0    0.00    0.00       2         get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       2/10          int_from_buffer(char*) [25]
+-----------------------------------------------
+                0.00    0.00       1/2           convolution(wav_file, wav_file) [8]
+                0.00    0.00       1/2           fft_convolution(float*, int, float*, int, double*, int) [2]
+[29]     0.0    0.00    0.00       2         multithread_multiply(double*, double*, double*, int) [29]
+-----------------------------------------------
+                0.00    0.00       1/1           convolution(wav_file, wav_file) [8]
+[30]     0.0    0.00    0.00       1         create_wav(short*, int, wav_file) [30]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, double*, int) [2]
+[31]     0.0    0.00    0.00       1         next_power(unsigned int) [31]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [11]
+[32]     0.0    0.00    0.00       1         write_file_format(file_fmt, _IO_FILE*) [32]
+                0.00    0.00       4/2810257     fwriteShortLSB(short, _IO_FILE*) [23]
+                0.00    0.00       3/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [11]
+[33]     0.0    0.00    0.00       1         write_file_header(file_header, _IO_FILE*) [33]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+  [30] create_wav(short*, int, wav_file) [14] double_to_short(double) [22] short_from_buffer(char*)
+  [31] next_power(unsigned int) [13] exit_if_invalid(char*) [32] write_file_format(file_fmt, _IO_FILE*)
+   [8] convolution(wav_file, wav_file) [2] fft_convolution(float*, int, float*, int, double*, int) [33] write_file_header(file_header, _IO_FILE*)
+  [26] fwriteIntLSB(int, _IO_FILE*) [27] get_file_format(file_fmt&, _IO_FILE*) [29] multithread_multiply(double*, double*, double*, int)
+   [6] zero_padding(float*, int, double*, int) [28] get_file_header(file_header&, _IO_FILE*) [3] four1(double*, int, int)
+   [9] get_file_data(file_data&, _IO_FILE*, int) [25] int_from_buffer(char*) [5] print_id(char*)
+  [11] write_to_file(wav_file, char*) [4] print_file_data(wav_file) [10] read_file(char*)
+  [24] float_to_short(float)  [12] write_file_data(file_data, _IO_FILE*, int) [21] std::abs(double)
+  [23] fwriteShortLSB(short, _IO_FILE*) [7] complex_multiply(void*)
diff --git a/profiling/flute-manual-2.out b/profiling/flute-manual-2.out
new file mode 100644
index 0000000..60c3b19
Binary files /dev/null and b/profiling/flute-manual-2.out differ
diff --git a/profiling/flute-manual-2.txt b/profiling/flute-manual-2.txt
new file mode 100644
index 0000000..c561376
--- /dev/null
+++ b/profiling/flute-manual-2.txt
@@ -0,0 +1,293 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 92.47      4.79     4.79        3     1.60     1.60  four1(double*, int, int)
+  2.70      4.93     0.14                             complex_multiply(void*)
+  2.32      5.05     0.12        2     0.06     0.06  zero_padding(float*, int, double*, int)
+  0.58      5.08     0.03        2     0.01     0.01  get_file_data(file_data&, _IO_FILE*, int)
+  0.58      5.11     0.03        1     0.03     4.96  convolution(wav_file, wav_file)
+  0.58      5.14     0.03        1     0.03     0.05  write_file_data(file_data, _IO_FILE*, int)
+  0.39      5.16     0.02  2810257     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  0.19      5.17     0.01        1     0.01     4.92  fft_convolution(float*, int, float*, int, double*, int)
+  0.10      5.17     0.01  2810253     0.00     0.00  double_to_short(double)
+  0.10      5.18     0.01                             std::rint(float)
+  0.00      5.18     0.00  2810347     0.00     0.00  std::abs(double)
+  0.00      5.18     0.00  2810262     0.00     0.00  short_from_buffer(char*)
+  0.00      5.18     0.00  2810254     0.00     0.00  short_to_float(short)
+  0.00      5.18     0.00       12     0.00     0.00  print_id(char*)
+  0.00      5.18     0.00       10     0.00     0.00  int_from_buffer(char*)
+  0.00      5.18     0.00        5     0.00     0.00  fwriteIntLSB(int, _IO_FILE*)
+  0.00      5.18     0.00        3     0.00     0.00  print_file_data(wav_file)
+  0.00      5.18     0.00        2     0.00     0.00  exit_if_invalid(char*)
+  0.00      5.18     0.00        2     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.00      5.18     0.00        2     0.00     0.00  get_file_header(file_header&, _IO_FILE*)
+  0.00      5.18     0.00        2     0.00     0.01  read_file(char*)
+  0.00      5.18     0.00        1     0.00     0.00  create_wav(short*, int, wav_file)
+  0.00      5.18     0.00        1     0.00     0.00  next_power(unsigned int)
+  0.00      5.18     0.00        1     0.00     0.05  write_to_file(wav_file, char*)
+  0.00      5.18     0.00        1     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      5.18     0.00        1     0.00     0.00  write_file_header(file_header, _IO_FILE*)
+  0.00      5.18     0.00        1     0.00     0.00  multithread_multiply(double*, double*, double*, int)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.19% of 5.18 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     97.2    0.00    5.04                 main [1]
+                0.03    4.92       1/1           convolution(wav_file, wav_file) [2]
+                0.00    0.05       1/1           write_to_file(wav_file, char*) [7]
+                0.00    0.03       2/2           read_file(char*) [10]
+                0.00    0.00       3/3           print_file_data(wav_file) [27]
+                0.00    0.00       2/2           exit_if_invalid(char*) [28]
+-----------------------------------------------
+                0.03    4.92       1/1           main [1]
+[2]     95.7    0.03    4.92       1         convolution(wav_file, wav_file) [2]
+                0.01    4.91       1/1           fft_convolution(float*, int, float*, int, double*, int) [3]
+                0.01    0.00 2810253/2810253     double_to_short(double) [12]
+                0.00    0.00 2810347/2810347     std::abs(double) [21]
+                0.00    0.00 2810254/2810254     short_to_float(short) [23]
+                0.00    0.00       1/1           create_wav(short*, int, wav_file) [31]
+-----------------------------------------------
+                0.01    4.91       1/1           convolution(wav_file, wav_file) [2]
+[3]     95.0    0.01    4.91       1         fft_convolution(float*, int, float*, int, double*, int) [3]
+                4.79    0.00       3/3           four1(double*, int, int) [4]
+                0.12    0.00       2/2           zero_padding(float*, int, double*, int) [6]
+                0.00    0.00       1/1           next_power(unsigned int) [32]
+                0.00    0.00       1/1           multithread_multiply(double*, double*, double*, int) [34]
+-----------------------------------------------
+                4.79    0.00       3/3           fft_convolution(float*, int, float*, int, double*, int) [3]
+[4]     92.5    4.79    0.00       3         four1(double*, int, int) [4]
+-----------------------------------------------
+                                                 <spontaneous>
+[5]      2.7    0.14    0.00                 complex_multiply(void*) [5]
+-----------------------------------------------
+                0.12    0.00       2/2           fft_convolution(float*, int, float*, int, double*, int) [3]
+[6]      2.3    0.12    0.00       2         zero_padding(float*, int, double*, int) [6]
+-----------------------------------------------
+                0.00    0.05       1/1           main [1]
+[7]      1.0    0.00    0.05       1         write_to_file(wav_file, char*) [7]
+                0.03    0.02       1/1           write_file_data(file_data, _IO_FILE*, int) [8]
+                0.00    0.00       1/1           write_file_format(file_fmt, _IO_FILE*) [14]
+                0.00    0.00       1/1           write_file_header(file_header, _IO_FILE*) [33]
+-----------------------------------------------
+                0.03    0.02       1/1           write_to_file(wav_file, char*) [7]
+[8]      1.0    0.03    0.02       1         write_file_data(file_data, _IO_FILE*, int) [8]
+                0.02    0.00 2810253/2810257     fwriteShortLSB(short, _IO_FILE*) [11]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.03    0.00       2/2           read_file(char*) [10]
+[9]      0.6    0.03    0.00       2         get_file_data(file_data&, _IO_FILE*, int) [9]
+                0.00    0.00 2810254/2810262     short_from_buffer(char*) [22]
+                0.00    0.00       2/10          int_from_buffer(char*) [25]
+-----------------------------------------------
+                0.00    0.03       2/2           main [1]
+[10]     0.6    0.00    0.03       2         read_file(char*) [10]
+                0.03    0.00       2/2           get_file_data(file_data&, _IO_FILE*, int) [9]
+                0.00    0.00       2/2           get_file_header(file_header&, _IO_FILE*) [30]
+                0.00    0.00       2/2           get_file_format(file_fmt&, _IO_FILE*) [29]
+-----------------------------------------------
+                0.00    0.00       4/2810257     write_file_format(file_fmt, _IO_FILE*) [14]
+                0.02    0.00 2810253/2810257     write_file_data(file_data, _IO_FILE*, int) [8]
+[11]     0.4    0.02    0.00 2810257         fwriteShortLSB(short, _IO_FILE*) [11]
+-----------------------------------------------
+                0.01    0.00 2810253/2810253     convolution(wav_file, wav_file) [2]
+[12]     0.1    0.01    0.00 2810253         double_to_short(double) [12]
+-----------------------------------------------
+                                                 <spontaneous>
+[13]     0.1    0.01    0.00                 std::rint(float) [13]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [7]
+[14]     0.0    0.00    0.00       1         write_file_format(file_fmt, _IO_FILE*) [14]
+                0.00    0.00       4/2810257     fwriteShortLSB(short, _IO_FILE*) [11]
+                0.00    0.00       3/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00 2810347/2810347     convolution(wav_file, wav_file) [2]
+[21]     0.0    0.00    0.00 2810347         std::abs(double) [21]
+-----------------------------------------------
+                0.00    0.00       8/2810262     get_file_format(file_fmt&, _IO_FILE*) [29]
+                0.00    0.00 2810254/2810262     get_file_data(file_data&, _IO_FILE*, int) [9]
+[22]     0.0    0.00    0.00 2810262         short_from_buffer(char*) [22]
+-----------------------------------------------
+                0.00    0.00 2810254/2810254     convolution(wav_file, wav_file) [2]
+[23]     0.0    0.00    0.00 2810254         short_to_float(short) [23]
+-----------------------------------------------
+                0.00    0.00      12/12          print_file_data(wav_file) [27]
+[24]     0.0    0.00    0.00      12         print_id(char*) [24]
+-----------------------------------------------
+                0.00    0.00       2/10          get_file_header(file_header&, _IO_FILE*) [30]
+                0.00    0.00       2/10          get_file_data(file_data&, _IO_FILE*, int) [9]
+                0.00    0.00       6/10          get_file_format(file_fmt&, _IO_FILE*) [29]
+[25]     0.0    0.00    0.00      10         int_from_buffer(char*) [25]
+-----------------------------------------------
+                0.00    0.00       1/5           write_file_header(file_header, _IO_FILE*) [33]
+                0.00    0.00       1/5           write_file_data(file_data, _IO_FILE*, int) [8]
+                0.00    0.00       3/5           write_file_format(file_fmt, _IO_FILE*) [14]
+[26]     0.0    0.00    0.00       5         fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00       3/3           main [1]
+[27]     0.0    0.00    0.00       3         print_file_data(wav_file) [27]
+                0.00    0.00      12/12          print_id(char*) [24]
+-----------------------------------------------
+                0.00    0.00       2/2           main [1]
+[28]     0.0    0.00    0.00       2         exit_if_invalid(char*) [28]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [10]
+[29]     0.0    0.00    0.00       2         get_file_format(file_fmt&, _IO_FILE*) [29]
+                0.00    0.00       8/2810262     short_from_buffer(char*) [22]
+                0.00    0.00       6/10          int_from_buffer(char*) [25]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [10]
+[30]     0.0    0.00    0.00       2         get_file_header(file_header&, _IO_FILE*) [30]
+                0.00    0.00       2/10          int_from_buffer(char*) [25]
+-----------------------------------------------
+                0.00    0.00       1/1           convolution(wav_file, wav_file) [2]
+[31]     0.0    0.00    0.00       1         create_wav(short*, int, wav_file) [31]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, double*, int) [3]
+[32]     0.0    0.00    0.00       1         next_power(unsigned int) [32]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [7]
+[33]     0.0    0.00    0.00       1         write_file_header(file_header, _IO_FILE*) [33]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [26]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, double*, int) [3]
+[34]     0.0    0.00    0.00       1         multithread_multiply(double*, double*, double*, int) [34]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+  [31] create_wav(short*, int, wav_file) [12] double_to_short(double) [22] short_from_buffer(char*)
+  [32] next_power(unsigned int) [28] exit_if_invalid(char*) [14] write_file_format(file_fmt, _IO_FILE*)
+   [2] convolution(wav_file, wav_file) [3] fft_convolution(float*, int, float*, int, double*, int) [33] write_file_header(file_header, _IO_FILE*)
+  [26] fwriteIntLSB(int, _IO_FILE*) [29] get_file_format(file_fmt&, _IO_FILE*) [34] multithread_multiply(double*, double*, double*, int)
+   [6] zero_padding(float*, int, double*, int) [30] get_file_header(file_header&, _IO_FILE*) [4] four1(double*, int, int)
+   [9] get_file_data(file_data&, _IO_FILE*, int) [25] int_from_buffer(char*) [24] print_id(char*)
+   [7] write_to_file(wav_file, char*) [27] print_file_data(wav_file) [10] read_file(char*)
+  [11] fwriteShortLSB(short, _IO_FILE*) [8] write_file_data(file_data, _IO_FILE*, int) [21] std::abs(double)
+  [23] short_to_float(short)   [5] complex_multiply(void*) [13] std::rint(float)
diff --git a/profiling/guitar-manual-1.txt b/profiling/guitar-manual-1.txt
new file mode 100644
index 0000000..0a02e23
--- /dev/null
+++ b/profiling/guitar-manual-1.txt
@@ -0,0 +1,288 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls  ms/call  ms/call  name    
+ 93.30      2.09     2.09        3   696.67   696.67  four1(double*, int, int)
+  3.12      2.16     0.07                             complex_multiply(void*)
+  2.23      2.21     0.05        2    25.00    25.00  zero_padding(float*, int, double*, int)
+  0.89      2.23     0.02        1    20.00    20.00  convolution(wav_file, wav_file)
+  0.45      2.24     0.01        2     5.00     5.00  get_file_data(file_data&, _IO_FILE*, int)
+  0.00      2.24     0.00  1871546     0.00     0.00  std::abs(double)
+  0.00      2.24     0.00  1871492     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  0.00      2.24     0.00  1871489     0.00     0.00  exit_if_invalid(char*)
+  0.00      2.24     0.00  1871488     0.00     0.00  float_to_short(float)
+  0.00      2.24     0.00  1769480     0.00     0.00  short_from_buffer(char*)
+  0.00      2.24     0.00   102027     0.00     0.00  int_from_buffer(char*)
+  0.00      2.24     0.00       12     0.00   178.33  fft_convolution(float*, int, float*, int, double*, int)
+  0.00      2.24     0.00        5     0.00     0.00  fwriteIntLSB(int, _IO_FILE*)
+  0.00      2.24     0.00        3     0.00   178.33  print_id(char*)
+  0.00      2.24     0.00        2     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.00      2.24     0.00        2     0.00     0.00  get_file_header(file_header&, _IO_FILE*)
+  0.00      2.24     0.00        2     0.00   802.50  print_file_data(wav_file)
+  0.00      2.24     0.00        2     0.00     0.00  multithread_multiply(double*, double*, double*, int)
+  0.00      2.24     0.00        2     0.00     5.00  read_file(char*)
+  0.00      2.24     0.00        1     0.00     0.00  create_wav(short*, int, wav_file)
+  0.00      2.24     0.00        1     0.00     0.00  next_power(unsigned int)
+  0.00      2.24     0.00        1     0.00     0.00  write_to_file(wav_file, char*)
+  0.00      2.24     0.00        1     0.00     0.00  write_file_data(file_data, _IO_FILE*, int)
+  0.00      2.24     0.00        1     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      2.24     0.00        1     0.00     0.00  write_file_header(file_header, _IO_FILE*)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.45% of 2.24 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     96.9    0.00    2.17                 main [1]
+                0.00    1.60       2/2           print_file_data(wav_file) [4]
+                0.00    0.54       3/3           print_id(char*) [5]
+                0.02    0.00       1/1           convolution(wav_file, wav_file) [8]
+                0.00    0.01       2/2           read_file(char*) [10]
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [29]
+-----------------------------------------------
+                0.00    0.54       3/12          print_id(char*) [5]
+                0.00    1.60       9/12          print_file_data(wav_file) [4]
+[2]     95.5    0.00    2.14      12         fft_convolution(float*, int, float*, int, double*, int) [2]
+                2.09    0.00       3/3           four1(double*, int, int) [3]
+                0.05    0.00       2/2           zero_padding(float*, int, double*, int) [7]
+                0.00    0.00       1/1           next_power(unsigned int) [28]
+                0.00    0.00       1/2           multithread_multiply(double*, double*, double*, int) [26]
+-----------------------------------------------
+                2.09    0.00       3/3           fft_convolution(float*, int, float*, int, double*, int) [2]
+[3]     93.3    2.09    0.00       3         four1(double*, int, int) [3]
+-----------------------------------------------
+                0.00    1.60       2/2           main [1]
+[4]     71.7    0.00    1.60       2         print_file_data(wav_file) [4]
+                0.00    1.60       9/12          fft_convolution(float*, int, float*, int, double*, int) [2]
+-----------------------------------------------
+                0.00    0.54       3/3           main [1]
+[5]     23.9    0.00    0.54       3         print_id(char*) [5]
+                0.00    0.54       3/12          fft_convolution(float*, int, float*, int, double*, int) [2]
+-----------------------------------------------
+                                                 <spontaneous>
+[6]      3.1    0.07    0.00                 complex_multiply(void*) [6]
+-----------------------------------------------
+                0.05    0.00       2/2           fft_convolution(float*, int, float*, int, double*, int) [2]
+[7]      2.2    0.05    0.00       2         zero_padding(float*, int, double*, int) [7]
+-----------------------------------------------
+                0.02    0.00       1/1           main [1]
+[8]      0.9    0.02    0.00       1         convolution(wav_file, wav_file) [8]
+                0.00    0.00 1871546/1871546     std::abs(double) [17]
+                0.00    0.00 1871489/1871489     exit_if_invalid(char*) [19]
+                0.00    0.00 1871488/1871488     float_to_short(float) [20]
+                0.00    0.00       1/2           multithread_multiply(double*, double*, double*, int) [26]
+                0.00    0.00       1/1           create_wav(short*, int, wav_file) [27]
+-----------------------------------------------
+                0.01    0.00       2/2           read_file(char*) [10]
+[9]      0.4    0.01    0.00       2         get_file_data(file_data&, _IO_FILE*, int) [9]
+                0.00    0.00 1769472/1769480     short_from_buffer(char*) [21]
+                0.00    0.00  102019/102027      int_from_buffer(char*) [22]
+-----------------------------------------------
+                0.00    0.01       2/2           main [1]
+[10]     0.4    0.00    0.01       2         read_file(char*) [10]
+                0.01    0.00       2/2           get_file_data(file_data&, _IO_FILE*, int) [9]
+                0.00    0.00       2/2           get_file_header(file_header&, _IO_FILE*) [25]
+                0.00    0.00       2/2           get_file_format(file_fmt&, _IO_FILE*) [24]
+-----------------------------------------------
+                0.00    0.00 1871546/1871546     convolution(wav_file, wav_file) [8]
+[17]     0.0    0.00    0.00 1871546         std::abs(double) [17]
+-----------------------------------------------
+                0.00    0.00       4/1871492     write_file_format(file_fmt, _IO_FILE*) [31]
+                0.00    0.00 1871488/1871492     write_file_data(file_data, _IO_FILE*, int) [30]
+[18]     0.0    0.00    0.00 1871492         fwriteShortLSB(short, _IO_FILE*) [18]
+-----------------------------------------------
+                0.00    0.00 1871489/1871489     convolution(wav_file, wav_file) [8]
+[19]     0.0    0.00    0.00 1871489         exit_if_invalid(char*) [19]
+-----------------------------------------------
+                0.00    0.00 1871488/1871488     convolution(wav_file, wav_file) [8]
+[20]     0.0    0.00    0.00 1871488         float_to_short(float) [20]
+-----------------------------------------------
+                0.00    0.00       8/1769480     get_file_format(file_fmt&, _IO_FILE*) [24]
+                0.00    0.00 1769472/1769480     get_file_data(file_data&, _IO_FILE*, int) [9]
+[21]     0.0    0.00    0.00 1769480         short_from_buffer(char*) [21]
+-----------------------------------------------
+                0.00    0.00       2/102027      get_file_header(file_header&, _IO_FILE*) [25]
+                0.00    0.00       6/102027      get_file_format(file_fmt&, _IO_FILE*) [24]
+                0.00    0.00  102019/102027      get_file_data(file_data&, _IO_FILE*, int) [9]
+[22]     0.0    0.00    0.00  102027         int_from_buffer(char*) [22]
+-----------------------------------------------
+                0.00    0.00       1/5           write_file_header(file_header, _IO_FILE*) [32]
+                0.00    0.00       1/5           write_file_data(file_data, _IO_FILE*, int) [30]
+                0.00    0.00       3/5           write_file_format(file_fmt, _IO_FILE*) [31]
+[23]     0.0    0.00    0.00       5         fwriteIntLSB(int, _IO_FILE*) [23]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [10]
+[24]     0.0    0.00    0.00       2         get_file_format(file_fmt&, _IO_FILE*) [24]
+                0.00    0.00       8/1769480     short_from_buffer(char*) [21]
+                0.00    0.00       6/102027      int_from_buffer(char*) [22]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [10]
+[25]     0.0    0.00    0.00       2         get_file_header(file_header&, _IO_FILE*) [25]
+                0.00    0.00       2/102027      int_from_buffer(char*) [22]
+-----------------------------------------------
+                0.00    0.00       1/2           convolution(wav_file, wav_file) [8]
+                0.00    0.00       1/2           fft_convolution(float*, int, float*, int, double*, int) [2]
+[26]     0.0    0.00    0.00       2         multithread_multiply(double*, double*, double*, int) [26]
+-----------------------------------------------
+                0.00    0.00       1/1           convolution(wav_file, wav_file) [8]
+[27]     0.0    0.00    0.00       1         create_wav(short*, int, wav_file) [27]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, double*, int) [2]
+[28]     0.0    0.00    0.00       1         next_power(unsigned int) [28]
+-----------------------------------------------
+                0.00    0.00       1/1           main [1]
+[29]     0.0    0.00    0.00       1         write_to_file(wav_file, char*) [29]
+                0.00    0.00       1/1           write_file_header(file_header, _IO_FILE*) [32]
+                0.00    0.00       1/1           write_file_format(file_fmt, _IO_FILE*) [31]
+                0.00    0.00       1/1           write_file_data(file_data, _IO_FILE*, int) [30]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [29]
+[30]     0.0    0.00    0.00       1         write_file_data(file_data, _IO_FILE*, int) [30]
+                0.00    0.00 1871488/1871492     fwriteShortLSB(short, _IO_FILE*) [18]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [23]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [29]
+[31]     0.0    0.00    0.00       1         write_file_format(file_fmt, _IO_FILE*) [31]
+                0.00    0.00       4/1871492     fwriteShortLSB(short, _IO_FILE*) [18]
+                0.00    0.00       3/5           fwriteIntLSB(int, _IO_FILE*) [23]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [29]
+[32]     0.0    0.00    0.00       1         write_file_header(file_header, _IO_FILE*) [32]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [23]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+  [27] create_wav(short*, int, wav_file) [19] exit_if_invalid(char*) [31] write_file_format(file_fmt, _IO_FILE*)
+  [28] next_power(unsigned int) [2] fft_convolution(float*, int, float*, int, double*, int) [32] write_file_header(file_header, _IO_FILE*)
+   [8] convolution(wav_file, wav_file) [24] get_file_format(file_fmt&, _IO_FILE*) [26] multithread_multiply(double*, double*, double*, int)
+  [23] fwriteIntLSB(int, _IO_FILE*) [25] get_file_header(file_header&, _IO_FILE*) [3] four1(double*, int, int)
+   [7] zero_padding(float*, int, double*, int) [22] int_from_buffer(char*) [5] print_id(char*)
+   [9] get_file_data(file_data&, _IO_FILE*, int) [4] print_file_data(wav_file) [10] read_file(char*)
+  [29] write_to_file(wav_file, char*) [30] write_file_data(file_data, _IO_FILE*, int) [17] std::abs(double)
+  [20] float_to_short(float)   [6] complex_multiply(void*)
+  [18] fwriteShortLSB(short, _IO_FILE*) [21] short_from_buffer(char*)
diff --git a/profiling/guitar-manual-2.out b/profiling/guitar-manual-2.out
new file mode 100644
index 0000000..d3dba77
Binary files /dev/null and b/profiling/guitar-manual-2.out differ
diff --git a/profiling/guitar-manual-2.txt b/profiling/guitar-manual-2.txt
new file mode 100644
index 0000000..1caeb05
--- /dev/null
+++ b/profiling/guitar-manual-2.txt
@@ -0,0 +1,289 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 90.82      1.88     1.88        3     0.63     0.63  four1(double*, int, int)
+  4.83      1.98     0.10                             complex_multiply(void*)
+  1.93      2.02     0.04        2     0.02     0.02  zero_padding(float*, int, double*, int)
+  1.45      2.05     0.03        1     0.03     1.96  convolution(wav_file, wav_file)
+  0.48      2.06     0.01  1871492     0.00     0.00  fwriteShortLSB(short, _IO_FILE*)
+  0.48      2.07     0.01        1     0.01     1.93  fft_convolution(float*, int, float*, int, double*, int)
+  0.00      2.07     0.00  1871540     0.00     0.00  std::abs(double)
+  0.00      2.07     0.00  1871489     0.00     0.00  short_to_float(short)
+  0.00      2.07     0.00  1871488     0.00     0.00  double_to_short(double)
+  0.00      2.07     0.00  1769480     0.00     0.00  short_from_buffer(char*)
+  0.00      2.07     0.00   102027     0.00     0.00  int_from_buffer(char*)
+  0.00      2.07     0.00       12     0.00     0.00  print_id(char*)
+  0.00      2.07     0.00        5     0.00     0.00  fwriteIntLSB(int, _IO_FILE*)
+  0.00      2.07     0.00        3     0.00     0.00  print_file_data(wav_file)
+  0.00      2.07     0.00        2     0.00     0.00  get_file_data(file_data&, _IO_FILE*, int)
+  0.00      2.07     0.00        2     0.00     0.00  exit_if_invalid(char*)
+  0.00      2.07     0.00        2     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.00      2.07     0.00        2     0.00     0.00  get_file_header(file_header&, _IO_FILE*)
+  0.00      2.07     0.00        2     0.00     0.00  read_file(char*)
+  0.00      2.07     0.00        1     0.00     0.00  create_wav(short*, int, wav_file)
+  0.00      2.07     0.00        1     0.00     0.00  next_power(unsigned int)
+  0.00      2.07     0.00        1     0.00     0.01  write_to_file(wav_file, char*)
+  0.00      2.07     0.00        1     0.00     0.01  write_file_data(file_data, _IO_FILE*, int)
+  0.00      2.07     0.00        1     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      2.07     0.00        1     0.00     0.00  write_file_header(file_header, _IO_FILE*)
+  0.00      2.07     0.00        1     0.00     0.00  multithread_multiply(double*, double*, double*, int)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.48% of 2.07 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     95.2    0.00    1.97                 main [1]
+                0.03    1.93       1/1           convolution(wav_file, wav_file) [2]
+                0.00    0.01       1/1           write_to_file(wav_file, char*) [8]
+                0.00    0.00       3/3           print_file_data(wav_file) [24]
+                0.00    0.00       2/2           exit_if_invalid(char*) [26]
+                0.00    0.00       2/2           read_file(char*) [29]
+-----------------------------------------------
+                0.03    1.93       1/1           main [1]
+[2]     94.7    0.03    1.93       1         convolution(wav_file, wav_file) [2]
+                0.01    1.92       1/1           fft_convolution(float*, int, float*, int, double*, int) [3]
+                0.00    0.00 1871540/1871540     std::abs(double) [17]
+                0.00    0.00 1871489/1871489     short_to_float(short) [18]
+                0.00    0.00 1871488/1871488     double_to_short(double) [19]
+                0.00    0.00       1/1           create_wav(short*, int, wav_file) [30]
+-----------------------------------------------
+                0.01    1.92       1/1           convolution(wav_file, wav_file) [2]
+[3]     93.2    0.01    1.92       1         fft_convolution(float*, int, float*, int, double*, int) [3]
+                1.88    0.00       3/3           four1(double*, int, int) [4]
+                0.04    0.00       2/2           zero_padding(float*, int, double*, int) [6]
+                0.00    0.00       1/1           next_power(unsigned int) [31]
+                0.00    0.00       1/1           multithread_multiply(double*, double*, double*, int) [33]
+-----------------------------------------------
+                1.88    0.00       3/3           fft_convolution(float*, int, float*, int, double*, int) [3]
+[4]     90.8    1.88    0.00       3         four1(double*, int, int) [4]
+-----------------------------------------------
+                                                 <spontaneous>
+[5]      4.8    0.10    0.00                 complex_multiply(void*) [5]
+-----------------------------------------------
+                0.04    0.00       2/2           fft_convolution(float*, int, float*, int, double*, int) [3]
+[6]      1.9    0.04    0.00       2         zero_padding(float*, int, double*, int) [6]
+-----------------------------------------------
+                0.00    0.00       4/1871492     write_file_format(file_fmt, _IO_FILE*) [10]
+                0.01    0.00 1871488/1871492     write_file_data(file_data, _IO_FILE*, int) [9]
+[7]      0.5    0.01    0.00 1871492         fwriteShortLSB(short, _IO_FILE*) [7]
+-----------------------------------------------
+                0.00    0.01       1/1           main [1]
+[8]      0.5    0.00    0.01       1         write_to_file(wav_file, char*) [8]
+                0.00    0.01       1/1           write_file_data(file_data, _IO_FILE*, int) [9]
+                0.00    0.00       1/1           write_file_format(file_fmt, _IO_FILE*) [10]
+                0.00    0.00       1/1           write_file_header(file_header, _IO_FILE*) [32]
+-----------------------------------------------
+                0.00    0.01       1/1           write_to_file(wav_file, char*) [8]
+[9]      0.5    0.00    0.01       1         write_file_data(file_data, _IO_FILE*, int) [9]
+                0.01    0.00 1871488/1871492     fwriteShortLSB(short, _IO_FILE*) [7]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [23]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [8]
+[10]     0.0    0.00    0.00       1         write_file_format(file_fmt, _IO_FILE*) [10]
+                0.00    0.00       4/1871492     fwriteShortLSB(short, _IO_FILE*) [7]
+                0.00    0.00       3/5           fwriteIntLSB(int, _IO_FILE*) [23]
+-----------------------------------------------
+                0.00    0.00 1871540/1871540     convolution(wav_file, wav_file) [2]
+[17]     0.0    0.00    0.00 1871540         std::abs(double) [17]
+-----------------------------------------------
+                0.00    0.00 1871489/1871489     convolution(wav_file, wav_file) [2]
+[18]     0.0    0.00    0.00 1871489         short_to_float(short) [18]
+-----------------------------------------------
+                0.00    0.00 1871488/1871488     convolution(wav_file, wav_file) [2]
+[19]     0.0    0.00    0.00 1871488         double_to_short(double) [19]
+-----------------------------------------------
+                0.00    0.00       8/1769480     get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00 1769472/1769480     get_file_data(file_data&, _IO_FILE*, int) [25]
+[20]     0.0    0.00    0.00 1769480         short_from_buffer(char*) [20]
+-----------------------------------------------
+                0.00    0.00       2/102027      get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       6/102027      get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00  102019/102027      get_file_data(file_data&, _IO_FILE*, int) [25]
+[21]     0.0    0.00    0.00  102027         int_from_buffer(char*) [21]
+-----------------------------------------------
+                0.00    0.00      12/12          print_file_data(wav_file) [24]
+[22]     0.0    0.00    0.00      12         print_id(char*) [22]
+-----------------------------------------------
+                0.00    0.00       1/5           write_file_header(file_header, _IO_FILE*) [32]
+                0.00    0.00       1/5           write_file_data(file_data, _IO_FILE*, int) [9]
+                0.00    0.00       3/5           write_file_format(file_fmt, _IO_FILE*) [10]
+[23]     0.0    0.00    0.00       5         fwriteIntLSB(int, _IO_FILE*) [23]
+-----------------------------------------------
+                0.00    0.00       3/3           main [1]
+[24]     0.0    0.00    0.00       3         print_file_data(wav_file) [24]
+                0.00    0.00      12/12          print_id(char*) [22]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [29]
+[25]     0.0    0.00    0.00       2         get_file_data(file_data&, _IO_FILE*, int) [25]
+                0.00    0.00 1769472/1769480     short_from_buffer(char*) [20]
+                0.00    0.00  102019/102027      int_from_buffer(char*) [21]
+-----------------------------------------------
+                0.00    0.00       2/2           main [1]
+[26]     0.0    0.00    0.00       2         exit_if_invalid(char*) [26]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [29]
+[27]     0.0    0.00    0.00       2         get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00       8/1769480     short_from_buffer(char*) [20]
+                0.00    0.00       6/102027      int_from_buffer(char*) [21]
+-----------------------------------------------
+                0.00    0.00       2/2           read_file(char*) [29]
+[28]     0.0    0.00    0.00       2         get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       2/102027      int_from_buffer(char*) [21]
+-----------------------------------------------
+                0.00    0.00       2/2           main [1]
+[29]     0.0    0.00    0.00       2         read_file(char*) [29]
+                0.00    0.00       2/2           get_file_header(file_header&, _IO_FILE*) [28]
+                0.00    0.00       2/2           get_file_format(file_fmt&, _IO_FILE*) [27]
+                0.00    0.00       2/2           get_file_data(file_data&, _IO_FILE*, int) [25]
+-----------------------------------------------
+                0.00    0.00       1/1           convolution(wav_file, wav_file) [2]
+[30]     0.0    0.00    0.00       1         create_wav(short*, int, wav_file) [30]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, double*, int) [3]
+[31]     0.0    0.00    0.00       1         next_power(unsigned int) [31]
+-----------------------------------------------
+                0.00    0.00       1/1           write_to_file(wav_file, char*) [8]
+[32]     0.0    0.00    0.00       1         write_file_header(file_header, _IO_FILE*) [32]
+                0.00    0.00       1/5           fwriteIntLSB(int, _IO_FILE*) [23]
+-----------------------------------------------
+                0.00    0.00       1/1           fft_convolution(float*, int, float*, int, double*, int) [3]
+[33]     0.0    0.00    0.00       1         multithread_multiply(double*, double*, double*, int) [33]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+  [30] create_wav(short*, int, wav_file) [19] double_to_short(double) [20] short_from_buffer(char*)
+  [31] next_power(unsigned int) [26] exit_if_invalid(char*) [10] write_file_format(file_fmt, _IO_FILE*)
+   [2] convolution(wav_file, wav_file) [3] fft_convolution(float*, int, float*, int, double*, int) [32] write_file_header(file_header, _IO_FILE*)
+  [23] fwriteIntLSB(int, _IO_FILE*) [27] get_file_format(file_fmt&, _IO_FILE*) [33] multithread_multiply(double*, double*, double*, int)
+   [6] zero_padding(float*, int, double*, int) [28] get_file_header(file_header&, _IO_FILE*) [4] four1(double*, int, int)
+  [25] get_file_data(file_data&, _IO_FILE*, int) [21] int_from_buffer(char*) [22] print_id(char*)
+   [8] write_to_file(wav_file, char*) [24] print_file_data(wav_file) [29] read_file(char*)
+   [7] fwriteShortLSB(short, _IO_FILE*) [9] write_file_data(file_data, _IO_FILE*, int) [17] std::abs(double)
+  [18] short_to_float(short)   [5] complex_multiply(void*)
diff --git a/report.md b/report.md
index 58cf3d3..4b9c232 100644
--- a/report.md
+++ b/report.md
@@ -68,6 +68,8 @@ sys     0m0.075s
  - As this complex multiplication is done linearly on rather large inputs, it takes a long time. This can be multithreaded to do the full complex multiplication in parallel across many threads.
  - This code tuning creates a new struct to be used as a single parameter, instead of a list of parameters. It then delegates segments of the input arrays across several threads. Each of those threads process their segments of arrays and enters their result into their segment of the output.
 
+**Commit**: [ff275d26132e407ef5ddb82fb4d211b12c2e9d62](https://github.com/alexs2112/CPSC501-Convolution/commit/ff275d26132e407ef5ddb82fb4d211b12c2e9d62)
+
 **Code Changes**:
 ```c
 // Allow for 512 threads. This could realistically be larger as the input size is huge
@@ -141,3 +143,69 @@ sys     0m0.134s
  - This change added an additional test for complex multiplication.
  - This test also broke previous unit tests as multiplication does not happen if the number of threads is greater than the size of the input arrays. This has since been fixed.
  - Output files from manual regression tests on convolution are the same as before the change.
+
+### Manual Code Tuning #2:
+ - Zero padding and converting the input samples to complex arrays have been taking a relatively long time after previous optimizations. Some profiling taken from the result of the previous optimization:
+```
+>>> gprof convolve profiling/flute-manual-1.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 94.22      5.38     5.38        3     1.79     1.79  four1(double*, int, int)
+  1.75      5.48     0.10        2     0.05     0.05  zero_padding(float*, int, double*, int)
+
+>>> gprof convolve profiling/guitar-manual-1.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 93.30      2.09     2.09        3     0.70     0.70  four1(double*, int, int)
+  3.12      2.16     0.07                             complex_multiply(void*)
+  2.23      2.21     0.05        2     0.03     0.03  zero_padding(float*, int, double*, int)
+```
+ - This is because the `zero_padding` function iterates over the `output` array twice, first it zeroes the entire array, and then it copies values from the input array to it.
+ - This can be optimized by only going over the array once by zeroing the imaginary part of the array at the same time as copying values from the input array.
+    - *Note*: If the output array size is greater than twice the length of the input array then the remainder will still need to be zeroed. This is easy to accomplish by starting another `for` loop at the index of `2 * input_length + 1`.
+
+**Code Changes**:
+```c
+void zero_padding(float *signal, int input_size, double *output, int output_size) {
+    int i;
+    for (i = 0; i < input_size; i++) {
+        output[i*2] = (double)signal[i];
+        output[i*2 + 1] = 0.0;
+    }
+    for (i = input_size * 2 + 1; i < output_size; i++) {
+        output[i] = 0.0;
+    }
+}
+```
+
+**Run Time Performance**:
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/out.wav
+real    0m6.031s
+user    0m5.411s
+sys     0m0.215s
+>>> gprof convolve profiling/flute-manual-2.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 92.47      4.79     4.79        3     1.60     1.60  four1(double*, int, int)
+  2.70      4.93     0.14                             complex_multiply(void*)
+  2.32      5.05     0.12        2     0.06     0.06  zero_padding(float*, int, double*, int)
+```
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    0m2.611s
+user    0m2.244s
+sys     0m0.139s
+>>> gprof convolve profiling/guitar-manual-2.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 90.82      1.88     1.88        3     0.63     0.63  four1(double*, int, int)
+  4.83      1.98     0.10                             complex_multiply(void*)
+  1.93      2.02     0.04        2     0.02     0.02  zero_padding(float*, int, double*, int)
+```
+ - The time it takes for the program to complete has dropped by a reasonable amount.
+ - The relative time it takes for `zero_padding` to finish compared to the other functions of the program has also been dropped by a reasonable amount.
+
+**Regression Testing**:
+ - A minor bug with the `for` loop values was caught by the existing unit tests.
+ - Manual convolution testing is successful and has expected results.

commit 6f1ffcf1cad9e13e11b42228bda5e6291fbb678e
Author: alexs2112 <alexste2112@gmail.com>
Date:   Sun Dec 3 18:24:51 2023 -0700

    add regression testing section to report

diff --git a/report.md b/report.md
index a5699fc..58cf3d3 100644
--- a/report.md
+++ b/report.md
@@ -53,6 +53,9 @@ sys     0m0.075s
 >>> gprof convolve profiling/fft-guitar.out
 ```
 
+**Regression Testing**:
+ - Audio files produced from FFT convolution are the same as the ones produced by linear convolution.
+
 ### Manual Code Tuning #1:
  - The `complex_multiply` function very consistently takes the most time as a function call, taking 60% of the total processing time of the program. This is twice as much as the next largest function.
 ```
@@ -133,3 +136,8 @@ sys     0m0.134s
   2.23      2.21     0.05        2     0.03     0.03  zero_padding(float*, int, double*, int)
 ```
  - As you can see with the above profiling results, the new `complex_multiply` function takes a fraction of the time that it used to. 1.75-3% of the total program runtime instead of the previous result of 60%
+
+**Regression Testing**:
+ - This change added an additional test for complex multiplication.
+ - This test also broke previous unit tests as multiplication does not happen if the number of threads is greater than the size of the input arrays. This has since been fixed.
+ - Output files from manual regression tests on convolution are the same as before the change.

commit ff275d26132e407ef5ddb82fb4d211b12c2e9d62
Author: alexs2112 <alexste2112@gmail.com>
Date:   Sun Dec 3 18:14:07 2023 -0700

    manual tuning: parallelize complex multiplication

diff --git a/.gitignore b/.gitignore
index 9eb5f7f..f73ea79 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,5 +3,5 @@ provided/
 convolve
 test
 *.wav
-*.txt
+./*.txt
 gmon.out
diff --git a/headers/fast_fourier.h b/headers/fast_fourier.h
index e405cb4..6d58fa1 100644
--- a/headers/fast_fourier.h
+++ b/headers/fast_fourier.h
@@ -1 +1,2 @@
 void fft_convolution(float *x, int N, float *h, int M, double *y, int P);
+void *complex_multiply(void *v);
diff --git a/modules/fast_fourier.cpp b/modules/fast_fourier.cpp
index 7be5e55..0cb963e 100644
--- a/modules/fast_fourier.cpp
+++ b/modules/fast_fourier.cpp
@@ -1,12 +1,15 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <pthread.h> 
 
 #define SIZE        8
 #define PI          3.141592653589793
 #define TWO_PI      (2.0 * PI)
 #define SWAP(a, b)  tempr=(a);(a)=(b);(b)=tempr
 
+#define COMPLEX_THREADS     512
+
 // Replaces data[1..2*nn] by its discrete Fourier transform if isign is input as 1
 // or replaces data[1..2*nn] by nn times its inverse discrete Fourier transform if isign is input as -1
 // Params:
@@ -86,13 +89,47 @@ void zero_padding(float *signal, int input_size, double *output, int output_size
     }
 }
 
-void complex_multiply(double *x, double *h, double *output, int size) {
+/* Perform the complex multiplication on a segment of three arrays */
+struct complex_param {
+    double *x;
+    double *h;
+    double *output;
+    int size;
+};
+
+void *complex_multiply(void *v) {
     // Perform complex multiplication
-    for (int k = 0; k < size; k += 2) {
+    complex_param p = ((complex_param *)v)[0];
+    for (int k = 0; k < p.size; k += 2) {
         // Re Y[k] = Re X[k] Re H[k] - Im X[k] Im H[k]
         // Im Y[k] = Im X[k] Re H[k] + Re X[k] Im H[k]
-        output[k] = x[k] * h[k] - x[k+1] * h[k+1];
-        output[k+1] = x[k+1] * h[k] + x[k] * h[k+1];
+        p.output[k] = p.x[k] * p.h[k] - p.x[k+1] * p.h[k+1];
+        p.output[k+1] = p.x[k+1] * p.h[k] + p.x[k] * p.h[k+1];
+    }
+    return 0;
+}
+
+/* Perform complex multiplication in several threads for performance */
+void multithread_multiply(double *x, double *h, double *output, int size) {
+    int num_threads;
+    if (size < 4 * COMPLEX_THREADS)
+        num_threads = 1;
+    else
+        num_threads = COMPLEX_THREADS;
+
+    pthread_t ids[num_threads];
+    int chunk = size / num_threads;
+    int i;
+    for (i = 0; i < num_threads; i++) {
+        complex_param p;
+        p.x = &x[i * chunk];
+        p.h = &h[i * chunk];
+        p.output = &output[i * chunk];
+        p.size = chunk;
+        pthread_create(&ids[i], NULL, complex_multiply, (void *)&p);
+    }
+    for (i = 0; i < num_threads; i++) {
+        pthread_join(ids[i], NULL);
     }
 }
 
@@ -117,7 +154,7 @@ void fft_convolution(float *x, int N, float *h, int M, double *y, int P) {
     four1(padded_x - 1, padded_size, 1);
     four1(padded_h - 1, padded_size, 1);
 
-    complex_multiply(padded_x, padded_h, padded_out, 2 * padded_size);
+    multithread_multiply(padded_x, padded_h, padded_out, 2*padded_size);
 
     four1(padded_out - 1, padded_size, -1);
 
diff --git a/profiling/fft-flute.txt b/profiling/fft-flute.txt
new file mode 100644
index 0000000..ced4e6a
--- /dev/null
+++ b/profiling/fft-flute.txt
@@ -0,0 +1,302 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 59.93      4.92     4.92                             complex_multiply(double*, double*, double*, int)
+ 30.21      7.40     2.48        2     1.24     1.24  fft_convolution(float*, int, float*, int, double*, int)
+  8.04      8.06     0.66                             zero_padding(float*, int, double*, int)
+  0.37      8.09     0.03                             write_file_data(file_data, _IO_FILE*, int)
+  0.24      8.11     0.02        4     0.01     0.01  four1(double*, int, int)
+  0.24      8.13     0.02        2     0.01     0.01  convolution(wav_file, wav_file)
+  0.24      8.15     0.02                             get_file_header(file_header&, _IO_FILE*)
+  0.12      8.16     0.01  2810272     0.00     0.00  get_file_data(file_data&, _IO_FILE*, int)
+  0.12      8.17     0.01  2810257     0.00     0.00  linear_convolution(float*, int, float*, int, double*, int)
+  0.12      8.18     0.01  2810253     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.12      8.19     0.01        6     0.00     0.00  print_file_data(wav_file)
+  0.12      8.20     0.01                             _init
+  0.12      8.21     0.01                             etext
+  0.00      8.21     0.00  2810254     0.00     0.00  double_to_short(double)
+  0.00      8.21     0.00  2810253     0.00     0.00  _fini
+  0.00      8.21     0.00        2     0.00     0.00  write_to_file(wav_file, char*)
+  0.00      8.21     0.00        2     0.00     0.00  float_to_short(float)
+  0.00      8.21     0.00        2     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      8.21     0.00        2     0.00     0.00  read_file(char*)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.12% of 8.21 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     59.9    4.92    0.00                 complex_multiply(double*, double*, double*, int) [1]
+-----------------------------------------------
+                                   3             fft_convolution(float*, int, float*, int, double*, int) [2]
+                1.24    0.00       1/2           short_from_buffer(char*) [4]
+                1.24    0.00       1/2           print_id(char*) [3]
+[2]     30.2    2.48    0.00       2+3       fft_convolution(float*, int, float*, int, double*, int) [2]
+                                   3             fft_convolution(float*, int, float*, int, double*, int) [2]
+-----------------------------------------------
+                                                 <spontaneous>
+[3]     15.3    0.00    1.25                 print_id(char*) [3]
+                1.24    0.00       1/2           fft_convolution(float*, int, float*, int, double*, int) [2]
+                0.01    0.01       2/4           four1(double*, int, int) [8]
+-----------------------------------------------
+                                                 <spontaneous>
+[4]     15.1    0.00    1.24                 short_from_buffer(char*) [4]
+                1.24    0.00       1/2           fft_convolution(float*, int, float*, int, double*, int) [2]
+-----------------------------------------------
+                                                 <spontaneous>
+[5]      8.0    0.66    0.00                 zero_padding(float*, int, double*, int) [5]
+-----------------------------------------------
+                                                 <spontaneous>
+[6]      0.5    0.02    0.02                 get_file_header(file_header&, _IO_FILE*) [6]
+                0.01    0.01 2810253/2810253     get_file_format(file_fmt&, _IO_FILE*) [10]
+-----------------------------------------------
+                                                 <spontaneous>
+[7]      0.5    0.03    0.01                 write_file_data(file_data, _IO_FILE*, int) [7]
+                0.01    0.00 2810256/2810272     get_file_data(file_data&, _IO_FILE*, int) [14]
+-----------------------------------------------
+                                   1             four1(double*, int, int) [8]
+                0.00    0.00       1/4           print_file_data(wav_file) [11]
+                0.01    0.00       1/4           convolution(wav_file, wav_file) [9]
+                0.01    0.01       2/4           print_id(char*) [3]
+[8]      0.4    0.02    0.01       4+1       four1(double*, int, int) [8]
+                0.01    0.00 2810257/2810257     linear_convolution(float*, int, float*, int, double*, int) [15]
+                                   1             four1(double*, int, int) [8]
+-----------------------------------------------
+                0.01    0.00       1/2           frame_dummy [12]
+                0.01    0.00       1/2           get_file_format(file_fmt&, _IO_FILE*) [10]
+[9]      0.3    0.02    0.01       2         convolution(wav_file, wav_file) [9]
+                0.01    0.00       1/4           four1(double*, int, int) [8]
+                0.00    0.00 2810254/2810254     double_to_short(double) [31]
+-----------------------------------------------
+                                 101             get_file_format(file_fmt&, _IO_FILE*) [10]
+                0.01    0.01 2810253/2810253     get_file_header(file_header&, _IO_FILE*) [6]
+[10]     0.3    0.01    0.01 2810253+101     get_file_format(file_fmt&, _IO_FILE*) [10]
+                0.01    0.00       1/2           convolution(wav_file, wav_file) [9]
+                0.00    0.00 2810253/2810253     _fini [32]
+                                 101             get_file_format(file_fmt&, _IO_FILE*) [10]
+-----------------------------------------------
+                                   9             print_file_data(wav_file) [11]
+                0.00    0.00       1/6           _start [19]
+                0.00    0.00       1/6           deregister_tm_clones [20]
+                0.00    0.00       1/6           create_wav(short*, int, wav_file) [21]
+                0.01    0.00       3/6           float_to_short(float) [18]
+[11]     0.2    0.01    0.01       6+9       print_file_data(wav_file) [11]
+                0.00    0.00       1/4           four1(double*, int, int) [8]
+                                   9             print_file_data(wav_file) [11]
+-----------------------------------------------
+                                                 <spontaneous>
+[12]     0.2    0.00    0.01                 frame_dummy [12]
+                0.01    0.00       1/2           convolution(wav_file, wav_file) [9]
+-----------------------------------------------
+                                                 <spontaneous>
+[13]     0.1    0.01    0.00                 etext [13]
+-----------------------------------------------
+                                   2             get_file_data(file_data&, _IO_FILE*, int) [14]
+                0.00    0.00       2/2810272     fwriteIntLSB(int, _IO_FILE*) [26]
+                0.00    0.00       2/2810272     fwriteShortLSB(short, _IO_FILE*) [27]
+                0.00    0.00       2/2810272     write_file_format(file_fmt, _IO_FILE*) [25]
+                0.00    0.00       2/2810272     write_to_file(wav_file, char*) [22]
+                0.00    0.00       4/2810272     read_file(char*) [23]
+                0.00    0.00       4/2810272     write_file_header(file_header, _IO_FILE*) [24]
+                0.01    0.00 2810256/2810272     write_file_data(file_data, _IO_FILE*, int) [7]
+[14]     0.1    0.01    0.00 2810272+2       get_file_data(file_data&, _IO_FILE*, int) [14]
+                                   2             get_file_data(file_data&, _IO_FILE*, int) [14]
+-----------------------------------------------
+                                   7             linear_convolution(float*, int, float*, int, double*, int) [15]
+                0.01    0.00 2810257/2810257     four1(double*, int, int) [8]
+[15]     0.1    0.01    0.00 2810257+7       linear_convolution(float*, int, float*, int, double*, int) [15]
+                                   7             linear_convolution(float*, int, float*, int, double*, int) [15]
+-----------------------------------------------
+                                                 <spontaneous>
+[16]     0.1    0.01    0.00                 _init [16]
+-----------------------------------------------
+                                                 <spontaneous>
+[17]     0.1    0.00    0.01                 main [17]
+                0.00    0.01       2/2           float_to_short(float) [18]
+                0.00    0.00       1/2           write_to_file(wav_file, char*) [22]
+-----------------------------------------------
+                0.00    0.01       2/2           main [17]
+[18]     0.1    0.00    0.01       2         float_to_short(float) [18]
+                0.01    0.00       3/6           print_file_data(wav_file) [11]
+-----------------------------------------------
+                                                 <spontaneous>
+[19]     0.0    0.00    0.00                 _start [19]
+                0.00    0.00       1/6           print_file_data(wav_file) [11]
+                0.00    0.00       1/2           write_to_file(wav_file, char*) [22]
+-----------------------------------------------
+                                                 <spontaneous>
+[20]     0.0    0.00    0.00                 deregister_tm_clones [20]
+                0.00    0.00       1/6           print_file_data(wav_file) [11]
+-----------------------------------------------
+                                                 <spontaneous>
+[21]     0.0    0.00    0.00                 create_wav(short*, int, wav_file) [21]
+                0.00    0.00       1/6           print_file_data(wav_file) [11]
+-----------------------------------------------
+                0.00    0.00       1/2           main [17]
+                0.00    0.00       1/2           _start [19]
+[22]     0.0    0.00    0.00       2         write_to_file(wav_file, char*) [22]
+                0.00    0.00       2/2           read_file(char*) [23]
+                0.00    0.00       2/2810272     get_file_data(file_data&, _IO_FILE*, int) [14]
+                0.00    0.00       2/2           write_file_format(file_fmt, _IO_FILE*) [25]
+-----------------------------------------------
+                0.00    0.00       2/2           write_to_file(wav_file, char*) [22]
+[23]     0.0    0.00    0.00       2         read_file(char*) [23]
+                0.00    0.00       4/2810272     get_file_data(file_data&, _IO_FILE*, int) [14]
+-----------------------------------------------
+                                                 <spontaneous>
+[24]     0.0    0.00    0.00                 write_file_header(file_header, _IO_FILE*) [24]
+                0.00    0.00       4/2810272     get_file_data(file_data&, _IO_FILE*, int) [14]
+-----------------------------------------------
+                0.00    0.00       2/2           write_to_file(wav_file, char*) [22]
+[25]     0.0    0.00    0.00       2         write_file_format(file_fmt, _IO_FILE*) [25]
+                0.00    0.00       2/2810272     get_file_data(file_data&, _IO_FILE*, int) [14]
+-----------------------------------------------
+                                                 <spontaneous>
+[26]     0.0    0.00    0.00                 fwriteIntLSB(int, _IO_FILE*) [26]
+                0.00    0.00       2/2810272     get_file_data(file_data&, _IO_FILE*, int) [14]
+-----------------------------------------------
+                                                 <spontaneous>
+[27]     0.0    0.00    0.00                 fwriteShortLSB(short, _IO_FILE*) [27]
+                0.00    0.00       2/2810272     get_file_data(file_data&, _IO_FILE*, int) [14]
+-----------------------------------------------
+                0.00    0.00 2810254/2810254     convolution(wav_file, wav_file) [9]
+[31]     0.0    0.00    0.00 2810254         double_to_short(double) [31]
+-----------------------------------------------
+                0.00    0.00 2810253/2810253     get_file_format(file_fmt&, _IO_FILE*) [10]
+[32]     0.0    0.00    0.00 2810253         _fini [32]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+   [9] convolution(wav_file, wav_file) [10] get_file_format(file_fmt&, _IO_FILE*) [8] four1(double*, int, int)
+   [5] zero_padding(float*, int, double*, int) [6] get_file_header(file_header&, _IO_FILE*) [23] read_file(char*)
+  [14] get_file_data(file_data&, _IO_FILE*, int) [11] print_file_data(wav_file) [32] _fini
+  [22] write_to_file(wav_file, char*) [7] write_file_data(file_data, _IO_FILE*, int) [16] _init
+  [18] float_to_short(float)   [1] complex_multiply(double*, double*, double*, int) [13] etext
+  [31] double_to_short(double) [25] write_file_format(file_fmt, _IO_FILE*)
+   [2] fft_convolution(float*, int, float*, int, double*, int) [15] linear_convolution(float*, int, float*, int, double*, int)
diff --git a/profiling/fft-guitar.txt b/profiling/fft-guitar.txt
new file mode 100644
index 0000000..6880075
--- /dev/null
+++ b/profiling/fft-guitar.txt
@@ -0,0 +1,295 @@
+Flat profile:
+
+Each sample counts as 0.01 seconds.
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls  ms/call  ms/call  name    
+ 55.88      1.33     1.33                             complex_multiply(double*, double*, double*, int)
+ 31.93      2.09     0.76        2   380.00   380.00  fft_convolution(float*, int, float*, int, double*, int)
+  8.82      2.30     0.21                             zero_padding(float*, int, double*, int)
+  1.26      2.33     0.03        2    15.00    16.25  convolution(wav_file, wav_file)
+  0.42      2.34     0.01  1871507     0.00     0.00  get_file_data(file_data&, _IO_FILE*, int)
+  0.42      2.35     0.01  1871488     0.00     0.00  get_file_format(file_fmt&, _IO_FILE*)
+  0.42      2.36     0.01        6     1.67     2.08  print_file_data(wav_file)
+  0.42      2.37     0.01        4     2.50     2.50  four1(double*, int, int)
+  0.42      2.38     0.01                             etext
+  0.00      2.38     0.00  1871492     0.00     0.00  linear_convolution(float*, int, float*, int, double*, int)
+  0.00      2.38     0.00  1871489     0.00     0.00  double_to_short(double)
+  0.00      2.38     0.00  1871488     0.00     0.00  _fini
+  0.00      2.38     0.00        2     0.00     0.27  write_to_file(wav_file, char*)
+  0.00      2.38     0.00        2     0.00     3.12  float_to_short(float)
+  0.00      2.38     0.00        2     0.00     0.00  write_file_format(file_fmt, _IO_FILE*)
+  0.00      2.38     0.00        2     0.00     0.00  read_file(char*)
+
+ %         the percentage of the total running time of the
+time       program used by this function.
+
+cumulative a running sum of the number of seconds accounted
+ seconds   for by this function and those listed above it.
+
+ self      the number of seconds accounted for by this
+seconds    function alone.  This is the major sort for this
+           listing.
+
+calls      the number of times this function was invoked, if
+           this function is profiled, else blank.
+
+ self      the average number of milliseconds spent in this
+ms/call    function per call, if this function is profiled,
+	   else blank.
+
+ total     the average number of milliseconds spent in this
+ms/call    function and its descendents per call, if this
+	   function is profiled, else blank.
+
+name       the name of the function.  This is the minor sort
+           for this listing. The index shows the location of
+	   the function in the gprof listing. If the index is
+	   in parenthesis it shows where it would appear in
+	   the gprof listing if it were to be printed.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+		     Call graph (explanation follows)
+
+
+granularity: each sample hit covers 4 byte(s) for 0.42% of 2.38 seconds
+
+index % time    self  children    called     name
+                                                 <spontaneous>
+[1]     55.9    1.33    0.00                 complex_multiply(double*, double*, double*, int) [1]
+-----------------------------------------------
+                                   3             fft_convolution(float*, int, float*, int, double*, int) [2]
+                0.38    0.00       1/2           short_from_buffer(char*) [4]
+                0.38    0.00       1/2           print_id(char*) [3]
+[2]     31.9    0.76    0.00       2+3       fft_convolution(float*, int, float*, int, double*, int) [2]
+                                   3             fft_convolution(float*, int, float*, int, double*, int) [2]
+-----------------------------------------------
+                                                 <spontaneous>
+[3]     16.2    0.00    0.39                 print_id(char*) [3]
+                0.38    0.00       1/2           fft_convolution(float*, int, float*, int, double*, int) [2]
+                0.01    0.00       2/4           four1(double*, int, int) [13]
+-----------------------------------------------
+                                                 <spontaneous>
+[4]     16.0    0.00    0.38                 short_from_buffer(char*) [4]
+                0.38    0.00       1/2           fft_convolution(float*, int, float*, int, double*, int) [2]
+-----------------------------------------------
+                                                 <spontaneous>
+[5]      8.8    0.21    0.00                 zero_padding(float*, int, double*, int) [5]
+-----------------------------------------------
+                0.01    0.00       1/2           frame_dummy [9]
+                0.01    0.00       1/2           get_file_format(file_fmt&, _IO_FILE*) [7]
+[6]      1.4    0.03    0.00       2         convolution(wav_file, wav_file) [6]
+                0.00    0.00       1/4           four1(double*, int, int) [13]
+                0.00    0.00 1871489/1871489     double_to_short(double) [30]
+-----------------------------------------------
+                                  70             get_file_format(file_fmt&, _IO_FILE*) [7]
+                0.01    0.02 1871488/1871488     get_file_header(file_header&, _IO_FILE*) [8]
+[7]      1.1    0.01    0.02 1871488+70      get_file_format(file_fmt&, _IO_FILE*) [7]
+                0.01    0.00       1/2           convolution(wav_file, wav_file) [6]
+                0.00    0.00 1871488/1871488     _fini [31]
+                                  70             get_file_format(file_fmt&, _IO_FILE*) [7]
+-----------------------------------------------
+                                                 <spontaneous>
+[8]      1.1    0.00    0.03                 get_file_header(file_header&, _IO_FILE*) [8]
+                0.01    0.02 1871488/1871488     get_file_format(file_fmt&, _IO_FILE*) [7]
+-----------------------------------------------
+                                                 <spontaneous>
+[9]      0.7    0.00    0.02                 frame_dummy [9]
+                0.01    0.00       1/2           convolution(wav_file, wav_file) [6]
+-----------------------------------------------
+                                   9             print_file_data(wav_file) [10]
+                0.00    0.00       1/6           _start [17]
+                0.00    0.00       1/6           deregister_tm_clones [18]
+                0.00    0.00       1/6           create_wav(short*, int, wav_file) [19]
+                0.01    0.00       3/6           float_to_short(float) [16]
+[10]     0.5    0.01    0.00       6+9       print_file_data(wav_file) [10]
+                0.00    0.00       1/4           four1(double*, int, int) [13]
+                                   9             print_file_data(wav_file) [10]
+-----------------------------------------------
+                                                 <spontaneous>
+[11]     0.4    0.01    0.00                 etext [11]
+-----------------------------------------------
+                                   2             get_file_data(file_data&, _IO_FILE*, int) [12]
+                0.00    0.00       2/1871507     fwriteIntLSB(int, _IO_FILE*) [24]
+                0.00    0.00       2/1871507     fwriteShortLSB(short, _IO_FILE*) [25]
+                0.00    0.00       2/1871507     write_file_format(file_fmt, _IO_FILE*) [23]
+                0.00    0.00       4/1871507     read_file(char*) [21]
+                0.00    0.00       4/1871507     write_file_header(file_header, _IO_FILE*) [22]
+                0.00    0.00  102019/1871507     write_to_file(wav_file, char*) [20]
+                0.01    0.00 1769474/1871507     write_file_data(file_data, _IO_FILE*, int) [14]
+[12]     0.4    0.01    0.00 1871507+2       get_file_data(file_data&, _IO_FILE*, int) [12]
+                                   2             get_file_data(file_data&, _IO_FILE*, int) [12]
+-----------------------------------------------
+                                   1             four1(double*, int, int) [13]
+                0.00    0.00       1/4           print_file_data(wav_file) [10]
+                0.00    0.00       1/4           convolution(wav_file, wav_file) [6]
+                0.01    0.00       2/4           print_id(char*) [3]
+[13]     0.4    0.01    0.00       4+1       four1(double*, int, int) [13]
+                0.00    0.00 1871492/1871492     linear_convolution(float*, int, float*, int, double*, int) [29]
+                                   1             four1(double*, int, int) [13]
+-----------------------------------------------
+                                                 <spontaneous>
+[14]     0.4    0.00    0.01                 write_file_data(file_data, _IO_FILE*, int) [14]
+                0.01    0.00 1769474/1871507     get_file_data(file_data&, _IO_FILE*, int) [12]
+-----------------------------------------------
+                                                 <spontaneous>
+[15]     0.3    0.00    0.01                 main [15]
+                0.00    0.01       2/2           float_to_short(float) [16]
+                0.00    0.00       1/2           write_to_file(wav_file, char*) [20]
+-----------------------------------------------
+                0.00    0.01       2/2           main [15]
+[16]     0.3    0.00    0.01       2         float_to_short(float) [16]
+                0.01    0.00       3/6           print_file_data(wav_file) [10]
+-----------------------------------------------
+                                                 <spontaneous>
+[17]     0.1    0.00    0.00                 _start [17]
+                0.00    0.00       1/6           print_file_data(wav_file) [10]
+                0.00    0.00       1/2           write_to_file(wav_file, char*) [20]
+-----------------------------------------------
+                                                 <spontaneous>
+[18]     0.1    0.00    0.00                 deregister_tm_clones [18]
+                0.00    0.00       1/6           print_file_data(wav_file) [10]
+-----------------------------------------------
+                                                 <spontaneous>
+[19]     0.1    0.00    0.00                 create_wav(short*, int, wav_file) [19]
+                0.00    0.00       1/6           print_file_data(wav_file) [10]
+-----------------------------------------------
+                0.00    0.00       1/2           main [15]
+                0.00    0.00       1/2           _start [17]
+[20]     0.0    0.00    0.00       2         write_to_file(wav_file, char*) [20]
+                0.00    0.00  102019/1871507     get_file_data(file_data&, _IO_FILE*, int) [12]
+                0.00    0.00       2/2           read_file(char*) [21]
+                0.00    0.00       2/2           write_file_format(file_fmt, _IO_FILE*) [23]
+-----------------------------------------------
+                0.00    0.00       2/2           write_to_file(wav_file, char*) [20]
+[21]     0.0    0.00    0.00       2         read_file(char*) [21]
+                0.00    0.00       4/1871507     get_file_data(file_data&, _IO_FILE*, int) [12]
+-----------------------------------------------
+                                                 <spontaneous>
+[22]     0.0    0.00    0.00                 write_file_header(file_header, _IO_FILE*) [22]
+                0.00    0.00       4/1871507     get_file_data(file_data&, _IO_FILE*, int) [12]
+-----------------------------------------------
+                0.00    0.00       2/2           write_to_file(wav_file, char*) [20]
+[23]     0.0    0.00    0.00       2         write_file_format(file_fmt, _IO_FILE*) [23]
+                0.00    0.00       2/1871507     get_file_data(file_data&, _IO_FILE*, int) [12]
+-----------------------------------------------
+                                                 <spontaneous>
+[24]     0.0    0.00    0.00                 fwriteIntLSB(int, _IO_FILE*) [24]
+                0.00    0.00       2/1871507     get_file_data(file_data&, _IO_FILE*, int) [12]
+-----------------------------------------------
+                                                 <spontaneous>
+[25]     0.0    0.00    0.00                 fwriteShortLSB(short, _IO_FILE*) [25]
+                0.00    0.00       2/1871507     get_file_data(file_data&, _IO_FILE*, int) [12]
+-----------------------------------------------
+                                   7             linear_convolution(float*, int, float*, int, double*, int) [29]
+                0.00    0.00 1871492/1871492     four1(double*, int, int) [13]
+[29]     0.0    0.00    0.00 1871492+7       linear_convolution(float*, int, float*, int, double*, int) [29]
+                                   7             linear_convolution(float*, int, float*, int, double*, int) [29]
+-----------------------------------------------
+                0.00    0.00 1871489/1871489     convolution(wav_file, wav_file) [6]
+[30]     0.0    0.00    0.00 1871489         double_to_short(double) [30]
+-----------------------------------------------
+                0.00    0.00 1871488/1871488     get_file_format(file_fmt&, _IO_FILE*) [7]
+[31]     0.0    0.00    0.00 1871488         _fini [31]
+-----------------------------------------------
+
+ This table describes the call tree of the program, and was sorted by
+ the total amount of time spent in each function and its children.
+
+ Each entry in this table consists of several lines.  The line with the
+ index number at the left hand margin lists the current function.
+ The lines above it list the functions that called this function,
+ and the lines below it list the functions this one called.
+ This line lists:
+     index	A unique number given to each element of the table.
+		Index numbers are sorted numerically.
+		The index number is printed next to every function name so
+		it is easier to look up where the function is in the table.
+
+     % time	This is the percentage of the `total' time that was spent
+		in this function and its children.  Note that due to
+		different viewpoints, functions excluded by options, etc,
+		these numbers will NOT add up to 100%.
+
+     self	This is the total amount of time spent in this function.
+
+     children	This is the total amount of time propagated into this
+		function by its children.
+
+     called	This is the number of times the function was called.
+		If the function called itself recursively, the number
+		only includes non-recursive calls, and is followed by
+		a `+' and the number of recursive calls.
+
+     name	The name of the current function.  The index number is
+		printed after it.  If the function is a member of a
+		cycle, the cycle number is printed between the
+		function's name and the index number.
+
+
+ For the function's parents, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the function into this parent.
+
+     children	This is the amount of time that was propagated from
+		the function's children into this parent.
+
+     called	This is the number of times this parent called the
+		function `/' the total number of times the function
+		was called.  Recursive calls to the function are not
+		included in the number after the `/'.
+
+     name	This is the name of the parent.  The parent's index
+		number is printed after it.  If the parent is a
+		member of a cycle, the cycle number is printed between
+		the name and the index number.
+
+ If the parents of the function cannot be determined, the word
+ `<spontaneous>' is printed in the `name' field, and all the other
+ fields are blank.
+
+ For the function's children, the fields have the following meanings:
+
+     self	This is the amount of time that was propagated directly
+		from the child into the function.
+
+     children	This is the amount of time that was propagated from the
+		child's children to the function.
+
+     called	This is the number of times the function called
+		this child `/' the total number of times the child
+		was called.  Recursive calls by the child are not
+		listed in the number after the `/'.
+
+     name	This is the name of the child.  The child's index
+		number is printed after it.  If the child is a
+		member of a cycle, the cycle number is printed
+		between the name and the index number.
+
+ If there are any cycles (circles) in the call graph, there is an
+ entry for the cycle-as-a-whole.  This entry shows who called the
+ cycle (as parents) and the members of the cycle (as children.)
+ The `+' recursive calls entry shows the number of function calls that
+ were internal to the cycle, and the calls entry for each member shows,
+ for that member, how many times it was called from other members of
+ the cycle.
+
+Copyright (C) 2012-2022 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Index by function name
+
+   [6] convolution(wav_file, wav_file) [2] fft_convolution(float*, int, float*, int, double*, int) [13] four1(double*, int, int)
+   [5] zero_padding(float*, int, double*, int) [7] get_file_format(file_fmt&, _IO_FILE*) [21] read_file(char*)
+  [12] get_file_data(file_data&, _IO_FILE*, int) [10] print_file_data(wav_file) [31] _fini
+  [20] write_to_file(wav_file, char*) [1] complex_multiply(double*, double*, double*, int) [11] etext
+  [16] float_to_short(float)  [23] write_file_format(file_fmt, _IO_FILE*)
+  [30] double_to_short(double) [29] linear_convolution(float*, int, float*, int, double*, int)
diff --git a/profiling/flute-manual-1.out b/profiling/flute-manual-1.out
new file mode 100644
index 0000000..cf0231b
Binary files /dev/null and b/profiling/flute-manual-1.out differ
diff --git a/profiling/guitar-manual-1.out b/profiling/guitar-manual-1.out
new file mode 100644
index 0000000..7262021
Binary files /dev/null and b/profiling/guitar-manual-1.out differ
diff --git a/report.md b/report.md
index a20738a..a5699fc 100644
--- a/report.md
+++ b/report.md
@@ -17,7 +17,6 @@ Length of `tah_mahal.wav`: 3 seconds
 real    21m49.301s
 user    20m56.925s
 sys     0m0.710s
-
 >>> gprof convolve profiling/linear-flute.out
 ```
 
@@ -30,7 +29,6 @@ Length of `large_brite_hall.wav`: 2 seconds
 real    9m4.331s
 user    9m0.709s
 sys     0m0.154s
-
 >>> gprof convolve profiling/linear-guitar.out
 ```
 
@@ -45,7 +43,6 @@ sys     0m0.154s
 real    0m9.000s
 user    0m8.394s
 sys     0m0.130s
-
 >>> gprof convolve profiling/fft-flute.out
 ```
 ```
@@ -53,6 +50,86 @@ sys     0m0.130s
 real    0m2.947s
 user    0m2.562s
 sys     0m0.075s
-
 >>> gprof convolve profiling/fft-guitar.out
 ```
+
+### Manual Code Tuning #1:
+ - The `complex_multiply` function very consistently takes the most time as a function call, taking 60% of the total processing time of the program. This is twice as much as the next largest function.
+```
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 59.93      4.92     4.92                             complex_multiply(double*, double*, double*, int)
+ 30.21      7.40     2.48        2     1.24     1.24  fft_convolution(float*, int, float*, int, double*, int)
+  8.04      8.06     0.66                             zero_padding(float*, int, double*, int)
+```
+ - As this complex multiplication is done linearly on rather large inputs, it takes a long time. This can be multithreaded to do the full complex multiplication in parallel across many threads.
+ - This code tuning creates a new struct to be used as a single parameter, instead of a list of parameters. It then delegates segments of the input arrays across several threads. Each of those threads process their segments of arrays and enters their result into their segment of the output.
+
+**Code Changes**:
+```c
+// Allow for 512 threads. This could realistically be larger as the input size is huge
+#define COMPLEX_THREADS     512
+
+// Input struct
+struct complex_param {
+    double *x;
+    double *h;
+    double *output;
+    int size;
+};
+
+// Perform the complex multiplication on a delegated segment of input arrays
+void *complex_multiply(void *v) {
+    complex_param p = ((complex_param *)v)[0];
+    for (int k = 0; k < p.size; k += 2) {
+        p.output[k] = p.x[k] * p.h[k] - p.x[k+1] * p.h[k+1];
+        p.output[k+1] = p.x[k+1] * p.h[k] + p.x[k] * p.h[k+1];
+    }
+    return 0;
+}
+
+// Break the input arrays into several chunks, give each thread a chunk to process
+void multithread_multiply(double *x, double *h, double *output, int size) {
+    pthread_t ids[COMPLEX_THREADS];
+    int chunk = size / COMPLEX_THREADS;
+    int i;
+    for (i = 0; i < COMPLEX_THREADS; i++) {
+        complex_param p;
+        p.x = &x[i * chunk];
+        p.h = &h[i * chunk];
+        p.output = &output[i * chunk];
+        p.size = chunk;
+        pthread_create(&ids[i], NULL, complex_multiply, (void *)&p);
+    }
+    for (i = 0; i < COMPLEX_THREADS; i++) {
+        pthread_join(ids[i], NULL);
+    }
+}
+```
+
+**Run Time Performance**:
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/out.wav
+real    0m6.662s
+user    0m5.949s
+sys     0m0.192s
+>>> gprof convolve profiling/flute-manual-1.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 94.22      5.38     5.38        3     1.79     1.79  four1(double*, int, int)
+  1.75      5.48     0.10        2     0.05     0.05  zero_padding(float*, int, double*, int)
+  1.75      5.58     0.10                             complex_multiply(void*)
+```
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    0m2.812s
+user    0m2.397s
+sys     0m0.134s
+>>> gprof convolve profiling/guitar-manual-1.out
+  %   cumulative   self              self     total           
+ time   seconds   seconds    calls   s/call   s/call  name    
+ 93.30      2.09     2.09        3     0.70     0.70  four1(double*, int, int)
+  3.12      2.16     0.07                             complex_multiply(void*)
+  2.23      2.21     0.05        2     0.03     0.03  zero_padding(float*, int, double*, int)
+```
+ - As you can see with the above profiling results, the new `complex_multiply` function takes a fraction of the time that it used to. 1.75-3% of the total program runtime instead of the previous result of 60%
diff --git a/test.cpp b/test.cpp
index adf88a0..e098036 100644
--- a/test.cpp
+++ b/test.cpp
@@ -9,15 +9,17 @@
 #endif
 
 /* Test Definitions */
-#define NUM_TESTS   2
+#define NUM_TESTS   3
 int test_linear_convolution();
 int test_fft_convolution();
+int test_complex_multiplication();
 
 /* Main Function */
 int main(int argc, char* argv[]) {
     int (*tests[])() = {
         test_linear_convolution,
         test_fft_convolution,
+        test_complex_multiplication,
     };
 
     // Run each test loaded into tests
@@ -87,3 +89,35 @@ int test_fft_convolution() {
     }
     return 0;
 }
+
+// Copied from fast_fourier.cpp
+struct complex_param {
+    double *x;
+    double *h;
+    double *output;
+    int size;
+};
+
+int test_complex_multiplication() {
+    double x[] = { 1, 2, 3, 4 };
+    double h[] = { 8, 7, 6, 5 };
+    double o[4];
+
+    complex_param p;
+    p.x = &x[0];
+    p.h = &h[0];
+    p.output = &o[0];
+    p.size = 4;
+    complex_multiply((void *)&p);
+
+    double e[] = { -6.0, 23.0, -2.0, 39.0 };
+
+    for (int i = 0; i < 4; i++) {
+        if (o[i] != e[i]) {
+            printf("Error in complex multiplication.\n\tExpected: [%.1f, %.1f, %.1f, %.1f]\n\tActual: [%.1f, %.1f, %.1f, %.1f]\n",
+                e[0], e[1], e[2], e[3], o[0], o[1], o[2], o[3]);
+            return 1;
+        }
+    }
+    return 0;
+}
\ No newline at end of file

commit cb85c68e5bfa561d4d45ad585ceb290809e94d07
Author: alexs2112 <alexste2112@gmail.com>
Date:   Sun Dec 3 14:41:57 2023 -0700

    start on the report

diff --git a/README.md b/README.md
index df99208..59cd58d 100644
--- a/README.md
+++ b/README.md
@@ -3,15 +3,17 @@
 
 *Note*: The baseline program that implements linear convolution is stored in the [baseline branch](https://github.com/alexs2112/CPSC501-Convolution/tree/baseline) for historical purposes.
 
+A full report is available at [report.md](report.md).
+
 ### Timings:
-Linear convolution:
+Linear Convolution:
 ```
 >>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
 real    9m4.331s
 user    9m0.709s
 sys     0m0.154s
 
->>> gprof convolve linear-guitar.out
+>>> gprof convolve profiling/linear-guitar.out
 ```
 ```
 >>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/flute-mahal.wav
@@ -19,8 +21,33 @@ real    21m49.301s
 user    20m56.925s
 sys     0m0.710s
 
->>> gprof convolve linear-flute.out
+>>> gprof convolve profiling/linear-flute.out
+```
+
+FFT Convolution:
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/out.wav
+real    0m9.000s
+user    0m8.394s
+sys     0m0.130s
+
+>>> gprof convolve profiling/fft-flute.out
+```
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    0m2.947s
+user    0m2.562s
+sys     0m0.075s
+
+>>> gprof convolve profiling/fft-guitar.out
 ```
 
 ### Unit Testing:
 Unit tests are available through the `test.cpp` file. This can be compiled using `make test` and run as `./test`.
+```
+>>> ./test
+
+Test Run Complete.
+Tests Run: 2
+Test Failed: 0
+```
diff --git a/profiling/fft-flute.out b/profiling/fft-flute.out
new file mode 100644
index 0000000..c4b3941
Binary files /dev/null and b/profiling/fft-flute.out differ
diff --git a/profiling/fft-guitar.out b/profiling/fft-guitar.out
new file mode 100644
index 0000000..4f1c1c2
Binary files /dev/null and b/profiling/fft-guitar.out differ
diff --git a/linear-flute.out b/profiling/linear-flute.out
similarity index 100%
rename from linear-flute.out
rename to profiling/linear-flute.out
diff --git a/linear-guitar.out b/profiling/linear-guitar.out
similarity index 100%
rename from linear-guitar.out
rename to profiling/linear-guitar.out
diff --git a/report.md b/report.md
new file mode 100644
index 0000000..a20738a
--- /dev/null
+++ b/report.md
@@ -0,0 +1,58 @@
+# CPSC 501 - Assignment 4, Optimization
+Alex Stevenson - 30073617
+
+Github Repository: https://github.com/alexs2112/CPSC501-Convolution
+
+### Baseline Program
+ - Initial version where convolution is implemented directly on the time domain in a linear matter.
+ - The code for this version is stored in the [baseline branch](https://github.com/alexs2112/CPSC501-Convolution/tree/baseline) of the repository.
+
+**Run Time Performance**:
+
+Length of `FluteDry.wav`: 60 seconds
+
+Length of `tah_mahal.wav`: 3 seconds
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/out.wav
+real    21m49.301s
+user    20m56.925s
+sys     0m0.710s
+
+>>> gprof convolve profiling/linear-flute.out
+```
+
+Length of `GuitarDry.wav`: 30 seconds
+
+Length of `large_brite_hall.wav`: 2 seconds
+ - There are 2 channels for this wav file, however the baseline program still works by treating it as a single channel.
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    9m4.331s
+user    9m0.709s
+sys     0m0.154s
+
+>>> gprof convolve profiling/linear-guitar.out
+```
+
+### Algorithm Based Optimization:
+ - Utilizing the FFT algorithm to re-implement the convolution using the frequency domain.
+ - The code for this version before any further optimizations is stored in the [fft branch](https://github.com/alexs2112/CPSC501-Convolution/tree/fft) of the repository.
+ - As you can see with the base run time performance below, the algorithm based optimization increased speed of the program by 145 to 185 times.
+
+**Run Time Performance**:
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/out.wav
+real    0m9.000s
+user    0m8.394s
+sys     0m0.130s
+
+>>> gprof convolve profiling/fft-flute.out
+```
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    0m2.947s
+user    0m2.562s
+sys     0m0.075s
+
+>>> gprof convolve profiling/fft-guitar.out
+```

commit c830c2fa764b8228cb4f18ff4f2aa35902ef5d83
Author: alexs2112 <alexste2112@gmail.com>
Date:   Sun Dec 3 14:12:52 2023 -0700

    implement basic unit tests for regression

diff --git a/.gitignore b/.gitignore
index 175b509..9eb5f7f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,7 @@
 .vscode/
 provided/
 convolve
+test
 *.wav
 *.txt
 gmon.out
diff --git a/Makefile b/Makefile
index ca2431a..7975d14 100644
--- a/Makefile
+++ b/Makefile
@@ -1,2 +1,5 @@
 convolve: convolve.cpp
 	g++ -g -p -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
+
+test: test.cpp
+	g++ -g -o test test.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
diff --git a/README.md b/README.md
index 4fcad00..df99208 100644
--- a/README.md
+++ b/README.md
@@ -20,4 +20,7 @@ user    20m56.925s
 sys     0m0.710s
 
 >>> gprof convolve linear-flute.out
-```
\ No newline at end of file
+```
+
+### Unit Testing:
+Unit tests are available through the `test.cpp` file. This can be compiled using `make test` and run as `./test`.
diff --git a/convolve.cpp b/convolve.cpp
index 8c6f926..730094a 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -84,28 +84,6 @@ wav_file create_wav(short* samples, int num_samples, wav_file input) {
     return output;
 }
 
-/* Some conversion functions */
-float short_to_float(short i) {
-    float f;
-    if (i < 0) { f = ((float)i) / 32768.0f; }
-    else { f = ((float)i) / 32767.0f; }
-    return f;
-}
-
-short float_to_short(float i) {
-    short s;
-    if (i < 0) { s = rint(i * 32768.0f); }
-    else { s = rint(i * 32767.0f); }
-    return s;
-}
-
-short double_to_short(double i) {
-    short s;
-    if (i < 0) { s = rint(i * 32768.0); }
-    else { s = rint(i * 32767.0); }
-    return s;
-}
-
 /* Take the input and ir wav_files, format their data as floats and perform the convolution */
 wav_file convolution(wav_file input, wav_file ir) {
     int N = input.data.num_samples;
diff --git a/headers/misc.h b/headers/misc.h
index 1a01dae..d3b12da 100644
--- a/headers/misc.h
+++ b/headers/misc.h
@@ -5,3 +5,6 @@
 
 void print_file_data(wav_file wav);
 void exit_if_invalid(char* path);
+float short_to_float(short i);
+short float_to_short(float i);
+short double_to_short(double i);
diff --git a/modules/misc.cpp b/modules/misc.cpp
index 029ab39..706c226 100644
--- a/modules/misc.cpp
+++ b/modules/misc.cpp
@@ -1,5 +1,6 @@
 #include <stdio.h>
 #include <stdlib.h>
+#include <math.h>
 #include <sys/stat.h>
 #include "../headers/file_structs.h"
 
@@ -13,6 +14,7 @@ void print_id(char buf[]) {
     }
     printf("\n");
 }
+
 void print_file_data(wav_file wav) {
     printf("\tChunk ID: ");
     print_id(wav.header.chunk_id);
@@ -35,6 +37,7 @@ void print_file_data(wav_file wav) {
     printf("\tSubchunk Size: %d\n", wav.data.subchunk_size);
     printf("\tSample Count: %d\n", wav.data.num_samples);
 }
+
 void exit_if_invalid(char* path) {
     struct stat sb;
     if (stat(path, &sb) != 0) {
@@ -42,3 +45,25 @@ void exit_if_invalid(char* path) {
         exit(EXIT_FAILURE);
     }
 }
+
+/* Some conversion functions */
+float short_to_float(short i) {
+    float f;
+    if (i < 0) { f = ((float)i) / 32768.0f; }
+    else { f = ((float)i) / 32767.0f; }
+    return f;
+}
+
+short float_to_short(float i) {
+    short s;
+    if (i < 0) { s = rint(i * 32768.0f); }
+    else { s = rint(i * 32767.0f); }
+    return s;
+}
+
+short double_to_short(double i) {
+    short s;
+    if (i < 0) { s = rint(i * 32768.0); }
+    else { s = rint(i * 32767.0); }
+    return s;
+}
diff --git a/test.cpp b/test.cpp
new file mode 100644
index 0000000..adf88a0
--- /dev/null
+++ b/test.cpp
@@ -0,0 +1,89 @@
+#include <stdio.h>
+#include "headers/convolution.h"
+#include "headers/fast_fourier.h"
+#include "headers/misc.h"
+
+#ifndef FILE_STRUCTS_H
+#define FILE_STRUCTS_H
+#include "headers/file_structs.h"
+#endif
+
+/* Test Definitions */
+#define NUM_TESTS   2
+int test_linear_convolution();
+int test_fft_convolution();
+
+/* Main Function */
+int main(int argc, char* argv[]) {
+    int (*tests[])() = {
+        test_linear_convolution,
+        test_fft_convolution,
+    };
+
+    // Run each test loaded into tests
+    int res;
+    int failures = 0;
+    for (int i = 0; i < NUM_TESTS; i++) {
+        res = (*tests[i])();
+        if (res == 1) { failures++; }
+    }
+
+    printf("\nTest Run Complete.\nTests Run: %d\nTest Failed: %d\n", NUM_TESTS, failures);
+
+    return 0;
+}
+
+/* List of Test Functions */
+int test_linear_convolution() {
+    int N = 3;
+    float x[] = { 0.2, 0.3, 0.4 };
+    int M = 2;
+    float h[] = { 0.1, 0.2 };
+    int P = N + M + 1;
+    double y[P];
+    linear_convolution(x, N, h, M, y, P);
+
+    double expected[] = {
+        0.020000,
+        0.070000,
+        0.100000,
+        0.080000,
+        0.000000,
+        0.000000
+    };
+    for (int i = 0; i < P; i++) {
+        if ((int)(y[i]*100) != (int)(expected[i]*100)) {
+            printf("Expected array after linear convolution: [%.3f, %.3f, %.3f, %.3f, %.3f, %.3f]\tActual: [%.3f, %.3f, %.3f, %.3f, %.3f, %.3f]\n",
+                expected[0], expected[1], expected[2], expected[3], expected[4], expected[5],
+                y[0], y[1], y[2], y[3], y[4], y[5]);
+            return 1;
+        }
+    }
+    return 0;
+}
+
+int test_fft_convolution() {
+    int N = 3;
+    float x[] = { 0.2, 0.3, 0.4 };
+    int M = 2;
+    float h[] = { 0.1, 0.2 };
+    int P = N + M - 1;
+    double y[P];
+    fft_convolution(x, N, h, M, y, P);
+
+    double expected[] = {
+        0.026,
+        0.093,
+        0.133,
+        0.106
+    };
+    for (int i = 0; i < P; i++) {
+        if ((int)(y[i]*1000) != (int)(expected[i]*1000)) {
+            printf("Expected array after fft convolution: [%.3f, %.3f, %.3f, %.3f]\tActual: [%.3f, %.3f, %.3f, %.3f]\n",
+                expected[0], expected[1], expected[2], expected[3],
+                y[0], y[1], y[2], y[3]);
+            return 1;
+        }
+    }
+    return 0;
+}

commit 33ad90f578f4c5702f8a37b42621bc305ffd4a8e
Merge: 2732fb8 6a053f9
Author: Urist2112 <47425839+alexs2112@users.noreply.github.com>
Date:   Fri Dec 1 15:54:11 2023 -0700

    Merge pull request #1 from alexs2112/fft_convolve
    
    Implement FFT Convolution

commit 6a053f9015a4717a376a39b58ca66b64f768f34b
Author: alexs2112 <alexste2112@gmail.com>
Date:   Fri Dec 1 15:53:04 2023 -0700

    cleanup fast fourier convolution and main convolution function

diff --git a/convolve.cpp b/convolve.cpp
index 57e247a..8c6f926 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -1,5 +1,7 @@
 #include <stdio.h>
 #include <stdlib.h>
+#include <cstring>
+#include <math.h>
 
 #ifndef FILE_STRUCTS_H
 #define FILE_STRUCTS_H
@@ -14,6 +16,14 @@
 
 using namespace std;
 
+#define USE_FAST_FOURIER    60
+
+float short_to_float(short i);
+short float_to_short(float i);
+short double_to_short(double i);
+wav_file create_wav(short* samples, int num_samples, wav_file input);
+wav_file convolution(wav_file input, wav_file ir);
+
 /********
  * Main *
  ********/
@@ -33,7 +43,7 @@ int main(int argc, char* argv[]) {
     printf("\nIMPULSE RESPONSE:\n");
     print_file_data(ir);
 
-    wav_file output = convolve_files_but_fast(input, ir);
+    wav_file output = convolution(input, ir);
     printf("\nOUTPUT FILE:\n");
     print_file_data(output);
 
@@ -45,3 +55,105 @@ int main(int argc, char* argv[]) {
 
     return EXIT_SUCCESS;
 }
+
+/* Format and create the wav_file struct to be written to a file */
+wav_file create_wav(short* samples, int num_samples, wav_file input) {
+    wav_file output;
+
+    // fmt subchunk
+    strncpy(output.fmt.subchunk_id, "fmt ", 4);
+    output.fmt.subchunk_size = 16;
+    output.fmt.audio_format = 1;
+    output.fmt.num_channels = input.fmt.num_channels;
+    output.fmt.sample_rate = input.fmt.sample_rate;
+    output.fmt.byte_rate = input.fmt.byte_rate;
+    output.fmt.block_align = input.fmt.block_align;
+    output.fmt.bits_per_sample = input.fmt.bits_per_sample;
+
+    // data subchunk
+    strncpy(output.data.subchunk_id, "data", 4);
+    output.data.num_samples = num_samples;
+    output.data.samples = samples;
+    output.data.subchunk_size = num_samples * (output.fmt.num_channels) * (output.fmt.bits_per_sample)/8;
+
+    // header chunk
+    strncpy(output.header.chunk_id, "RIFF", 4);
+    strncpy(output.header.format, "WAVE", 4);
+    output.header.chunk_size = 4 + (8 + output.fmt.subchunk_size) + (8 + output.data.subchunk_size);
+
+    return output;
+}
+
+/* Some conversion functions */
+float short_to_float(short i) {
+    float f;
+    if (i < 0) { f = ((float)i) / 32768.0f; }
+    else { f = ((float)i) / 32767.0f; }
+    return f;
+}
+
+short float_to_short(float i) {
+    short s;
+    if (i < 0) { s = rint(i * 32768.0f); }
+    else { s = rint(i * 32767.0f); }
+    return s;
+}
+
+short double_to_short(double i) {
+    short s;
+    if (i < 0) { s = rint(i * 32768.0); }
+    else { s = rint(i * 32767.0); }
+    return s;
+}
+
+/* Take the input and ir wav_files, format their data as floats and perform the convolution */
+wav_file convolution(wav_file input, wav_file ir) {
+    int N = input.data.num_samples;
+    int M = ir.data.num_samples;
+    int P = N + M;
+    if (M > USE_FAST_FOURIER) { P--; }
+    else { P++; }
+    int i;
+
+    // Output samples after being converted back to floats
+    short *samples = (short *)malloc(P * input.fmt.block_align);
+
+    // x and h arrays are handled as decimals between -1.0 and 1.0
+    float *x = new float[N];
+    float *h = new float[M];
+    double *y = new double[P];
+
+    // Convert the stored sample values as floats from -1.0 to 1.0
+    for (i = 0; i < N; i++)
+        x[i] = short_to_float(input.data.samples[i]);
+    for (i = 0; i < M; i++)
+        h[i] = short_to_float(ir.data.samples[i]);
+    for (i = 0; i < P; i++)
+        y[i] = 0.0;
+
+    // Use FFT convolution when the size of M is greater than 60 samples, otherwise use linear convolution
+    if (M > 60) {
+        fft_convolution(x, N, h, M, y, P);
+    } else {
+        linear_convolution(x, N, h, M, y, P);
+    }
+
+    // The convolution can result in values > 1.0, make sure to scale them
+    double largest = 1.0;
+    for (i = 0; i < P; i++) {
+        if (abs(y[i]) > largest) { largest = abs(y[i]); }
+    }
+
+    // Convert the doubles now stored in y back into sample values
+    for (i = 0; i < P; i++) {
+        samples[i] = double_to_short(y[i] / largest);
+    }
+
+    // Clean up the allocated arrays
+    delete(x);
+    delete(h);
+    delete(y);
+
+    // Create the output wav file using the above data
+    return create_wav(samples, P, input);
+}
diff --git a/headers/convolution.h b/headers/convolution.h
index 0b0cd6b..e59ed30 100644
--- a/headers/convolution.h
+++ b/headers/convolution.h
@@ -1,6 +1 @@
-#ifndef FILE_STRUCTS_H
-#define FILE_STRUCTS_H
-#include "./file_structs.h"
-#endif
-
-wav_file convolve_files(wav_file input, wav_file ir);
+void linear_convolution(float* x, int N, float* h, int M, double* y, int P);
diff --git a/headers/fast_fourier.h b/headers/fast_fourier.h
index 39df948..e405cb4 100644
--- a/headers/fast_fourier.h
+++ b/headers/fast_fourier.h
@@ -1,10 +1 @@
-void fft_convolve(float *x, int N, float *h, int M, double *y, int P);
-
-/****************************
- * DELETE AFTER CLEANING UP *
- ****************************/
-#ifndef FILE_STRUCTS_H
-#define FILE_STRUCTS_H
-#include "./file_structs.h"
-#endif
-wav_file convolve_files_but_fast(wav_file input, wav_file ir);
+void fft_convolution(float *x, int N, float *h, int M, double *y, int P);
diff --git a/modules/convolution.cpp b/modules/convolution.cpp
index 94b2398..d0026e4 100644
--- a/modules/convolution.cpp
+++ b/modules/convolution.cpp
@@ -1,41 +1,5 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <cstring>
-#include "../headers/file_structs.h"
-
-/***************
- * Convolution *
- ***************/
-wav_file create_wav(short* samples, int num_samples, wav_file input) {
-    wav_file output;
-
-    // fmt subchunk
-    strncpy(output.fmt.subchunk_id, "fmt ", 4);
-    output.fmt.subchunk_size = 16;
-    output.fmt.audio_format = 1;
-    output.fmt.num_channels = input.fmt.num_channels;
-    output.fmt.sample_rate = input.fmt.sample_rate;
-    output.fmt.byte_rate = input.fmt.byte_rate;
-    output.fmt.block_align = input.fmt.block_align;
-    output.fmt.bits_per_sample = input.fmt.bits_per_sample;
-
-    // data subchunk
-    strncpy(output.data.subchunk_id, "data", 4);
-    output.data.num_samples = num_samples;
-    output.data.samples = samples;
-    output.data.subchunk_size = num_samples * (output.fmt.num_channels) * (output.fmt.bits_per_sample)/8;
-
-    // header chunk
-    strncpy(output.header.chunk_id, "RIFF", 4);
-    strncpy(output.header.format, "WAVE", 4);
-    output.header.chunk_size = 4 + (8 + output.fmt.subchunk_size) + (8 + output.data.subchunk_size);
-
-    return output;
-}
-
 /* Using a slightly modified version of the input-side algorithm presented in lecture */
-void convolve(float* x, int N, float* h, int M, float* y, int P) {
+void linear_convolution(float* x, int N, float* h, int M, double* y, int P) {
     int n, m;
 
 	// Clear output buffer y[]
@@ -47,67 +11,7 @@ void convolve(float* x, int N, float* h, int M, float* y, int P) {
 	for (n = 0; n < N; n++) {
 		// Inner Loop: process x[n] with each sample of h[n]
 		for (m = 0; m < M; m++) {
-			y[n+m] += x[n] * h[m];
+			y[n+m] += (double)(x[n] * h[m]);
 		}
 	}
 }
-
-/* Some conversion functions */
-float short_to_float(short i) {
-    float f;
-    if (i < 0) { f = ((float)i) / 32768.0f; }
-    else { f = ((float)i) / 32767.0f; }
-    return f;
-}
-
-short float_to_short(float i) {
-    short s;
-    if (i < 0) { s = rint(i * 32768.0f); }
-    else { s = rint(i * 32767.0f); }
-    return s;
-}
-
-/* Take the input and ir wav_files, format their data as floats and perform the convolution */
-wav_file convolve_files(wav_file input, wav_file ir) {
-    int N = input.data.num_samples;
-    int M = ir.data.num_samples;
-    int P = N + M + 1;
-
-    int f = sizeof(float);
-    float *x = (float *)malloc(N * f);
-    float *h = (float *)malloc(M * f);
-    float *y = (float *)malloc(P * f);
-
-    // Convert the stored sample values as floats from -1.0 to 1.0
-    int i;
-    for (i = 0; i < N; i++) {
-        x[i] = short_to_float(input.data.samples[i]);
-    }
-    for (i = 0; i < M; i++) {
-        h[i] = short_to_float(ir.data.samples[i]);
-    }
-
-    // Perform the convolution
-    convolve(x, N, h, M, y, P);
-
-    // The convolution can result in values > 1.0, make sure to scale them
-    float largest = 1.0;
-    for (i = 0; i < P; i++) {
-        if (abs(y[i]) > largest) { largest = abs(y[i]); }
-    }
-    printf("\nScaling output by %f\n\n", largest);
-
-    // Convert the floats now stored in y back into sample values
-    short *samples = (short *)malloc(P * input.fmt.block_align);
-    for (i = 0; i < P; i++) {
-        samples[i] = float_to_short(y[i] / largest);
-    }
-
-    // Clean up the float arrays
-    free(x);
-    free(h);
-    free(y);
-
-    // Create the output wav file using the above data
-    return create_wav(samples, P, input);
-}
diff --git a/modules/fast_fourier.cpp b/modules/fast_fourier.cpp
index 8d97e3e..7be5e55 100644
--- a/modules/fast_fourier.cpp
+++ b/modules/fast_fourier.cpp
@@ -104,7 +104,7 @@ void complex_multiply(double *x, double *h, double *output, int size) {
 //    M: length of h
 //    y: output signal samples, scaled to be between -1.0 and 1.0
 //    P: length of y, this should equal N + M - 1
-void fft_convolve(float *x, int N, float *h, int M, double *y, int P) {
+void fft_convolution(float *x, int N, float *h, int M, double *y, int P) {
     int padded_size = next_power(P);
 
     double* padded_x = new double[2 * padded_size];
@@ -128,97 +128,3 @@ void fft_convolve(float *x, int N, float *h, int M, double *y, int P) {
     delete(padded_h);
     delete(padded_out);
 }
-
-/***************************************************************************************************
- * EVERYTHING BELOW THIS LINE SHOULD BE DELETED AND STUFF SHOULD BE ORGANIZED BETTER ONCE IT WORKS *
- ***************************************************************************************************/
-#include "../headers/file_structs.h"
-#include <cstring>
-
-float short_to_float_pt2(short i) {
-    float f;
-    if (i < 0) { f = ((float)i) / 32768.0f; }
-    else { f = ((float)i) / 32767.0f; }
-    return f;
-}
-
-short double_to_short(double i) {
-    short s;
-    if (i < 0) { s = rint(i * 32768.0); }
-    else { s = rint(i * 32767.0); }
-    return s;
-}
-
-wav_file create_wav_pt2(short* samples, int num_samples, wav_file input) {
-    wav_file output;
-
-    // fmt subchunk
-    strncpy(output.fmt.subchunk_id, "fmt ", 4);
-    output.fmt.subchunk_size = 16;
-    output.fmt.audio_format = 1;
-    output.fmt.num_channels = input.fmt.num_channels;
-    output.fmt.sample_rate = input.fmt.sample_rate;
-    output.fmt.byte_rate = input.fmt.byte_rate;
-    output.fmt.block_align = input.fmt.block_align;
-    output.fmt.bits_per_sample = input.fmt.bits_per_sample;
-
-    // data subchunk
-    strncpy(output.data.subchunk_id, "data", 4);
-    output.data.num_samples = num_samples;
-    output.data.samples = samples;
-    output.data.subchunk_size = num_samples * (output.fmt.num_channels) * (output.fmt.bits_per_sample)/8;
-
-    // header chunk
-    strncpy(output.header.chunk_id, "RIFF", 4);
-    strncpy(output.header.format, "WAVE", 4);
-    output.header.chunk_size = 4 + (8 + output.fmt.subchunk_size) + (8 + output.data.subchunk_size);
-
-    return output;
-}
-
-wav_file convolve_files_but_fast(wav_file input, wav_file ir) {
-    int N = input.data.num_samples;
-    int M = ir.data.num_samples;
-    int P = N + M - 1;
-
-    int f = sizeof(float);
-    float *x = new float[N];
-    float *h = new float[M];
-    double *y = new double[P];
-
-    // Convert the stored sample values as floats from -1.0 to 1.0
-    int i;
-    for (i = 0; i < N; i++) {
-        x[i] = short_to_float_pt2(input.data.samples[i]);
-    }
-    for (i = 0; i < M; i++) {
-        h[i] = short_to_float_pt2(ir.data.samples[i]);
-    }
-    for (i = 0; i < P; i++) {
-        y[i] = 0.0;
-    }
-
-    // Perform the convolution
-    fft_convolve(x, N, h, M, y, P);
-
-    // The convolution can result in values > 1.0, make sure to scale them
-    float largest = 1.0;
-    for (i = 0; i < P; i++) {
-        if (abs(y[i]) > largest) { largest = abs(y[i]); }
-    }
-    printf("\nScaling output by %f\n\n", largest);
-
-    // Convert the floats now stored in y back into sample values
-    short *samples = (short *)malloc(P * input.fmt.block_align);
-    for (i = 0; i < P; i++) {
-        samples[i] = double_to_short(y[i] / largest);
-    }
-
-    // Clean up the float arrays
-    delete(x);
-    delete(h);
-    delete(y);
-
-    // Create the output wav file using the above data
-    return create_wav_pt2(samples, P, input);
-}
\ No newline at end of file

commit 4e8ee37052d9656c037b7be12e7734a58373a537
Author: alexs2112 <alexste2112@gmail.com>
Date:   Fri Dec 1 15:23:29 2023 -0700

    simplified fft convolution algorithm works

diff --git a/modules/fast_fourier.cpp b/modules/fast_fourier.cpp
index 3ab65d4..8d97e3e 100644
--- a/modules/fast_fourier.cpp
+++ b/modules/fast_fourier.cpp
@@ -61,48 +61,6 @@ void four1(double *data, int nn, int isign) {
     }
 }
 
-// Convert our float arrays into complex double arrays
-// Params:
-//     data: input floats read from the wav files
-//     data_len: length of the data array
-//     output: should be at least twice the length as the data array padded to a length of power of 2
-//     out_len: length of the output array
-void convert_to_complex(float data[], int data_len, double output[], int out_len) {
-    // Clear the output array
-    for (int i = 0; i < out_len; i++) {
-        output[i] = 0.0;
-    }
-
-    // As this is a real signal, the imaginary parts remain as 0
-    for (int i = 0; i < data_len; i++) {
-        output[i * 2] = (double)data[i];
-    }
-}
-
-// Perform a convolution on input segment array and ir array
-// input and ir should be complex arrays that have already gone through the four1 function
-// in_length should be the length of input and ir, this should be identical and a power of 2 * 2
-// output is the output buffer that is filled by the convolution
-// out_length is the size of the output buffer, it should be equal to (in_length * 2 - 1)
-// out_signals is the number of signals stored in the output buffer, this needs to be a power of 2
-void convolution(double input[], double ir[], int in_length, double output[], int out_length, int out_signals) {
-    // Clear the output buffer
-    int k;
-    for (k = 0; k < out_length; k++)
-        output[k] = 0.0;
-
-    // Perform complex multiplication
-    for (k = 0; k < in_length; k += 2) {
-        // Re Y[k] = Re X[k] Re H[k] - Im X[k] Im H[k]
-        // Im Y[k] = Im X[k] Re H[k] + Re X[k] Im H[k]
-        output[k] = input[k] * ir[k] - input[k+1] * ir[k+1];
-        output[k+1] = input[k+1] * ir[k] + input[k] * ir[k+1];
-    }
-
-    // Perform the IFFT
-    four1(output - 1, out_signals, -1);
-}
-
 // Determine the next highest power of 2 for an integer value
 // https://graphics.stanford.edu/%7Eseander/bithacks.html#RoundUpPowerOf2
 unsigned int next_power(unsigned int v) {
@@ -116,67 +74,60 @@ unsigned int next_power(unsigned int v) {
     return v;
 }
 
-// Break x into several chunks of length next_power(M*2)
-// Perform FFT convolution on each chunk of x and h
-// Use the Overlap Add method to stick those chunks together again to get y
+// Output size should be 2x the padded size to account for complex numbers
+void zero_padding(float *signal, int input_size, double *output, int output_size) {
+    int i;
+    for (i = 0; i < output_size; i++) {
+        output[i] = 0.0;
+    }
+
+    for (i = 0; i < input_size; i++) {
+        output[i*2] = (double)signal[i];
+    }
+}
+
+void complex_multiply(double *x, double *h, double *output, int size) {
+    // Perform complex multiplication
+    for (int k = 0; k < size; k += 2) {
+        // Re Y[k] = Re X[k] Re H[k] - Im X[k] Im H[k]
+        // Im Y[k] = Im X[k] Re H[k] + Re X[k] Im H[k]
+        output[k] = x[k] * h[k] - x[k+1] * h[k+1];
+        output[k+1] = x[k+1] * h[k] + x[k] * h[k+1];
+    }
+}
+
+// Perform convolution using the FFT algorithm
 // Params:
 //    x: input signal samples between -1.0 and 1.0
 //    N: length of x
 //    h: ir signal samples between -1.0 and 1.0
 //    M: length of h
 //    y: output signal samples, scaled to be between -1.0 and 1.0
-//    P: length of y, I think this should equal N + M - 1 (not sure about padding)
+//    P: length of y, this should equal N + M - 1
 void fft_convolve(float *x, int N, float *h, int M, double *y, int P) {
-    // Number of signals in a complex array, multiplied by 2 to avoid circular convolution
-    unsigned int carr_signals = next_power(2 * M);
-
-    // Number of values in a complex array as each signal makes 2 values
-    unsigned int carr_length = carr_signals * 2;
-
-    // Perform FFT on the IR signal
-    double *complex_h = (double *)malloc(carr_length * sizeof(double));
-    convert_to_complex(h, M, complex_h, carr_length);
-    four1(complex_h-1, M, 1);
-
-    // Break x[] into a bunch of segments of size (carr_signals / 2), perform convolution on each segment
-    unsigned int segment_signals = carr_signals / 2;
-    double *complex_x = (double *)malloc(carr_length * sizeof(double));
-    double *output = (double *)malloc(carr_length * sizeof(double) * 2 - sizeof(double));
-    int i, j;
-    unsigned int max = 0;
-    for (i = 0; i < N; i += segment_signals) {
-        // Perform FFT on the new segment
-        unsigned int signals;
-        if ((i + segment_signals) > N) {
-            // Truncate x if it would overflow the buffer
-            signals = N - i;
-        } else {
-            signals = segment_signals;
-        }
-        convert_to_complex(&x[i], signals, complex_x, carr_length);
-        four1(complex_x-1, signals, 1);
-
-        // Do complex multiplication of complex_x and complex_h, then do the IFFT
-        // Put the result into the output buffer
-        convolution(complex_x, complex_h, carr_length, output, carr_length * 2 - 1, carr_signals);
-
-        // Then overlap add the result back into y, assume that y is an empty array of doubles at the start
-        for (j = 0; j < carr_signals; j++) {
-            // Sometimes this overflows because our arrays are not correctly sized
-            if ((i + j) < P) {
-                y[i + j] += output[j * 2];
-            }
-        }
-    }
+    int padded_size = next_power(P);
 
-    for (i = 0; i < P; i++)
-        y[i] /= (double)N;
+    double* padded_x = new double[2 * padded_size];
+    double* padded_h = new double[2 * padded_size];
+    double* padded_out = new double[2 * padded_size];
 
-    free(complex_h);
-    free(complex_x);
-    free(output);
-}
+    zero_padding(x, N, padded_x, 2 * padded_size);
+    zero_padding(h, M, padded_h, 2 * padded_size);
 
+    four1(padded_x - 1, padded_size, 1);
+    four1(padded_h - 1, padded_size, 1);
+
+    complex_multiply(padded_x, padded_h, padded_out, 2 * padded_size);
+
+    four1(padded_out - 1, padded_size, -1);
+
+    for (int i = 0; i < P; i++)
+        y[i] = padded_out[i * 2] / (double)N;
+    
+    delete(padded_x);
+    delete(padded_h);
+    delete(padded_out);
+}
 
 /***************************************************************************************************
  * EVERYTHING BELOW THIS LINE SHOULD BE DELETED AND STUFF SHOULD BE ORGANIZED BETTER ONCE IT WORKS *
@@ -228,12 +179,12 @@ wav_file create_wav_pt2(short* samples, int num_samples, wav_file input) {
 wav_file convolve_files_but_fast(wav_file input, wav_file ir) {
     int N = input.data.num_samples;
     int M = ir.data.num_samples;
-    int P = N + M + 1;
+    int P = N + M - 1;
 
     int f = sizeof(float);
-    float *x = (float *)malloc(N * f);
-    float *h = (float *)malloc(M * f);
-    double *y = (double *)malloc(P * sizeof(double));
+    float *x = new float[N];
+    float *h = new float[M];
+    double *y = new double[P];
 
     // Convert the stored sample values as floats from -1.0 to 1.0
     int i;
@@ -264,9 +215,9 @@ wav_file convolve_files_but_fast(wav_file input, wav_file ir) {
     }
 
     // Clean up the float arrays
-    free(x);
-    free(h);
-    free(y);
+    delete(x);
+    delete(h);
+    delete(y);
 
     // Create the output wav file using the above data
     return create_wav_pt2(samples, P, input);

commit 15fe852ef05934b04c5b510170eecf63b38fcf30
Author: alexs2112 <alexste2112@gmail.com>
Date:   Fri Dec 1 13:39:01 2023 -0700

    mild improvements, still not correct

diff --git a/.gitignore b/.gitignore
index 41febad..175b509 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,4 @@ provided/
 convolve
 *.wav
 *.txt
+gmon.out
diff --git a/modules/fast_fourier.cpp b/modules/fast_fourier.cpp
index fb9d1fd..3ab65d4 100644
--- a/modules/fast_fourier.cpp
+++ b/modules/fast_fourier.cpp
@@ -142,7 +142,8 @@ void fft_convolve(float *x, int N, float *h, int M, double *y, int P) {
     unsigned int segment_signals = carr_signals / 2;
     double *complex_x = (double *)malloc(carr_length * sizeof(double));
     double *output = (double *)malloc(carr_length * sizeof(double) * 2 - sizeof(double));
-    int i;
+    int i, j;
+    unsigned int max = 0;
     for (i = 0; i < N; i += segment_signals) {
         // Perform FFT on the new segment
         unsigned int signals;
@@ -159,17 +160,20 @@ void fft_convolve(float *x, int N, float *h, int M, double *y, int P) {
         // Put the result into the output buffer
         convolution(complex_x, complex_h, carr_length, output, carr_length * 2 - 1, carr_signals);
 
-        // Then overlap add the result back into y, assume that y is an empty array of doubles at this point
-        for (int j = 0; j < carr_length; j++) {
-            y[i * segment_signals + j] += output[j];
+        // Then overlap add the result back into y, assume that y is an empty array of doubles at the start
+        for (j = 0; j < carr_signals; j++) {
+            // Sometimes this overflows because our arrays are not correctly sized
+            if ((i + j) < P) {
+                y[i + j] += output[j * 2];
+            }
         }
     }
 
-    printf("Free h\n");
+    for (i = 0; i < P; i++)
+        y[i] /= (double)N;
+
     free(complex_h);
-    printf("Free x\n");
     free(complex_x);
-    printf("Free out\n");
     free(output);
 }
 

commit 810afdc9c2bcd61f1597b3ecc5706fb8f6566210
Author: alexs2112 <alexste2112@gmail.com>
Date:   Fri Dec 1 12:49:05 2023 -0700

    FFT convolution without memory issues, doesn't work but doesn't crash

diff --git a/Makefile b/Makefile
index 4c5ab99..ca2431a 100644
--- a/Makefile
+++ b/Makefile
@@ -1,2 +1,2 @@
 convolve: convolve.cpp
-	g++ -g -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/misc.cpp
+	g++ -g -p -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/fast_fourier.cpp modules/misc.cpp
diff --git a/README.md b/README.md
index 4788858..4fcad00 100644
--- a/README.md
+++ b/README.md
@@ -2,3 +2,22 @@
 *Usage*: convolve <input_file> <IR_file> <output_file>
 
 *Note*: The baseline program that implements linear convolution is stored in the [baseline branch](https://github.com/alexs2112/CPSC501-Convolution/tree/baseline) for historical purposes.
+
+### Timings:
+Linear convolution:
+```
+>>> time ./convolve input/GuitarDry.wav ir/large_brite_hall.wav output/out.wav
+real    9m4.331s
+user    9m0.709s
+sys     0m0.154s
+
+>>> gprof convolve linear-guitar.out
+```
+```
+>>> time ./convolve input/FluteDry.wav ir/taj_mahal.wav output/flute-mahal.wav
+real    21m49.301s
+user    20m56.925s
+sys     0m0.710s
+
+>>> gprof convolve linear-flute.out
+```
\ No newline at end of file
diff --git a/convolve.cpp b/convolve.cpp
index 3730296..57e247a 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -9,6 +9,7 @@
 #include "headers/reader.h"
 #include "headers/writer.h"
 #include "headers/convolution.h"
+#include "headers/fast_fourier.h"
 #include "headers/misc.h"
 
 using namespace std;
@@ -32,7 +33,7 @@ int main(int argc, char* argv[]) {
     printf("\nIMPULSE RESPONSE:\n");
     print_file_data(ir);
 
-    wav_file output = convolve_files(input, ir);
+    wav_file output = convolve_files_but_fast(input, ir);
     printf("\nOUTPUT FILE:\n");
     print_file_data(output);
 
diff --git a/headers/fast_fourier.h b/headers/fast_fourier.h
new file mode 100644
index 0000000..39df948
--- /dev/null
+++ b/headers/fast_fourier.h
@@ -0,0 +1,10 @@
+void fft_convolve(float *x, int N, float *h, int M, double *y, int P);
+
+/****************************
+ * DELETE AFTER CLEANING UP *
+ ****************************/
+#ifndef FILE_STRUCTS_H
+#define FILE_STRUCTS_H
+#include "./file_structs.h"
+#endif
+wav_file convolve_files_but_fast(wav_file input, wav_file ir);
diff --git a/linear-flute.out b/linear-flute.out
new file mode 100644
index 0000000..6a94b67
Binary files /dev/null and b/linear-flute.out differ
diff --git a/linear-guitar.out b/linear-guitar.out
new file mode 100644
index 0000000..019cabd
Binary files /dev/null and b/linear-guitar.out differ
diff --git a/modules/fast_fourier.cpp b/modules/fast_fourier.cpp
new file mode 100644
index 0000000..fb9d1fd
--- /dev/null
+++ b/modules/fast_fourier.cpp
@@ -0,0 +1,269 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#define SIZE        8
+#define PI          3.141592653589793
+#define TWO_PI      (2.0 * PI)
+#define SWAP(a, b)  tempr=(a);(a)=(b);(b)=tempr
+
+// Replaces data[1..2*nn] by its discrete Fourier transform if isign is input as 1
+// or replaces data[1..2*nn] by nn times its inverse discrete Fourier transform if isign is input as -1
+// Params:
+//    data pointer to data array, this should be subtracted by 1 as our arrays are 0 aligned (ie. four1(data - 1, 1024, 1))
+//    nn must be a power of 2, it is the number of complex data points in data (ie. half the length of data)
+//    isign = +1 for FFT, -1 for IFFT
+void four1(double *data, int nn, int isign) {
+    unsigned long n, mmax, m, j, istep, i;
+    double wtemp, wr, wpr, wpi, wi, theta;
+    double tempr, tempi;
+
+    n = nn << 1;
+    j = 1;
+
+    for (i = 1; i < n; i += 2) {
+        if (j > i) {
+            SWAP(data[j], data[i]);
+            SWAP(data[j+1], data[i+1]);
+        }
+        m = nn;
+        while (m >= 2 && j > m) {
+            j -= m;
+            m >>= 1;
+        }
+        j += m;
+    }
+
+    mmax = 2;
+    while (n > mmax) {
+        istep = mmax << 1;
+        theta = isign * (TWO_PI / mmax);
+        wtemp = sin(0.5 * theta);
+        wpr = -2.0 * wtemp * wtemp;
+        wpi = sin(theta);
+        wr = 1.0;
+        wi = 0.0;
+
+        for (m = 1; m < mmax; m += 2) {
+            for (i = m; i <= n; i += istep) {
+                j =i + mmax;
+                tempr = wr * data[j] - wi * data[j+1];
+                tempi = wr * data[j+1] + wi * data[j];
+                data[j] = data[i] - tempr;
+                data[j+1] = data[i+1] - tempi;
+                data[i] += tempr;
+                data[i+1] += tempi;
+            }
+            wr = (wtemp = wr) * wpr - wi * wpi + wr;
+            wi = wi * wpr + wtemp * wpi + wi;
+        }
+        mmax = istep;
+    }
+}
+
+// Convert our float arrays into complex double arrays
+// Params:
+//     data: input floats read from the wav files
+//     data_len: length of the data array
+//     output: should be at least twice the length as the data array padded to a length of power of 2
+//     out_len: length of the output array
+void convert_to_complex(float data[], int data_len, double output[], int out_len) {
+    // Clear the output array
+    for (int i = 0; i < out_len; i++) {
+        output[i] = 0.0;
+    }
+
+    // As this is a real signal, the imaginary parts remain as 0
+    for (int i = 0; i < data_len; i++) {
+        output[i * 2] = (double)data[i];
+    }
+}
+
+// Perform a convolution on input segment array and ir array
+// input and ir should be complex arrays that have already gone through the four1 function
+// in_length should be the length of input and ir, this should be identical and a power of 2 * 2
+// output is the output buffer that is filled by the convolution
+// out_length is the size of the output buffer, it should be equal to (in_length * 2 - 1)
+// out_signals is the number of signals stored in the output buffer, this needs to be a power of 2
+void convolution(double input[], double ir[], int in_length, double output[], int out_length, int out_signals) {
+    // Clear the output buffer
+    int k;
+    for (k = 0; k < out_length; k++)
+        output[k] = 0.0;
+
+    // Perform complex multiplication
+    for (k = 0; k < in_length; k += 2) {
+        // Re Y[k] = Re X[k] Re H[k] - Im X[k] Im H[k]
+        // Im Y[k] = Im X[k] Re H[k] + Re X[k] Im H[k]
+        output[k] = input[k] * ir[k] - input[k+1] * ir[k+1];
+        output[k+1] = input[k+1] * ir[k] + input[k] * ir[k+1];
+    }
+
+    // Perform the IFFT
+    four1(output - 1, out_signals, -1);
+}
+
+// Determine the next highest power of 2 for an integer value
+// https://graphics.stanford.edu/%7Eseander/bithacks.html#RoundUpPowerOf2
+unsigned int next_power(unsigned int v) {
+    v--;
+    v |= v >> 1;
+    v |= v >> 2;
+    v |= v >> 4;
+    v |= v >> 8;
+    v |= v >> 16;
+    v++;
+    return v;
+}
+
+// Break x into several chunks of length next_power(M*2)
+// Perform FFT convolution on each chunk of x and h
+// Use the Overlap Add method to stick those chunks together again to get y
+// Params:
+//    x: input signal samples between -1.0 and 1.0
+//    N: length of x
+//    h: ir signal samples between -1.0 and 1.0
+//    M: length of h
+//    y: output signal samples, scaled to be between -1.0 and 1.0
+//    P: length of y, I think this should equal N + M - 1 (not sure about padding)
+void fft_convolve(float *x, int N, float *h, int M, double *y, int P) {
+    // Number of signals in a complex array, multiplied by 2 to avoid circular convolution
+    unsigned int carr_signals = next_power(2 * M);
+
+    // Number of values in a complex array as each signal makes 2 values
+    unsigned int carr_length = carr_signals * 2;
+
+    // Perform FFT on the IR signal
+    double *complex_h = (double *)malloc(carr_length * sizeof(double));
+    convert_to_complex(h, M, complex_h, carr_length);
+    four1(complex_h-1, M, 1);
+
+    // Break x[] into a bunch of segments of size (carr_signals / 2), perform convolution on each segment
+    unsigned int segment_signals = carr_signals / 2;
+    double *complex_x = (double *)malloc(carr_length * sizeof(double));
+    double *output = (double *)malloc(carr_length * sizeof(double) * 2 - sizeof(double));
+    int i;
+    for (i = 0; i < N; i += segment_signals) {
+        // Perform FFT on the new segment
+        unsigned int signals;
+        if ((i + segment_signals) > N) {
+            // Truncate x if it would overflow the buffer
+            signals = N - i;
+        } else {
+            signals = segment_signals;
+        }
+        convert_to_complex(&x[i], signals, complex_x, carr_length);
+        four1(complex_x-1, signals, 1);
+
+        // Do complex multiplication of complex_x and complex_h, then do the IFFT
+        // Put the result into the output buffer
+        convolution(complex_x, complex_h, carr_length, output, carr_length * 2 - 1, carr_signals);
+
+        // Then overlap add the result back into y, assume that y is an empty array of doubles at this point
+        for (int j = 0; j < carr_length; j++) {
+            y[i * segment_signals + j] += output[j];
+        }
+    }
+
+    printf("Free h\n");
+    free(complex_h);
+    printf("Free x\n");
+    free(complex_x);
+    printf("Free out\n");
+    free(output);
+}
+
+
+/***************************************************************************************************
+ * EVERYTHING BELOW THIS LINE SHOULD BE DELETED AND STUFF SHOULD BE ORGANIZED BETTER ONCE IT WORKS *
+ ***************************************************************************************************/
+#include "../headers/file_structs.h"
+#include <cstring>
+
+float short_to_float_pt2(short i) {
+    float f;
+    if (i < 0) { f = ((float)i) / 32768.0f; }
+    else { f = ((float)i) / 32767.0f; }
+    return f;
+}
+
+short double_to_short(double i) {
+    short s;
+    if (i < 0) { s = rint(i * 32768.0); }
+    else { s = rint(i * 32767.0); }
+    return s;
+}
+
+wav_file create_wav_pt2(short* samples, int num_samples, wav_file input) {
+    wav_file output;
+
+    // fmt subchunk
+    strncpy(output.fmt.subchunk_id, "fmt ", 4);
+    output.fmt.subchunk_size = 16;
+    output.fmt.audio_format = 1;
+    output.fmt.num_channels = input.fmt.num_channels;
+    output.fmt.sample_rate = input.fmt.sample_rate;
+    output.fmt.byte_rate = input.fmt.byte_rate;
+    output.fmt.block_align = input.fmt.block_align;
+    output.fmt.bits_per_sample = input.fmt.bits_per_sample;
+
+    // data subchunk
+    strncpy(output.data.subchunk_id, "data", 4);
+    output.data.num_samples = num_samples;
+    output.data.samples = samples;
+    output.data.subchunk_size = num_samples * (output.fmt.num_channels) * (output.fmt.bits_per_sample)/8;
+
+    // header chunk
+    strncpy(output.header.chunk_id, "RIFF", 4);
+    strncpy(output.header.format, "WAVE", 4);
+    output.header.chunk_size = 4 + (8 + output.fmt.subchunk_size) + (8 + output.data.subchunk_size);
+
+    return output;
+}
+
+wav_file convolve_files_but_fast(wav_file input, wav_file ir) {
+    int N = input.data.num_samples;
+    int M = ir.data.num_samples;
+    int P = N + M + 1;
+
+    int f = sizeof(float);
+    float *x = (float *)malloc(N * f);
+    float *h = (float *)malloc(M * f);
+    double *y = (double *)malloc(P * sizeof(double));
+
+    // Convert the stored sample values as floats from -1.0 to 1.0
+    int i;
+    for (i = 0; i < N; i++) {
+        x[i] = short_to_float_pt2(input.data.samples[i]);
+    }
+    for (i = 0; i < M; i++) {
+        h[i] = short_to_float_pt2(ir.data.samples[i]);
+    }
+    for (i = 0; i < P; i++) {
+        y[i] = 0.0;
+    }
+
+    // Perform the convolution
+    fft_convolve(x, N, h, M, y, P);
+
+    // The convolution can result in values > 1.0, make sure to scale them
+    float largest = 1.0;
+    for (i = 0; i < P; i++) {
+        if (abs(y[i]) > largest) { largest = abs(y[i]); }
+    }
+    printf("\nScaling output by %f\n\n", largest);
+
+    // Convert the floats now stored in y back into sample values
+    short *samples = (short *)malloc(P * input.fmt.block_align);
+    for (i = 0; i < P; i++) {
+        samples[i] = double_to_short(y[i] / largest);
+    }
+
+    // Clean up the float arrays
+    free(x);
+    free(h);
+    free(y);
+
+    // Create the output wav file using the above data
+    return create_wav_pt2(samples, P, input);
+}
\ No newline at end of file

commit 2732fb8888149cd98c0d57ab983d6bb4538506d0
Author: alexs2112 <alexste2112@gmail.com>
Date:   Tue Nov 28 16:44:18 2023 -0700

    break up convolve.cpp into several modules and headers

diff --git a/Makefile b/Makefile
index be27e52..4c5ab99 100644
--- a/Makefile
+++ b/Makefile
@@ -1,2 +1,2 @@
 convolve: convolve.cpp
-	g++ -g -o convolve convolve.cpp
+	g++ -g -o convolve convolve.cpp modules/reader.cpp modules/writer.cpp modules/convolution.cpp modules/misc.cpp
diff --git a/README.md b/README.md
index 57e54a4..4788858 100644
--- a/README.md
+++ b/README.md
@@ -1,2 +1,4 @@
 # CPSC 501 - Convolution
-Usage: convolve <input_file> <IR_file> <output_file>
+*Usage*: convolve <input_file> <IR_file> <output_file>
+
+*Note*: The baseline program that implements linear convolution is stored in the [baseline branch](https://github.com/alexs2112/CPSC501-Convolution/tree/baseline) for historical purposes.
diff --git a/convolve.cpp b/convolve.cpp
index 76cbe5d..3730296 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -1,360 +1,17 @@
 #include <stdio.h>
 #include <stdlib.h>
-#include <sys/stat.h>
-#include <math.h>
-#include <cstring>
 
-using namespace std;
-
-/* Some structs to store values for a given file*/
-struct file_header {
-    char    chunk_id[4];
-    int     chunk_size;
-    char    format[4];
-};
-
-struct file_fmt {
-    char    subchunk_id[4];
-    int     subchunk_size;
-    short   audio_format;
-    short   num_channels;
-    int     sample_rate;
-    int     byte_rate;
-    short   block_align;
-    short   bits_per_sample;
-};
-
-struct file_data {
-    char    subchunk_id[4];
-    int     subchunk_size;
-    int     num_samples;    // Not read from the file, just helpful to store here
-    short*  samples;
-};
-
-struct wav_file {
-    file_header header;
-    file_fmt fmt;
-    file_data data;
-};
-
-/*****************************************
- * Functions for reading from a wav file *
- *****************************************/
-/* Get an int from a byte buffer of size 4 */
-int int_from_buffer(char buf[]) {
-    int value =
-        ((buf[3] & 0xFF) << 24) |
-        ((buf[2] & 0xFF) << 16) |
-        ((buf[1] & 0xFF) << 8) |
-        (buf[0] & 0xFF);
-    return value;
-}
-
-/* Get a short from a byte buffer of size 2 */
-short short_from_buffer(char buf[]) {
-    short value =
-        ((buf[1] & 0xFF) << 8) |
-        (buf[0] & 0xFF);
-    return value;
-}
-
-/* Use file to fill out the provided header */
-void get_file_header(file_header &header, FILE* file) {
-    fread(&header.chunk_id, 4, 1, file);
-    
-    char size[4];
-    fread(&size, 4, 1, file);
-    header.chunk_size = int_from_buffer(size);
-
-    fread(&header.format, 4, 1, file);
-}
-
-/* Use file to fill out the provided format subchunk */
-void get_file_format(file_fmt &fmt, FILE *file) {
-    fread(fmt.subchunk_id, 4, 1, file);
-
-    char size[4];
-    fread(&size, 4, 1, file);
-    fmt.subchunk_size = int_from_buffer(size);
-
-    char audio_format[2];
-    fread(&audio_format, 2, 1, file);
-    fmt.audio_format = short_from_buffer(audio_format);
-
-    char num_channels[2];
-    fread(&num_channels, 2, 1, file);
-    fmt.num_channels = short_from_buffer(num_channels);
-
-    char sample_rate[4];
-    fread(&sample_rate, 4, 1, file);
-    fmt.sample_rate = int_from_buffer(sample_rate);
-
-    char byte_rate[4];
-    fread(&byte_rate, 4, 1, file);
-    fmt.byte_rate = int_from_buffer(byte_rate);
-
-    char block_align[2];
-    fread(&block_align, 2, 1, file);
-    fmt.block_align = short_from_buffer(block_align);
-
-    char bits_per_sample[2];
-    fread(&bits_per_sample, 2, 1, file);
-    fmt.bits_per_sample = short_from_buffer(bits_per_sample);
+#ifndef FILE_STRUCTS_H
+#define FILE_STRUCTS_H
+#include "headers/file_structs.h"
+#endif
 
-    if (fmt.subchunk_size > 16) {
-        // Sometimes the fmt of the ir's have a subchunk size that is randomly too big
-        // Throw those away
-        int l = fmt.subchunk_size - 16;
-        char garbage[l];
-        fread(&garbage, l, 1, file);
-    }
-}
-
-/* Use file to fill out the provided data subchunk */
-void get_file_data(file_data &data, FILE* file, int sample_size) {
-    fread(&data.subchunk_id, 4, 1, file);
-
-    char size[4];
-    fread(&size, 4, 1, file);
-    data.subchunk_size = int_from_buffer(size);
-
-    int num_samples = data.subchunk_size / sample_size;
-    data.num_samples = num_samples;
-    data.samples = (short *)malloc(data.subchunk_size);
-    for (int i = 0; i < num_samples; i++) {
-        char value[sample_size];
-        fread(&value, sample_size, 1, file);
-        if (sample_size==2) {
-            data.samples[i] = short_from_buffer(value);
-        } else {
-            data.samples[i] = int_from_buffer(value);
-        }
-    }
-}
-
-/* Read the filename given and store all wav file data into the returned wav_file */
-wav_file read_file(char* filename) {
-    FILE* file = fopen(filename, "rb");
-    wav_file wav;
-    get_file_header(wav.header, file);
-    get_file_format(wav.fmt, file);
-    get_file_data(wav.data, file, wav.fmt.block_align);
-    fclose(file);
-    return wav;
-}
-
-/***************************************
- * Functions for writing to a wav file *
- ***************************************/
-/* Write an integer in little endian format to the file stream */
-void fwriteIntLSB(int data, FILE *file) {
-    char array[4];
+#include "headers/reader.h"
+#include "headers/writer.h"
+#include "headers/convolution.h"
+#include "headers/misc.h"
 
-    array[3] = (unsigned char)((data >> 24) & 0xFF);
-    array[2] = (unsigned char)((data >> 16) & 0xFF);
-    array[1] = (unsigned char)((data >> 8) & 0xFF);
-    array[0] = (unsigned char)(data & 0xFF);
-    fwrite((char *)array, 4, 1, file);
-}
-
-/* Write a short in little endian format to the file stream */
-void fwriteShortLSB(short data, FILE *file) {
-    char array[2];
-
-    array[1] = (unsigned char)((data >> 8) & 0xFF);
-    array[0] = (unsigned char)(data & 0xFF);
-    fwrite((char *)array, 2, 1, file);
-}
-
-/* Write the fileheader to an open output filestream */
-void write_file_header(file_header header, FILE *file) {
-    fwrite(header.chunk_id, 4, 1, file);
-    fwriteIntLSB(header.chunk_size, file);
-    fwrite(header.format, 4, 1, file);
-}
-
-/* Write the file format subchunk to an open output filestream */
-void write_file_format(file_fmt fmt, FILE *file) {
-    fwrite(fmt.subchunk_id, 4, 1, file);
-    fwriteIntLSB(fmt.subchunk_size, file);
-    fwriteShortLSB(fmt.audio_format, file);
-    fwriteShortLSB(fmt.num_channels, file);
-    fwriteIntLSB(fmt.sample_rate, file);
-    fwriteIntLSB(fmt.byte_rate, file);
-    fwriteShortLSB(fmt.block_align, file);
-    fwriteShortLSB(fmt.bits_per_sample, file);
-}
-
-/* Write the data subchunk to an open output filestream */
-void write_file_data(file_data data, FILE *file, int block_align) {
-    fwrite(data.subchunk_id, 4, 1, file);
-    fwriteIntLSB(data.subchunk_size, file);
-    
-    for (int i = 0; i < data.num_samples; i++) {
-        if (block_align == 2) {
-            fwriteShortLSB(data.samples[i], file);
-        } else {
-            fwriteIntLSB(data.samples[i], file);
-        }
-    }
-}
-
-/* Write the wav_file struct to a given file */
-void write_to_file(wav_file wav, char* filename) {
-    FILE *file = fopen(filename, "wb");
-    write_file_header(wav.header, file);
-    write_file_format(wav.fmt, file);
-    write_file_data(wav.data, file, wav.fmt.block_align);
-    fclose(file);
-}
-
-/***************
- * Convolution *
- ***************/
-wav_file create_wav(short* samples, int num_samples, wav_file input) {
-    wav_file output;
-
-    // fmt subchunk
-    strncpy(output.fmt.subchunk_id, "fmt ", 4);
-    output.fmt.subchunk_size = 16;
-    output.fmt.audio_format = 1;
-    output.fmt.num_channels = input.fmt.num_channels;
-    output.fmt.sample_rate = input.fmt.sample_rate;
-    output.fmt.byte_rate = input.fmt.byte_rate;
-    output.fmt.block_align = input.fmt.block_align;
-    output.fmt.bits_per_sample = input.fmt.bits_per_sample;
-
-    // data subchunk
-    strncpy(output.data.subchunk_id, "data", 4);
-    output.data.num_samples = num_samples;
-    output.data.samples = samples;
-    output.data.subchunk_size = num_samples * (output.fmt.num_channels) * (output.fmt.bits_per_sample)/8;
-
-    // header chunk
-    strncpy(output.header.chunk_id, "RIFF", 4);
-    strncpy(output.header.format, "WAVE", 4);
-    output.header.chunk_size = 4 + (8 + output.fmt.subchunk_size) + (8 + output.data.subchunk_size);
-
-    return output;
-}
-
-/* Using a slightly modified version of the input-side algorithm presented in lecture */
-void convolve(float* x, int N, float* h, int M, float* y, int P) {
-    int n, m;
-
-	// Clear output buffer y[]
-	for (n = 0; n < P; n++) {
-		y[n] = 0.0;
-	}
-
-	// Outer Loop: Process each input value x[n] in turn
-	for (n = 0; n < N; n++) {
-		// Inner Loop: process x[n] with each sample of h[n]
-		for (m = 0; m < M; m++) {
-			y[n+m] += x[n] * h[m];
-		}
-	}
-}
-
-/* Some conversion functions */
-float short_to_float(short i) {
-    float f;
-    if (i < 0) { f = ((float)i) / 32768.0f; }
-    else { f = ((float)i) / 32767.0f; }
-    return f;
-}
-
-short float_to_short(float i) {
-    short s;
-    if (i < 0) { s = rint(i * 32768.0f); }
-    else { s = rint(i * 32767.0f); }
-    return s;
-}
-
-/* Take the input and ir wav_files, format their data as floats and perform the convolution */
-wav_file convolve_files(wav_file input, wav_file ir) {
-    int N = input.data.num_samples;
-    int M = ir.data.num_samples;
-    int P = N + M + 1;
-
-    int f = sizeof(float);
-    float *x = (float *)malloc(N * f);
-    float *h = (float *)malloc(M * f);
-    float *y = (float *)malloc(P * f);
-
-    // Convert the stored sample values as floats from -1.0 to 1.0
-    int i;
-    for (i = 0; i < N; i++) {
-        x[i] = short_to_float(input.data.samples[i]);
-    }
-    for (i = 0; i < M; i++) {
-        h[i] = short_to_float(ir.data.samples[i]);
-    }
-
-    // Perform the convolution
-    convolve(x, N, h, M, y, P);
-
-    // The convolution can result in values > 1.0, make sure to scale them
-    float largest = 1.0;
-    for (i = 0; i < P; i++) {
-        if (abs(y[i]) > largest) { largest = abs(y[i]); }
-    }
-    printf("\nScaling output by %f\n\n", largest);
-
-    // Convert the floats now stored in y back into sample values
-    short *samples = (short *)malloc(P * input.fmt.block_align);
-    for (i = 0; i < P; i++) {
-        samples[i] = float_to_short(y[i] / largest);
-    }
-
-    // Clean up the float arrays
-    free(x);
-    free(h);
-    free(y);
-
-    // Create the output wav file using the above data
-    return create_wav(samples, P, input);
-}
-
-/***************************
- * Miscellaneous functions *
- ***************************/
-/* Some potentially helpful print statements for developing help */
-void print_id(char buf[]) {
-    for (int i = 0; i < 4; i++) {
-        printf("%c", buf[i]);
-    }
-    printf("\n");
-}
-void print_file_data(wav_file wav) {
-    printf("\tChunk ID: ");
-    print_id(wav.header.chunk_id);
-    printf("\tChunk Size: %d\n", wav.header.chunk_size);
-    printf("\tFormat: ");
-    print_id(wav.header.format);
-    
-    printf("\n\tSubchunk ID: ");
-    print_id(wav.fmt.subchunk_id);
-    printf("\tSubchunk Size: %d\n", wav.fmt.subchunk_size);
-    printf("\tAudio Format: %d\n", wav.fmt.audio_format);
-    printf("\tNum Channels: %d\n", wav.fmt.num_channels);
-    printf("\tSample Rate: %d\n", wav.fmt.sample_rate);
-    printf("\tByte Rate: %d\n", wav.fmt.byte_rate);
-    printf("\tBlock Align: %d\n", wav.fmt.block_align);
-    printf("\tBits Per Sample: %d\n", wav.fmt.bits_per_sample);
-
-    printf("\n\tSubchunk ID: ");
-    print_id(wav.data.subchunk_id);
-    printf("\tSubchunk Size: %d\n", wav.data.subchunk_size);
-    printf("\tSample Count: %d\n", wav.data.num_samples);
-}
-void exit_if_invalid(char* path) {
-    struct stat sb;
-    if (stat(path, &sb) != 0) {
-        printf("Error: Could not find file: %s\n", path);
-        exit(EXIT_FAILURE);
-    }
-}
+using namespace std;
 
 /********
  * Main *
diff --git a/headers/convolution.h b/headers/convolution.h
new file mode 100644
index 0000000..0b0cd6b
--- /dev/null
+++ b/headers/convolution.h
@@ -0,0 +1,6 @@
+#ifndef FILE_STRUCTS_H
+#define FILE_STRUCTS_H
+#include "./file_structs.h"
+#endif
+
+wav_file convolve_files(wav_file input, wav_file ir);
diff --git a/headers/file_structs.h b/headers/file_structs.h
new file mode 100644
index 0000000..88a296e
--- /dev/null
+++ b/headers/file_structs.h
@@ -0,0 +1,30 @@
+/* Some structs to store values for a given file*/
+struct file_header {
+    char    chunk_id[4];
+    int     chunk_size;
+    char    format[4];
+};
+
+struct file_fmt {
+    char    subchunk_id[4];
+    int     subchunk_size;
+    short   audio_format;
+    short   num_channels;
+    int     sample_rate;
+    int     byte_rate;
+    short   block_align;
+    short   bits_per_sample;
+};
+
+struct file_data {
+    char    subchunk_id[4];
+    int     subchunk_size;
+    int     num_samples;    // Not read from the file, just helpful to store here
+    short*  samples;
+};
+
+struct wav_file {
+    file_header header;
+    file_fmt fmt;
+    file_data data;
+};
diff --git a/headers/misc.h b/headers/misc.h
new file mode 100644
index 0000000..1a01dae
--- /dev/null
+++ b/headers/misc.h
@@ -0,0 +1,7 @@
+#ifndef FILE_STRUCTS_H
+#define FILE_STRUCTS_H
+#include "./file_structs.h"
+#endif
+
+void print_file_data(wav_file wav);
+void exit_if_invalid(char* path);
diff --git a/headers/reader.h b/headers/reader.h
new file mode 100644
index 0000000..cc8b06a
--- /dev/null
+++ b/headers/reader.h
@@ -0,0 +1,6 @@
+#ifndef FILE_STRUCTS_H
+#define FILE_STRUCTS_H
+#include "./file_structs.h"
+#endif
+
+wav_file read_file(char* filename);
diff --git a/headers/writer.h b/headers/writer.h
new file mode 100644
index 0000000..66a58e8
--- /dev/null
+++ b/headers/writer.h
@@ -0,0 +1,6 @@
+#ifndef FILE_STRUCTS_H
+#define FILE_STRUCTS_H
+#include "./file_structs.h"
+#endif
+
+void write_to_file(wav_file wav, char* filename);
diff --git a/modules/convolution.cpp b/modules/convolution.cpp
new file mode 100644
index 0000000..94b2398
--- /dev/null
+++ b/modules/convolution.cpp
@@ -0,0 +1,113 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <cstring>
+#include "../headers/file_structs.h"
+
+/***************
+ * Convolution *
+ ***************/
+wav_file create_wav(short* samples, int num_samples, wav_file input) {
+    wav_file output;
+
+    // fmt subchunk
+    strncpy(output.fmt.subchunk_id, "fmt ", 4);
+    output.fmt.subchunk_size = 16;
+    output.fmt.audio_format = 1;
+    output.fmt.num_channels = input.fmt.num_channels;
+    output.fmt.sample_rate = input.fmt.sample_rate;
+    output.fmt.byte_rate = input.fmt.byte_rate;
+    output.fmt.block_align = input.fmt.block_align;
+    output.fmt.bits_per_sample = input.fmt.bits_per_sample;
+
+    // data subchunk
+    strncpy(output.data.subchunk_id, "data", 4);
+    output.data.num_samples = num_samples;
+    output.data.samples = samples;
+    output.data.subchunk_size = num_samples * (output.fmt.num_channels) * (output.fmt.bits_per_sample)/8;
+
+    // header chunk
+    strncpy(output.header.chunk_id, "RIFF", 4);
+    strncpy(output.header.format, "WAVE", 4);
+    output.header.chunk_size = 4 + (8 + output.fmt.subchunk_size) + (8 + output.data.subchunk_size);
+
+    return output;
+}
+
+/* Using a slightly modified version of the input-side algorithm presented in lecture */
+void convolve(float* x, int N, float* h, int M, float* y, int P) {
+    int n, m;
+
+	// Clear output buffer y[]
+	for (n = 0; n < P; n++) {
+		y[n] = 0.0;
+	}
+
+	// Outer Loop: Process each input value x[n] in turn
+	for (n = 0; n < N; n++) {
+		// Inner Loop: process x[n] with each sample of h[n]
+		for (m = 0; m < M; m++) {
+			y[n+m] += x[n] * h[m];
+		}
+	}
+}
+
+/* Some conversion functions */
+float short_to_float(short i) {
+    float f;
+    if (i < 0) { f = ((float)i) / 32768.0f; }
+    else { f = ((float)i) / 32767.0f; }
+    return f;
+}
+
+short float_to_short(float i) {
+    short s;
+    if (i < 0) { s = rint(i * 32768.0f); }
+    else { s = rint(i * 32767.0f); }
+    return s;
+}
+
+/* Take the input and ir wav_files, format their data as floats and perform the convolution */
+wav_file convolve_files(wav_file input, wav_file ir) {
+    int N = input.data.num_samples;
+    int M = ir.data.num_samples;
+    int P = N + M + 1;
+
+    int f = sizeof(float);
+    float *x = (float *)malloc(N * f);
+    float *h = (float *)malloc(M * f);
+    float *y = (float *)malloc(P * f);
+
+    // Convert the stored sample values as floats from -1.0 to 1.0
+    int i;
+    for (i = 0; i < N; i++) {
+        x[i] = short_to_float(input.data.samples[i]);
+    }
+    for (i = 0; i < M; i++) {
+        h[i] = short_to_float(ir.data.samples[i]);
+    }
+
+    // Perform the convolution
+    convolve(x, N, h, M, y, P);
+
+    // The convolution can result in values > 1.0, make sure to scale them
+    float largest = 1.0;
+    for (i = 0; i < P; i++) {
+        if (abs(y[i]) > largest) { largest = abs(y[i]); }
+    }
+    printf("\nScaling output by %f\n\n", largest);
+
+    // Convert the floats now stored in y back into sample values
+    short *samples = (short *)malloc(P * input.fmt.block_align);
+    for (i = 0; i < P; i++) {
+        samples[i] = float_to_short(y[i] / largest);
+    }
+
+    // Clean up the float arrays
+    free(x);
+    free(h);
+    free(y);
+
+    // Create the output wav file using the above data
+    return create_wav(samples, P, input);
+}
diff --git a/modules/misc.cpp b/modules/misc.cpp
new file mode 100644
index 0000000..029ab39
--- /dev/null
+++ b/modules/misc.cpp
@@ -0,0 +1,44 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include "../headers/file_structs.h"
+
+/***************************
+ * Miscellaneous functions *
+ ***************************/
+/* Some potentially helpful print statements for developing help */
+void print_id(char buf[]) {
+    for (int i = 0; i < 4; i++) {
+        printf("%c", buf[i]);
+    }
+    printf("\n");
+}
+void print_file_data(wav_file wav) {
+    printf("\tChunk ID: ");
+    print_id(wav.header.chunk_id);
+    printf("\tChunk Size: %d\n", wav.header.chunk_size);
+    printf("\tFormat: ");
+    print_id(wav.header.format);
+    
+    printf("\n\tSubchunk ID: ");
+    print_id(wav.fmt.subchunk_id);
+    printf("\tSubchunk Size: %d\n", wav.fmt.subchunk_size);
+    printf("\tAudio Format: %d\n", wav.fmt.audio_format);
+    printf("\tNum Channels: %d\n", wav.fmt.num_channels);
+    printf("\tSample Rate: %d\n", wav.fmt.sample_rate);
+    printf("\tByte Rate: %d\n", wav.fmt.byte_rate);
+    printf("\tBlock Align: %d\n", wav.fmt.block_align);
+    printf("\tBits Per Sample: %d\n", wav.fmt.bits_per_sample);
+
+    printf("\n\tSubchunk ID: ");
+    print_id(wav.data.subchunk_id);
+    printf("\tSubchunk Size: %d\n", wav.data.subchunk_size);
+    printf("\tSample Count: %d\n", wav.data.num_samples);
+}
+void exit_if_invalid(char* path) {
+    struct stat sb;
+    if (stat(path, &sb) != 0) {
+        printf("Error: Could not find file: %s\n", path);
+        exit(EXIT_FAILURE);
+    }
+}
diff --git a/modules/reader.cpp b/modules/reader.cpp
new file mode 100644
index 0000000..9312aa4
--- /dev/null
+++ b/modules/reader.cpp
@@ -0,0 +1,109 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "../headers/file_structs.h"
+
+/*****************************************
+ * Functions for reading from a wav file *
+ *****************************************/
+/* Get an int from a byte buffer of size 4 */
+int int_from_buffer(char buf[]) {
+    int value =
+        ((buf[3] & 0xFF) << 24) |
+        ((buf[2] & 0xFF) << 16) |
+        ((buf[1] & 0xFF) << 8) |
+        (buf[0] & 0xFF);
+    return value;
+}
+
+/* Get a short from a byte buffer of size 2 */
+short short_from_buffer(char buf[]) {
+    short value =
+        ((buf[1] & 0xFF) << 8) |
+        (buf[0] & 0xFF);
+    return value;
+}
+
+/* Use file to fill out the provided header */
+void get_file_header(file_header &header, FILE* file) {
+    fread(&header.chunk_id, 4, 1, file);
+    
+    char size[4];
+    fread(&size, 4, 1, file);
+    header.chunk_size = int_from_buffer(size);
+
+    fread(&header.format, 4, 1, file);
+}
+
+/* Use file to fill out the provided format subchunk */
+void get_file_format(file_fmt &fmt, FILE *file) {
+    fread(fmt.subchunk_id, 4, 1, file);
+
+    char size[4];
+    fread(&size, 4, 1, file);
+    fmt.subchunk_size = int_from_buffer(size);
+
+    char audio_format[2];
+    fread(&audio_format, 2, 1, file);
+    fmt.audio_format = short_from_buffer(audio_format);
+
+    char num_channels[2];
+    fread(&num_channels, 2, 1, file);
+    fmt.num_channels = short_from_buffer(num_channels);
+
+    char sample_rate[4];
+    fread(&sample_rate, 4, 1, file);
+    fmt.sample_rate = int_from_buffer(sample_rate);
+
+    char byte_rate[4];
+    fread(&byte_rate, 4, 1, file);
+    fmt.byte_rate = int_from_buffer(byte_rate);
+
+    char block_align[2];
+    fread(&block_align, 2, 1, file);
+    fmt.block_align = short_from_buffer(block_align);
+
+    char bits_per_sample[2];
+    fread(&bits_per_sample, 2, 1, file);
+    fmt.bits_per_sample = short_from_buffer(bits_per_sample);
+
+    if (fmt.subchunk_size > 16) {
+        // Sometimes the fmt of the ir's have a subchunk size that is randomly too big
+        // Throw those away
+        int l = fmt.subchunk_size - 16;
+        char garbage[l];
+        fread(&garbage, l, 1, file);
+    }
+}
+
+/* Use file to fill out the provided data subchunk */
+void get_file_data(file_data &data, FILE* file, int sample_size) {
+    fread(&data.subchunk_id, 4, 1, file);
+
+    char size[4];
+    fread(&size, 4, 1, file);
+    data.subchunk_size = int_from_buffer(size);
+
+    int num_samples = data.subchunk_size / sample_size;
+    data.num_samples = num_samples;
+    data.samples = (short *)malloc(data.subchunk_size);
+    for (int i = 0; i < num_samples; i++) {
+        char value[sample_size];
+        fread(&value, sample_size, 1, file);
+        if (sample_size==2) {
+            data.samples[i] = short_from_buffer(value);
+        } else {
+            data.samples[i] = int_from_buffer(value);
+        }
+    }
+}
+
+/* Read the filename given and store all wav file data into the returned wav_file */
+wav_file read_file(char* filename) {
+    FILE* file = fopen(filename, "rb");
+    wav_file wav;
+    get_file_header(wav.header, file);
+    get_file_format(wav.fmt, file);
+    get_file_data(wav.data, file, wav.fmt.block_align);
+    fclose(file);
+    return wav;
+}
diff --git a/modules/writer.cpp b/modules/writer.cpp
new file mode 100644
index 0000000..7d9800c
--- /dev/null
+++ b/modules/writer.cpp
@@ -0,0 +1,67 @@
+#include <stdio.h>
+#include "../headers/file_structs.h"
+
+/***************************************
+ * Functions for writing to a wav file *
+ ***************************************/
+/* Write an integer in little endian format to the file stream */
+void fwriteIntLSB(int data, FILE *file) {
+    char array[4];
+
+    array[3] = (unsigned char)((data >> 24) & 0xFF);
+    array[2] = (unsigned char)((data >> 16) & 0xFF);
+    array[1] = (unsigned char)((data >> 8) & 0xFF);
+    array[0] = (unsigned char)(data & 0xFF);
+    fwrite((char *)array, 4, 1, file);
+}
+
+/* Write a short in little endian format to the file stream */
+void fwriteShortLSB(short data, FILE *file) {
+    char array[2];
+
+    array[1] = (unsigned char)((data >> 8) & 0xFF);
+    array[0] = (unsigned char)(data & 0xFF);
+    fwrite((char *)array, 2, 1, file);
+}
+
+/* Write the fileheader to an open output filestream */
+void write_file_header(file_header header, FILE *file) {
+    fwrite(header.chunk_id, 4, 1, file);
+    fwriteIntLSB(header.chunk_size, file);
+    fwrite(header.format, 4, 1, file);
+}
+
+/* Write the file format subchunk to an open output filestream */
+void write_file_format(file_fmt fmt, FILE *file) {
+    fwrite(fmt.subchunk_id, 4, 1, file);
+    fwriteIntLSB(fmt.subchunk_size, file);
+    fwriteShortLSB(fmt.audio_format, file);
+    fwriteShortLSB(fmt.num_channels, file);
+    fwriteIntLSB(fmt.sample_rate, file);
+    fwriteIntLSB(fmt.byte_rate, file);
+    fwriteShortLSB(fmt.block_align, file);
+    fwriteShortLSB(fmt.bits_per_sample, file);
+}
+
+/* Write the data subchunk to an open output filestream */
+void write_file_data(file_data data, FILE *file, int block_align) {
+    fwrite(data.subchunk_id, 4, 1, file);
+    fwriteIntLSB(data.subchunk_size, file);
+    
+    for (int i = 0; i < data.num_samples; i++) {
+        if (block_align == 2) {
+            fwriteShortLSB(data.samples[i], file);
+        } else {
+            fwriteIntLSB(data.samples[i], file);
+        }
+    }
+}
+
+/* Write the wav_file struct to a given file */
+void write_to_file(wav_file wav, char* filename) {
+    FILE *file = fopen(filename, "wb");
+    write_file_header(wav.header, file);
+    write_file_format(wav.fmt, file);
+    write_file_data(wav.data, file, wav.fmt.block_align);
+    fclose(file);
+}

commit 6b66b087b9c68637960f57f801cd16d277e88e49
Author: alexs2112 <alexste2112@gmail.com>
Date:   Tue Nov 28 11:47:40 2023 -0700

    fix that stupid seg fault on big inputs

diff --git a/convolve.cpp b/convolve.cpp
index 0083c0f..76cbe5d 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -277,9 +277,10 @@ wav_file convolve_files(wav_file input, wav_file ir) {
     int M = ir.data.num_samples;
     int P = N + M + 1;
 
-    float x[N];
-    float h[M];
-    float y[P];
+    int f = sizeof(float);
+    float *x = (float *)malloc(N * f);
+    float *h = (float *)malloc(M * f);
+    float *y = (float *)malloc(P * f);
 
     // Convert the stored sample values as floats from -1.0 to 1.0
     int i;
@@ -306,6 +307,11 @@ wav_file convolve_files(wav_file input, wav_file ir) {
         samples[i] = float_to_short(y[i] / largest);
     }
 
+    // Clean up the float arrays
+    free(x);
+    free(h);
+    free(y);
+
     // Create the output wav file using the above data
     return create_wav(samples, P, input);
 }

commit 922250075c19c7514777db7a274c6f7442a7e108
Author: alexs2112 <alexste2112@gmail.com>
Date:   Tue Nov 28 10:48:38 2023 -0700

    finish storing sample arrays on the heap

diff --git a/Makefile b/Makefile
index 3047418..be27e52 100644
--- a/Makefile
+++ b/Makefile
@@ -1 +1,2 @@
 convolve: convolve.cpp
+	g++ -g -o convolve convolve.cpp
diff --git a/convolve.cpp b/convolve.cpp
index d94ce2b..0083c0f 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -120,17 +120,16 @@ void get_file_data(file_data &data, FILE* file, int sample_size) {
 
     int num_samples = data.subchunk_size / sample_size;
     data.num_samples = num_samples;
-    short samples[num_samples];
+    data.samples = (short *)malloc(data.subchunk_size);
     for (int i = 0; i < num_samples; i++) {
         char value[sample_size];
         fread(&value, sample_size, 1, file);
         if (sample_size==2) {
-            samples[i] = short_from_buffer(value);
+            data.samples[i] = short_from_buffer(value);
         } else {
-            samples[i] = int_from_buffer(value);
+            data.samples[i] = int_from_buffer(value);
         }
     }
-    data.samples = samples;
 }
 
 /* Read the filename given and store all wav file data into the returned wav_file */
@@ -302,7 +301,7 @@ wav_file convolve_files(wav_file input, wav_file ir) {
     printf("\nScaling output by %f\n\n", largest);
 
     // Convert the floats now stored in y back into sample values
-    short samples[P];
+    short *samples = (short *)malloc(P * input.fmt.block_align);
     for (i = 0; i < P; i++) {
         samples[i] = float_to_short(y[i] / largest);
     }
@@ -376,5 +375,9 @@ int main(int argc, char* argv[]) {
 
     write_to_file(output, argv[3]);
 
+    free(input.data.samples);
+    free(ir.data.samples);
+    free(output.data.samples);
+
     return EXIT_SUCCESS;
 }

commit 5b2dc9ca6af5ae6f79f0f7884ee364ccf388b3b1
Author: alexs2112 <alexste2112@gmail.com>
Date:   Mon Nov 27 14:06:55 2023 -0700

    implement convolution

diff --git a/.gitignore b/.gitignore
index 3b9a521..41febad 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,3 +2,4 @@
 provided/
 convolve
 *.wav
+*.txt
diff --git a/convolve.cpp b/convolve.cpp
index 9c7a71f..d94ce2b 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -1,8 +1,8 @@
 #include <stdio.h>
 #include <stdlib.h>
-#include <iostream>
-#include <fstream>
 #include <sys/stat.h>
+#include <math.h>
+#include <cstring>
 
 using namespace std;
 
@@ -59,83 +59,88 @@ short short_from_buffer(char buf[]) {
 }
 
 /* Use file to fill out the provided header */
-void get_file_header(file_header &header, ifstream &file) {
-    file.read(header.chunk_id, 4);
-
+void get_file_header(file_header &header, FILE* file) {
+    fread(&header.chunk_id, 4, 1, file);
+    
     char size[4];
-    file.read(size, 4);
+    fread(&size, 4, 1, file);
     header.chunk_size = int_from_buffer(size);
 
-    file.read(header.format, 4);
+    fread(&header.format, 4, 1, file);
 }
 
 /* Use file to fill out the provided format subchunk */
-void get_file_format(file_fmt &fmt, ifstream &file) {
-    file.read(fmt.subchunk_id, 4);
+void get_file_format(file_fmt &fmt, FILE *file) {
+    fread(fmt.subchunk_id, 4, 1, file);
 
     char size[4];
-    file.read(size, 4);
+    fread(&size, 4, 1, file);
     fmt.subchunk_size = int_from_buffer(size);
 
     char audio_format[2];
-    file.read(audio_format, 2);
+    fread(&audio_format, 2, 1, file);
     fmt.audio_format = short_from_buffer(audio_format);
 
     char num_channels[2];
-    file.read(num_channels, 2);
+    fread(&num_channels, 2, 1, file);
     fmt.num_channels = short_from_buffer(num_channels);
 
     char sample_rate[4];
-    file.read(sample_rate, 4);
+    fread(&sample_rate, 4, 1, file);
     fmt.sample_rate = int_from_buffer(sample_rate);
 
     char byte_rate[4];
-    file.read(byte_rate, 4);
+    fread(&byte_rate, 4, 1, file);
     fmt.byte_rate = int_from_buffer(byte_rate);
 
     char block_align[2];
-    file.read(block_align, 2);
+    fread(&block_align, 2, 1, file);
     fmt.block_align = short_from_buffer(block_align);
 
     char bits_per_sample[2];
-    file.read(bits_per_sample, 2);
+    fread(&bits_per_sample, 2, 1, file);
     fmt.bits_per_sample = short_from_buffer(bits_per_sample);
 
     if (fmt.subchunk_size > 16) {
         // Sometimes the fmt of the ir's have a subchunk size that is randomly too big
         // Throw those away
-        file.read(size, fmt.subchunk_size - 16);
+        int l = fmt.subchunk_size - 16;
+        char garbage[l];
+        fread(&garbage, l, 1, file);
     }
 }
 
 /* Use file to fill out the provided data subchunk */
-void get_file_data(file_data &data, ifstream &file, int sample_size) {
-    file.read(data.subchunk_id, 4);
+void get_file_data(file_data &data, FILE* file, int sample_size) {
+    fread(&data.subchunk_id, 4, 1, file);
 
     char size[4];
-    file.read(size, 4);
+    fread(&size, 4, 1, file);
     data.subchunk_size = int_from_buffer(size);
 
     int num_samples = data.subchunk_size / sample_size;
     data.num_samples = num_samples;
     short samples[num_samples];
     for (int i = 0; i < num_samples; i++) {
-        char value[2];
-        file.read(value, 2);
-        samples[i] = short_from_buffer(value);
+        char value[sample_size];
+        fread(&value, sample_size, 1, file);
+        if (sample_size==2) {
+            samples[i] = short_from_buffer(value);
+        } else {
+            samples[i] = int_from_buffer(value);
+        }
     }
     data.samples = samples;
 }
 
 /* Read the filename given and store all wav file data into the returned wav_file */
 wav_file read_file(char* filename) {
-    ifstream file = ifstream(filename);
-    if (!file.is_open()) { exit(EXIT_FAILURE); }
+    FILE* file = fopen(filename, "rb");
     wav_file wav;
     get_file_header(wav.header, file);
     get_file_format(wav.fmt, file);
     get_file_data(wav.data, file, wav.fmt.block_align);
-    file.close();
+    fclose(file);
     return wav;
 }
 
@@ -143,35 +148,35 @@ wav_file read_file(char* filename) {
  * Functions for writing to a wav file *
  ***************************************/
 /* Write an integer in little endian format to the file stream */
-void fwriteIntLSB(int data, ofstream &file) {
+void fwriteIntLSB(int data, FILE *file) {
     char array[4];
 
     array[3] = (unsigned char)((data >> 24) & 0xFF);
     array[2] = (unsigned char)((data >> 16) & 0xFF);
     array[1] = (unsigned char)((data >> 8) & 0xFF);
     array[0] = (unsigned char)(data & 0xFF);
-    file.write((char *)array, 4);
+    fwrite((char *)array, 4, 1, file);
 }
 
 /* Write a short in little endian format to the file stream */
-void fwriteShortLSB(short data, ofstream &file) {
+void fwriteShortLSB(short data, FILE *file) {
     char array[2];
 
     array[1] = (unsigned char)((data >> 8) & 0xFF);
     array[0] = (unsigned char)(data & 0xFF);
-    file.write((char *)array, 2);
+    fwrite((char *)array, 2, 1, file);
 }
 
 /* Write the fileheader to an open output filestream */
-void write_file_header(file_header header, ofstream &file) {
-    file.write(header.chunk_id, 4);
+void write_file_header(file_header header, FILE *file) {
+    fwrite(header.chunk_id, 4, 1, file);
     fwriteIntLSB(header.chunk_size, file);
-    file.write(header.format, 4);
+    fwrite(header.format, 4, 1, file);
 }
 
 /* Write the file format subchunk to an open output filestream */
-void write_file_format(file_fmt fmt, ofstream &file) {
-    file.write(fmt.subchunk_id, 4);
+void write_file_format(file_fmt fmt, FILE *file) {
+    fwrite(fmt.subchunk_id, 4, 1, file);
     fwriteIntLSB(fmt.subchunk_size, file);
     fwriteShortLSB(fmt.audio_format, file);
     fwriteShortLSB(fmt.num_channels, file);
@@ -182,8 +187,8 @@ void write_file_format(file_fmt fmt, ofstream &file) {
 }
 
 /* Write the data subchunk to an open output filestream */
-void write_file_data(file_data data, ofstream &file, int block_align) {
-    file.write(data.subchunk_id, 4);
+void write_file_data(file_data data, FILE *file, int block_align) {
+    fwrite(data.subchunk_id, 4, 1, file);
     fwriteIntLSB(data.subchunk_size, file);
     
     for (int i = 0; i < data.num_samples; i++) {
@@ -195,13 +200,115 @@ void write_file_data(file_data data, ofstream &file, int block_align) {
     }
 }
 
+/* Write the wav_file struct to a given file */
 void write_to_file(wav_file wav, char* filename) {
-    ofstream file = ofstream(filename);
-    if (!file.is_open()) { exit(EXIT_FAILURE); }
+    FILE *file = fopen(filename, "wb");
     write_file_header(wav.header, file);
     write_file_format(wav.fmt, file);
     write_file_data(wav.data, file, wav.fmt.block_align);
-    file.close();
+    fclose(file);
+}
+
+/***************
+ * Convolution *
+ ***************/
+wav_file create_wav(short* samples, int num_samples, wav_file input) {
+    wav_file output;
+
+    // fmt subchunk
+    strncpy(output.fmt.subchunk_id, "fmt ", 4);
+    output.fmt.subchunk_size = 16;
+    output.fmt.audio_format = 1;
+    output.fmt.num_channels = input.fmt.num_channels;
+    output.fmt.sample_rate = input.fmt.sample_rate;
+    output.fmt.byte_rate = input.fmt.byte_rate;
+    output.fmt.block_align = input.fmt.block_align;
+    output.fmt.bits_per_sample = input.fmt.bits_per_sample;
+
+    // data subchunk
+    strncpy(output.data.subchunk_id, "data", 4);
+    output.data.num_samples = num_samples;
+    output.data.samples = samples;
+    output.data.subchunk_size = num_samples * (output.fmt.num_channels) * (output.fmt.bits_per_sample)/8;
+
+    // header chunk
+    strncpy(output.header.chunk_id, "RIFF", 4);
+    strncpy(output.header.format, "WAVE", 4);
+    output.header.chunk_size = 4 + (8 + output.fmt.subchunk_size) + (8 + output.data.subchunk_size);
+
+    return output;
+}
+
+/* Using a slightly modified version of the input-side algorithm presented in lecture */
+void convolve(float* x, int N, float* h, int M, float* y, int P) {
+    int n, m;
+
+	// Clear output buffer y[]
+	for (n = 0; n < P; n++) {
+		y[n] = 0.0;
+	}
+
+	// Outer Loop: Process each input value x[n] in turn
+	for (n = 0; n < N; n++) {
+		// Inner Loop: process x[n] with each sample of h[n]
+		for (m = 0; m < M; m++) {
+			y[n+m] += x[n] * h[m];
+		}
+	}
+}
+
+/* Some conversion functions */
+float short_to_float(short i) {
+    float f;
+    if (i < 0) { f = ((float)i) / 32768.0f; }
+    else { f = ((float)i) / 32767.0f; }
+    return f;
+}
+
+short float_to_short(float i) {
+    short s;
+    if (i < 0) { s = rint(i * 32768.0f); }
+    else { s = rint(i * 32767.0f); }
+    return s;
+}
+
+/* Take the input and ir wav_files, format their data as floats and perform the convolution */
+wav_file convolve_files(wav_file input, wav_file ir) {
+    int N = input.data.num_samples;
+    int M = ir.data.num_samples;
+    int P = N + M + 1;
+
+    float x[N];
+    float h[M];
+    float y[P];
+
+    // Convert the stored sample values as floats from -1.0 to 1.0
+    int i;
+    for (i = 0; i < N; i++) {
+        x[i] = short_to_float(input.data.samples[i]);
+    }
+    for (i = 0; i < M; i++) {
+        h[i] = short_to_float(ir.data.samples[i]);
+    }
+
+    // Perform the convolution
+    convolve(x, N, h, M, y, P);
+
+    // The convolution can result in values > 1.0, make sure to scale them
+    float largest = 1.0;
+    for (i = 0; i < P; i++) {
+        if (abs(y[i]) > largest) { largest = abs(y[i]); }
+    }
+    printf("\nScaling output by %f\n\n", largest);
+
+    // Convert the floats now stored in y back into sample values
+    short samples[P];
+    for (i = 0; i < P; i++) {
+        samples[i] = float_to_short(y[i] / largest);
+    }
+
+    // Create the output wav file using the above data
+    return create_wav(samples, P, input);
 }
 
 /***************************
@@ -263,7 +370,11 @@ int main(int argc, char* argv[]) {
     printf("\nIMPULSE RESPONSE:\n");
     print_file_data(ir);
 
-    write_to_file(input, argv[3]);
+    wav_file output = convolve_files(input, ir);
+    printf("\nOUTPUT FILE:\n");
+    print_file_data(output);
+
+    write_to_file(output, argv[3]);
 
     return EXIT_SUCCESS;
 }

commit 97767f3a1fe2a27e054edddba130d1f1159c8f6e
Author: alexs2112 <alexste2112@gmail.com>
Date:   Wed Nov 22 12:22:13 2023 -0700

    better error handling, read IR files

diff --git a/convolve.cpp b/convolve.cpp
index e17f040..9c7a71f 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -2,6 +2,7 @@
 #include <stdlib.h>
 #include <iostream>
 #include <fstream>
+#include <sys/stat.h>
 
 using namespace std;
 
@@ -99,6 +100,12 @@ void get_file_format(file_fmt &fmt, ifstream &file) {
     char bits_per_sample[2];
     file.read(bits_per_sample, 2);
     fmt.bits_per_sample = short_from_buffer(bits_per_sample);
+
+    if (fmt.subchunk_size > 16) {
+        // Sometimes the fmt of the ir's have a subchunk size that is randomly too big
+        // Throw those away
+        file.read(size, fmt.subchunk_size - 16);
+    }
 }
 
 /* Use file to fill out the provided data subchunk */
@@ -123,6 +130,7 @@ void get_file_data(file_data &data, ifstream &file, int sample_size) {
 /* Read the filename given and store all wav file data into the returned wav_file */
 wav_file read_file(char* filename) {
     ifstream file = ifstream(filename);
+    if (!file.is_open()) { exit(EXIT_FAILURE); }
     wav_file wav;
     get_file_header(wav.header, file);
     get_file_format(wav.fmt, file);
@@ -189,6 +197,7 @@ void write_file_data(file_data data, ofstream &file, int block_align) {
 
 void write_to_file(wav_file wav, char* filename) {
     ofstream file = ofstream(filename);
+    if (!file.is_open()) { exit(EXIT_FAILURE); }
     write_file_header(wav.header, file);
     write_file_format(wav.fmt, file);
     write_file_data(wav.data, file, wav.fmt.block_align);
@@ -206,29 +215,33 @@ void print_id(char buf[]) {
     printf("\n");
 }
 void print_file_data(wav_file wav) {
-    printf("HEADER\n");
-    printf("Chunk ID: ");
+    printf("\tChunk ID: ");
     print_id(wav.header.chunk_id);
-    printf("Chunk Size: %d\n", wav.header.chunk_size);
-    printf("Format: ");
+    printf("\tChunk Size: %d\n", wav.header.chunk_size);
+    printf("\tFormat: ");
     print_id(wav.header.format);
     
-    printf("\nFMT\n");
-    printf("Subchunk ID: ");
+    printf("\n\tSubchunk ID: ");
     print_id(wav.fmt.subchunk_id);
-    printf("Subchunk Size: %d\n", wav.fmt.subchunk_size);
-    printf("Audio Format: %d\n", wav.fmt.audio_format);
-    printf("Num Channels: %d\n", wav.fmt.num_channels);
-    printf("Sample Rate: %d\n", wav.fmt.sample_rate);
-    printf("Byte Rate: %d\n", wav.fmt.byte_rate);
-    printf("Block Align: %d\n", wav.fmt.block_align);
-    printf("Bits Per Sample: %d\n", wav.fmt.bits_per_sample);
-
-    printf("\nDATA\n");
-    printf("Subchunk ID: ");
+    printf("\tSubchunk Size: %d\n", wav.fmt.subchunk_size);
+    printf("\tAudio Format: %d\n", wav.fmt.audio_format);
+    printf("\tNum Channels: %d\n", wav.fmt.num_channels);
+    printf("\tSample Rate: %d\n", wav.fmt.sample_rate);
+    printf("\tByte Rate: %d\n", wav.fmt.byte_rate);
+    printf("\tBlock Align: %d\n", wav.fmt.block_align);
+    printf("\tBits Per Sample: %d\n", wav.fmt.bits_per_sample);
+
+    printf("\n\tSubchunk ID: ");
     print_id(wav.data.subchunk_id);
-    printf("Subchunk Size: %d\n", wav.data.subchunk_size);
-    printf("Sample Count: %d\n", wav.data.num_samples);
+    printf("\tSubchunk Size: %d\n", wav.data.subchunk_size);
+    printf("\tSample Count: %d\n", wav.data.num_samples);
+}
+void exit_if_invalid(char* path) {
+    struct stat sb;
+    if (stat(path, &sb) != 0) {
+        printf("Error: Could not find file: %s\n", path);
+        exit(EXIT_FAILURE);
+    }
 }
 
 /********
@@ -239,10 +252,18 @@ int main(int argc, char* argv[]) {
         printf("Usage: %s <input_file> <IR_file> <output_file>\n", argv[0]);
         exit(EXIT_FAILURE);
     }
+    exit_if_invalid(argv[1]);
+    exit_if_invalid(argv[2]);
+
+    wav_file input = read_file(argv[1]);
+    printf("INPUT FILE:\n");
+    print_file_data(input);
+
+    wav_file ir = read_file(argv[2]);
+    printf("\nIMPULSE RESPONSE:\n");
+    print_file_data(ir);
 
-    wav_file wav = read_file(argv[1]);
-    print_file_data(wav);
-    write_to_file(wav, argv[3]);
+    write_to_file(input, argv[3]);
 
     return EXIT_SUCCESS;
 }

commit d84621b3f0ac3b0a28971ef3f308097948439a32
Author: alexs2112 <alexste2112@gmail.com>
Date:   Wed Nov 22 11:08:44 2023 -0700

    write data to an output wav file

diff --git a/.gitignore b/.gitignore
index 438ad72..3b9a521 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
 .vscode/
-audio/
+provided/
 convolve
+*.wav
diff --git a/convolve.cpp b/convolve.cpp
index 90857e9..e17f040 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -5,6 +5,7 @@
 
 using namespace std;
 
+/* Some structs to store values for a given file*/
 struct file_header {
     char    chunk_id[4];
     int     chunk_size;
@@ -25,10 +26,20 @@ struct file_fmt {
 struct file_data {
     char    subchunk_id[4];
     int     subchunk_size;
-    int     num_samples;
+    int     num_samples;    // Not read from the file, just helpful to store here
     short*  samples;
 };
 
+struct wav_file {
+    file_header header;
+    file_fmt fmt;
+    file_data data;
+};
+
+/*****************************************
+ * Functions for reading from a wav file *
+ *****************************************/
+/* Get an int from a byte buffer of size 4 */
 int int_from_buffer(char buf[]) {
     int value =
         ((buf[3] & 0xFF) << 24) |
@@ -38,6 +49,7 @@ int int_from_buffer(char buf[]) {
     return value;
 }
 
+/* Get a short from a byte buffer of size 2 */
 short short_from_buffer(char buf[]) {
     short value =
         ((buf[1] & 0xFF) << 8) |
@@ -45,20 +57,7 @@ short short_from_buffer(char buf[]) {
     return value;
 }
 
-float float_from_buffer(char buf[], int size) {
-    if (size == 2) {
-        return
-            ((buf[1] & 0xFF) << 8) |
-            (buf[0] & 0xFF);
-    } else {
-        return
-            ((buf[3] & 0xFF) << 24) |
-            ((buf[2] & 0xFF) << 16) |
-            ((buf[1] & 0xFF) << 8) |
-            (buf[0] & 0xFF);
-    }
-}
-
+/* Use file to fill out the provided header */
 void get_file_header(file_header &header, ifstream &file) {
     file.read(header.chunk_id, 4);
 
@@ -69,6 +68,7 @@ void get_file_header(file_header &header, ifstream &file) {
     file.read(header.format, 4);
 }
 
+/* Use file to fill out the provided format subchunk */
 void get_file_format(file_fmt &fmt, ifstream &file) {
     file.read(fmt.subchunk_id, 4);
 
@@ -101,6 +101,7 @@ void get_file_format(file_fmt &fmt, ifstream &file) {
     fmt.bits_per_sample = short_from_buffer(bits_per_sample);
 }
 
+/* Use file to fill out the provided data subchunk */
 void get_file_data(file_data &data, ifstream &file, int sample_size) {
     file.read(data.subchunk_id, 4);
 
@@ -113,58 +114,135 @@ void get_file_data(file_data &data, ifstream &file, int sample_size) {
     short samples[num_samples];
     for (int i = 0; i < num_samples; i++) {
         char value[2];
-        samples[i] = float_from_buffer(value, 2);
+        file.read(value, 2);
+        samples[i] = short_from_buffer(value);
     }
     data.samples = samples;
 }
 
+/* Read the filename given and store all wav file data into the returned wav_file */
+wav_file read_file(char* filename) {
+    ifstream file = ifstream(filename);
+    wav_file wav;
+    get_file_header(wav.header, file);
+    get_file_format(wav.fmt, file);
+    get_file_data(wav.data, file, wav.fmt.block_align);
+    file.close();
+    return wav;
+}
+
+/***************************************
+ * Functions for writing to a wav file *
+ ***************************************/
+/* Write an integer in little endian format to the file stream */
+void fwriteIntLSB(int data, ofstream &file) {
+    char array[4];
+
+    array[3] = (unsigned char)((data >> 24) & 0xFF);
+    array[2] = (unsigned char)((data >> 16) & 0xFF);
+    array[1] = (unsigned char)((data >> 8) & 0xFF);
+    array[0] = (unsigned char)(data & 0xFF);
+    file.write((char *)array, 4);
+}
+
+/* Write a short in little endian format to the file stream */
+void fwriteShortLSB(short data, ofstream &file) {
+    char array[2];
+
+    array[1] = (unsigned char)((data >> 8) & 0xFF);
+    array[0] = (unsigned char)(data & 0xFF);
+    file.write((char *)array, 2);
+}
+
+/* Write the fileheader to an open output filestream */
+void write_file_header(file_header header, ofstream &file) {
+    file.write(header.chunk_id, 4);
+    fwriteIntLSB(header.chunk_size, file);
+    file.write(header.format, 4);
+}
+
+/* Write the file format subchunk to an open output filestream */
+void write_file_format(file_fmt fmt, ofstream &file) {
+    file.write(fmt.subchunk_id, 4);
+    fwriteIntLSB(fmt.subchunk_size, file);
+    fwriteShortLSB(fmt.audio_format, file);
+    fwriteShortLSB(fmt.num_channels, file);
+    fwriteIntLSB(fmt.sample_rate, file);
+    fwriteIntLSB(fmt.byte_rate, file);
+    fwriteShortLSB(fmt.block_align, file);
+    fwriteShortLSB(fmt.bits_per_sample, file);
+}
+
+/* Write the data subchunk to an open output filestream */
+void write_file_data(file_data data, ofstream &file, int block_align) {
+    file.write(data.subchunk_id, 4);
+    fwriteIntLSB(data.subchunk_size, file);
+    
+    for (int i = 0; i < data.num_samples; i++) {
+        if (block_align == 2) {
+            fwriteShortLSB(data.samples[i], file);
+        } else {
+            fwriteIntLSB(data.samples[i], file);
+        }
+    }
+}
+
+void write_to_file(wav_file wav, char* filename) {
+    ofstream file = ofstream(filename);
+    write_file_header(wav.header, file);
+    write_file_format(wav.fmt, file);
+    write_file_data(wav.data, file, wav.fmt.block_align);
+    file.close();
+}
+
+/***************************
+ * Miscellaneous functions *
+ ***************************/
+/* Some potentially helpful print statements for developing help */
 void print_id(char buf[]) {
     for (int i = 0; i < 4; i++) {
         printf("%c", buf[i]);
     }
     printf("\n");
 }
-
-void print_file_data(file_header header, file_fmt fmt, file_data data) {
+void print_file_data(wav_file wav) {
     printf("HEADER\n");
     printf("Chunk ID: ");
-    print_id(header.chunk_id);
-    printf("Chunk Size: %d\n", header.chunk_size);
+    print_id(wav.header.chunk_id);
+    printf("Chunk Size: %d\n", wav.header.chunk_size);
     printf("Format: ");
-    print_id(header.format);
+    print_id(wav.header.format);
     
     printf("\nFMT\n");
     printf("Subchunk ID: ");
-    print_id(fmt.subchunk_id);
-    printf("Subchunk Size: %d\n", fmt.subchunk_size);
-    printf("Audio Format: %d\n", fmt.audio_format);
-    printf("Num Channels: %d\n", fmt.num_channels);
-    printf("Sample Rate: %d\n", fmt.sample_rate);
-    printf("Byte Rate: %d\n", fmt.byte_rate);
-    printf("Block Align: %d\n", fmt.block_align);
-    printf("Bits Per Sample: %d\n", fmt.bits_per_sample);
+    print_id(wav.fmt.subchunk_id);
+    printf("Subchunk Size: %d\n", wav.fmt.subchunk_size);
+    printf("Audio Format: %d\n", wav.fmt.audio_format);
+    printf("Num Channels: %d\n", wav.fmt.num_channels);
+    printf("Sample Rate: %d\n", wav.fmt.sample_rate);
+    printf("Byte Rate: %d\n", wav.fmt.byte_rate);
+    printf("Block Align: %d\n", wav.fmt.block_align);
+    printf("Bits Per Sample: %d\n", wav.fmt.bits_per_sample);
 
     printf("\nDATA\n");
     printf("Subchunk ID: ");
-    print_id(data.subchunk_id);
-    printf("Subchunk Size: %d\n", data.subchunk_size);
-    printf("Sample Count: %d\n", data.num_samples);
+    print_id(wav.data.subchunk_id);
+    printf("Subchunk Size: %d\n", wav.data.subchunk_size);
+    printf("Sample Count: %d\n", wav.data.num_samples);
 }
 
+/********
+ * Main *
+ ********/
 int main(int argc, char* argv[]) {
-    file_header header;
-    file_fmt fmt;
-    file_data data;
     if (argc != 4) {
-        printf("Usage: convolve <input_file> <IR_file> <output_file>\n");
+        printf("Usage: %s <input_file> <IR_file> <output_file>\n", argv[0]);
         exit(EXIT_FAILURE);
     }
 
-    ifstream file = ifstream(argv[1]);
-    get_file_header(header, file);
-    get_file_format(fmt, file);
-    get_file_data(data, file, fmt.block_align);
-    print_file_data(header, fmt, data);
+    wav_file wav = read_file(argv[1]);
+    print_file_data(wav);
+    write_to_file(wav, argv[3]);
 
     return EXIT_SUCCESS;
 }

commit 1857b9047ec738bee1b50dd7e8152a7f907346e9
Author: alexs2112 <alexste2112@gmail.com>
Date:   Mon Nov 20 13:36:14 2023 -0700

    get data subchunk

diff --git a/convolve.cpp b/convolve.cpp
index 6122762..90857e9 100644
--- a/convolve.cpp
+++ b/convolve.cpp
@@ -5,13 +5,13 @@
 
 using namespace std;
 
-struct file_header{
+struct file_header {
     char    chunk_id[4];
     int     chunk_size;
     char    format[4];
 };
 
-struct file_fmt{
+struct file_fmt {
     char    subchunk_id[4];
     int     subchunk_size;
     short   audio_format;
@@ -22,6 +22,13 @@ struct file_fmt{
     short   bits_per_sample;
 };
 
+struct file_data {
+    char    subchunk_id[4];
+    int     subchunk_size;
+    int     num_samples;
+    short*  samples;
+};
+
 int int_from_buffer(char buf[]) {
     int value =
         ((buf[3] & 0xFF) << 24) |
@@ -38,6 +45,20 @@ short short_from_buffer(char buf[]) {
     return value;
 }
 
+float float_from_buffer(char buf[], int size) {
+    if (size == 2) {
+        return
+            ((buf[1] & 0xFF) << 8) |
+            (buf[0] & 0xFF);
+    } else {
+        return
+            ((buf[3] & 0xFF) << 24) |
+            ((buf[2] & 0xFF) << 16) |
+            ((buf[1] & 0xFF) << 8) |
+            (buf[0] & 0xFF);
+    }
+}
+
 void get_file_header(file_header &header, ifstream &file) {
     file.read(header.chunk_id, 4);
 
@@ -80,16 +101,41 @@ void get_file_format(file_fmt &fmt, ifstream &file) {
     fmt.bits_per_sample = short_from_buffer(bits_per_sample);
 }
 
-void print_file_data(file_header &header, file_fmt &fmt) {
-    // For some reason this adds some extra stuff when printing id and
-    // format, even though the length of each is 4
+void get_file_data(file_data &data, ifstream &file, int sample_size) {
+    file.read(data.subchunk_id, 4);
+
+    char size[4];
+    file.read(size, 4);
+    data.subchunk_size = int_from_buffer(size);
+
+    int num_samples = data.subchunk_size / sample_size;
+    data.num_samples = num_samples;
+    short samples[num_samples];
+    for (int i = 0; i < num_samples; i++) {
+        char value[2];
+        samples[i] = float_from_buffer(value, 2);
+    }
+    data.samples = samples;
+}
+
+void print_id(char buf[]) {
+    for (int i = 0; i < 4; i++) {
+        printf("%c", buf[i]);
+    }
+    printf("\n");
+}
+
+void print_file_data(file_header header, file_fmt fmt, file_data data) {
     printf("HEADER\n");
-    printf("Chunk ID: %s\n", header.chunk_id);
+    printf("Chunk ID: ");
+    print_id(header.chunk_id);
     printf("Chunk Size: %d\n", header.chunk_size);
-    printf("Format: %s\n", header.format);
+    printf("Format: ");
+    print_id(header.format);
     
     printf("\nFMT\n");
-    printf("Subchunk ID: %s\n", fmt.subchunk_id);
+    printf("Subchunk ID: ");
+    print_id(fmt.subchunk_id);
     printf("Subchunk Size: %d\n", fmt.subchunk_size);
     printf("Audio Format: %d\n", fmt.audio_format);
     printf("Num Channels: %d\n", fmt.num_channels);
@@ -97,11 +143,18 @@ void print_file_data(file_header &header, file_fmt &fmt) {
     printf("Byte Rate: %d\n", fmt.byte_rate);
     printf("Block Align: %d\n", fmt.block_align);
     printf("Bits Per Sample: %d\n", fmt.bits_per_sample);
+
+    printf("\nDATA\n");
+    printf("Subchunk ID: ");
+    print_id(data.subchunk_id);
+    printf("Subchunk Size: %d\n", data.subchunk_size);
+    printf("Sample Count: %d\n", data.num_samples);
 }
 
 int main(int argc, char* argv[]) {
     file_header header;
     file_fmt fmt;
+    file_data data;
     if (argc != 4) {
         printf("Usage: convolve <input_file> <IR_file> <output_file>\n");
         exit(EXIT_FAILURE);
@@ -110,7 +163,8 @@ int main(int argc, char* argv[]) {
     ifstream file = ifstream(argv[1]);
     get_file_header(header, file);
     get_file_format(fmt, file);
-    print_file_data(header, fmt);
+    get_file_data(data, file, fmt.block_align);
+    print_file_data(header, fmt, data);
 
     return EXIT_SUCCESS;
 }

commit 5ff9fa6fcd2540c9be2800357ac50dab3ae3781e
Author: alexander.stevenson <alexander.stevenson@csx2.uc.ucalgary.ca>
Date:   Mon Nov 20 10:56:20 2023 -0700

    initial commit

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..438ad72
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,3 @@
+.vscode/
+audio/
+convolve
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..3047418
--- /dev/null
+++ b/Makefile
@@ -0,0 +1 @@
+convolve: convolve.cpp
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..57e54a4
--- /dev/null
+++ b/README.md
@@ -0,0 +1,2 @@
+# CPSC 501 - Convolution
+Usage: convolve <input_file> <IR_file> <output_file>
diff --git a/convolve.cpp b/convolve.cpp
new file mode 100644
index 0000000..6122762
--- /dev/null
+++ b/convolve.cpp
@@ -0,0 +1,116 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <iostream>
+#include <fstream>
+
+using namespace std;
+
+struct file_header{
+    char    chunk_id[4];
+    int     chunk_size;
+    char    format[4];
+};
+
+struct file_fmt{
+    char    subchunk_id[4];
+    int     subchunk_size;
+    short   audio_format;
+    short   num_channels;
+    int     sample_rate;
+    int     byte_rate;
+    short   block_align;
+    short   bits_per_sample;
+};
+
+int int_from_buffer(char buf[]) {
+    int value =
+        ((buf[3] & 0xFF) << 24) |
+        ((buf[2] & 0xFF) << 16) |
+        ((buf[1] & 0xFF) << 8) |
+        (buf[0] & 0xFF);
+    return value;
+}
+
+short short_from_buffer(char buf[]) {
+    short value =
+        ((buf[1] & 0xFF) << 8) |
+        (buf[0] & 0xFF);
+    return value;
+}
+
+void get_file_header(file_header &header, ifstream &file) {
+    file.read(header.chunk_id, 4);
+
+    char size[4];
+    file.read(size, 4);
+    header.chunk_size = int_from_buffer(size);
+
+    file.read(header.format, 4);
+}
+
+void get_file_format(file_fmt &fmt, ifstream &file) {
+    file.read(fmt.subchunk_id, 4);
+
+    char size[4];
+    file.read(size, 4);
+    fmt.subchunk_size = int_from_buffer(size);
+
+    char audio_format[2];
+    file.read(audio_format, 2);
+    fmt.audio_format = short_from_buffer(audio_format);
+
+    char num_channels[2];
+    file.read(num_channels, 2);
+    fmt.num_channels = short_from_buffer(num_channels);
+
+    char sample_rate[4];
+    file.read(sample_rate, 4);
+    fmt.sample_rate = int_from_buffer(sample_rate);
+
+    char byte_rate[4];
+    file.read(byte_rate, 4);
+    fmt.byte_rate = int_from_buffer(byte_rate);
+
+    char block_align[2];
+    file.read(block_align, 2);
+    fmt.block_align = short_from_buffer(block_align);
+
+    char bits_per_sample[2];
+    file.read(bits_per_sample, 2);
+    fmt.bits_per_sample = short_from_buffer(bits_per_sample);
+}
+
+void print_file_data(file_header &header, file_fmt &fmt) {
+    // For some reason this adds some extra stuff when printing id and
+    // format, even though the length of each is 4
+    printf("HEADER\n");
+    printf("Chunk ID: %s\n", header.chunk_id);
+    printf("Chunk Size: %d\n", header.chunk_size);
+    printf("Format: %s\n", header.format);
+    
+    printf("\nFMT\n");
+    printf("Subchunk ID: %s\n", fmt.subchunk_id);
+    printf("Subchunk Size: %d\n", fmt.subchunk_size);
+    printf("Audio Format: %d\n", fmt.audio_format);
+    printf("Num Channels: %d\n", fmt.num_channels);
+    printf("Sample Rate: %d\n", fmt.sample_rate);
+    printf("Byte Rate: %d\n", fmt.byte_rate);
+    printf("Block Align: %d\n", fmt.block_align);
+    printf("Bits Per Sample: %d\n", fmt.bits_per_sample);
+}
+
+int main(int argc, char* argv[]) {
+    file_header header;
+    file_fmt fmt;
+    if (argc != 4) {
+        printf("Usage: convolve <input_file> <IR_file> <output_file>\n");
+        exit(EXIT_FAILURE);
+    }
+
+    ifstream file = ifstream(argv[1]);
+    get_file_header(header, file);
+    get_file_format(fmt, file);
+    print_file_data(header, fmt);
+
+    return EXIT_SUCCESS;
+}
